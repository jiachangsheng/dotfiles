- Using Emacs 30.1 @ c:/Users/jiacs/scoop/apps/emacs/current/bin/emacs.exe
> Synchronizing "default" profile...
  > Regenerating envvars file
    âœ“ Generated ~/.emacs.d/.local/env
  > Ensuring packages are installed and built...
    > Updating recipe repos...
      > Updating recipes for melpa...

Error: error ("Failed to run \"git\" \"fetch\" \"origin\", see buffer *straight-process*")
  error("Failed to run %s, see %s" "\"git\" \"fetch\" \"origin\"" "buffer *straight-process*")
  (if success (let ((output (concat stdout stderr))) (if straight--process-trim (string-trim output) output)) (error "Failed to run %s, see %s" (mapconcat #'shell-quote-argument (cons program args) " ") (if straight-process-messages "prior messages" (format "buffer %s" straight-process-buffer))))
  (let* ((result (apply #'straight--process-run program args)) (exit (car result)) (invoked (numberp exit)) (success (and invoked (= 0 exit))) (failure (not success)) (stdout (nth 1 result)) (stderr (nth 2 result))) (ignore result exit invoked success failure stdout stderr) (if success (let ((output (concat stdout stderr))) (if straight--process-trim (string-trim output) output)) (error "Failed to run %s, see %s" (mapconcat #'shell-quote-argument (cons program args) " ") (if straight-process-messages "prior messages" (format "buffer %s" straight-process-buffer)))))
  straight--process-output("git" "fetch" "origin")
  (and (straight-vc-git--ensure-remotes recipe) (straight--process-output "git" "fetch" remote) (throw '--cl-block-nil-- t))
  (while t (and (straight-vc-git--ensure-remotes recipe) (straight--process-output "git" "fetch" remote) (throw '--cl-block-nil-- t)))
  (let ((repo (if from-upstream upstream-repo repo)) (remote (if from-upstream upstream-remote remote))) (if repo nil (throw '--cl-block-nil-- t)) (while t (and (straight-vc-git--ensure-remotes recipe) (straight--process-output "git" "fetch" remote) (throw '--cl-block-nil-- t))))
  (let ((upstream-repo (plist-get --recipe-- ':repo)) (upstream-remote (cond ((plist-member --recipe-- ':remote) (plist-get --recipe-- ':remote)) ((equal straight-vc-git-primary-remote "origin") straight-vc-git-default-remote-name) (t straight-vc-git-primary-remote))) (repo (let* ((fork (and t (plist-get --recipe-- :fork)))) (if fork (plist-get fork ':repo) (plist-get --recipe-- ':repo)))) (remote (let* ((fork (and t (plist-get --recipe-- :fork)))) (if fork (cond ((plist-member fork ':remote) (plist-get fork ':remote)) (t straight-vc-git-default-fork-name)) (cond ((plist-member --recipe-- ':remote) (plist-get --recipe-- ':remote)) ((equal straight-vc-git-primary-remote "origin") straight-vc-git-default-remote-name) (t straight-vc-git-primary-remote))))) (fork (plist-get --recipe-- ':fork))) (if (and from-upstream (not fork)) (progn (throw '--cl-block-nil-- t))) (let ((repo (if from-upstream upstream-repo repo)) (remote (if from-upstream upstream-remote remote))) (if repo nil (throw '--cl-block-nil-- t)) (while t (and (straight-vc-git--ensure-remotes recipe) (straight--process-output "git" "fetch" remote) (throw '--cl-block-nil-- t)))))
  (let ((--recipe-- recipe)) (let* ((--cl-rest-- --recipe--) (upstream (car (cdr (plist-member --cl-rest-- ':upstream)))) (repo (car (cdr (plist-member --cl-rest-- ':repo)))) (host (car (cdr (plist-member --cl-rest-- ':host)))) (branch (car (cdr (plist-member --cl-rest-- ':branch))))) (if upstream (progn (setq --recipe-- (cl-copy-list --recipe--)) (setq --recipe-- (plist-put --recipe-- :fork (list :repo repo :host host :branch branch :remote straight-vc-git-primary-remote))) (let ((tail '(:host :repo))) (while tail (let ((kw (car tail))) (setq --recipe-- (plist-put --recipe-- kw (plist-get upstream kw))) (setq tail (cdr tail))))) (setq --recipe-- (plist-put --recipe-- :branch (plist-get upstream :branch))) (setq --recipe-- (plist-put --recipe-- :remote straight-vc-git-upstream-remote))))) (let ((upstream-repo (plist-get --recipe-- ':repo)) (upstream-remote (cond ((plist-member --recipe-- ':remote) (plist-get --recipe-- ':remote)) ((equal straight-vc-git-primary-remote "origin") straight-vc-git-default-remote-name) (t straight-vc-git-primary-remote))) (repo (let* ((fork (and t (plist-get --recipe-- :fork)))) (if fork (plist-get fork ':repo) (plist-get --recipe-- ':repo)))) (remote (let* ((fork (and t (plist-get --recipe-- :fork)))) (if fork (cond ((plist-member fork ':remote) (plist-get fork ':remote)) (t straight-vc-git-default-fork-name)) (cond ((plist-member --recipe-- ':remote) (plist-get --recipe-- ':remote)) ((equal straight-vc-git-primary-remote "origin") straight-vc-git-default-remote-name) (t straight-vc-git-primary-remote))))) (fork (plist-get --recipe-- ':fork))) (if (and from-upstream (not fork)) (progn (throw '--cl-block-nil-- t))) (let ((repo (if from-upstream upstream-repo repo)) (remote (if from-upstream upstream-remote remote))) (if repo nil (throw '--cl-block-nil-- t)) (while t (and (straight-vc-git--ensure-remotes recipe) (straight--process-output "git" "fetch" remote) (throw '--cl-block-nil-- t))))))
  (catch '--cl-block-nil-- (let ((--recipe-- recipe)) (let* ((--cl-rest-- --recipe--) (upstream (car (cdr (plist-member --cl-rest-- ':upstream)))) (repo (car (cdr (plist-member --cl-rest-- ':repo)))) (host (car (cdr (plist-member --cl-rest-- ':host)))) (branch (car (cdr (plist-member --cl-rest-- ':branch))))) (if upstream (progn (setq --recipe-- (cl-copy-list --recipe--)) (setq --recipe-- (plist-put --recipe-- :fork (list :repo repo :host host :branch branch :remote straight-vc-git-primary-remote))) (let ((tail '(:host :repo))) (while tail (let ((kw (car tail))) (setq --recipe-- (plist-put --recipe-- kw (plist-get upstream kw))) (setq tail (cdr tail))))) (setq --recipe-- (plist-put --recipe-- :branch (plist-get upstream :branch))) (setq --recipe-- (plist-put --recipe-- :remote straight-vc-git-upstream-remote))))) (let ((upstream-repo (plist-get --recipe-- ':repo)) (upstream-remote (cond ((plist-member --recipe-- ':remote) (plist-get --recipe-- ':remote)) ((equal straight-vc-git-primary-remote "origin") straight-vc-git-default-remote-name) (t straight-vc-git-primary-remote))) (repo (let* ((fork (and t (plist-get --recipe-- :fork)))) (if fork (plist-get fork ':repo) (plist-get --recipe-- ':repo)))) (remote (let* ((fork (and t (plist-get --recipe-- :fork)))) (if fork (cond ((plist-member fork ':remote) (plist-get fork ':remote)) (t straight-vc-git-default-fork-name)) (cond ((plist-member --recipe-- ':remote) (plist-get --recipe-- ':remote)) ((equal straight-vc-git-primary-remote "origin") straight-vc-git-default-remote-name) (t straight-vc-git-primary-remote))))) (fork (plist-get --recipe-- ':fork))) (if (and from-upstream (not fork)) (progn (throw '--cl-block-nil-- t))) (let ((repo (if from-upstream upstream-repo repo)) (remote (if from-upstream upstream-remote remote))) (if repo nil (throw '--cl-block-nil-- t)) (while t (and (straight-vc-git--ensure-remotes recipe) (straight--process-output "git" "fetch" remote) (throw '--cl-block-nil-- t)))))))
  straight-vc-git-fetch-from-remote((:type git :host github :repo "melpa/melpa" :build nil :package "melpa" :local-repo "melpa"))
  apply(straight-vc-git-fetch-from-remote (:type git :host github :repo "melpa/melpa" :build nil :package "melpa" :local-repo "melpa"))
  (let ((func (intern (format "straight-vc-%S-%S" type method)))) (if (fboundp func) nil (let ((regexp (format "^straight-vc-%S-[a-z-]+$" type))) (if (catch '--cl-block-nil-- (prog1 nil (mapatoms #'(lambda (sym) (if (and (fboundp sym) (string-match-p regexp (symbol-name sym))) (progn (throw '--cl-block-nil-- t))))))) (error "VC backend `%S' does not implement method `%S'" type method) (error "No such VC backend `%S'" type)))) (apply func args))
  straight-vc(fetch-from-remote git (:type git :host github :repo "melpa/melpa" :build nil :package "melpa" :local-repo "melpa"))
  (let ((straight--default-directory (straight--repos-dir local-repo))) (straight-vc 'fetch-from-remote type recipe))
  (progn (let ((straight--default-directory (straight--repos-dir local-repo))) (straight-vc 'fetch-from-remote type recipe)))
  (if local-repo (progn (let ((straight--default-directory (straight--repos-dir local-repo))) (straight-vc 'fetch-from-remote type recipe))))
  (let* ((--cl-rest-- recipe) (local-repo (car (cdr (plist-member --cl-rest-- ':local-repo)))) (type (car (cdr (plist-member --cl-rest-- ':type))))) (if local-repo (progn (let ((straight--default-directory (straight--repos-dir local-repo))) (straight-vc 'fetch-from-remote type recipe)))))
  straight-vc-fetch-from-remote((:type git :host github :repo "melpa/melpa" :build nil :package "melpa" :local-repo "melpa"))
  (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t))))
  (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output)))))))))))
  (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output))))))))))))
  (let* ((--cl-rest-- (append (list :recipe recipe) recipe)) (recipe (car (cdr (plist-member --cl-rest-- ':recipe)))) (package (car (cdr (plist-member --cl-rest-- ':package)))) (type (car (cdr (plist-member --cl-rest-- ':type)))) (local-repo (car (cdr (plist-member --cl-rest-- ':local-repo))))) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output)))))))))))))
  (cl-destructuring-bind (&key recipe package type local-repo &allow-other-keys) (append (list :recipe recipe) recipe) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output)))))))))))))
  (straight--with-plist (append (list :recipe recipe) recipe) (recipe package type local-repo) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output)))))))))))))
  (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (recipe package type local-repo) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output))))))))))))) (setq tail (cdr tail)))
  (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (recipe package type local-repo) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output))))))))))))) (setq tail (cdr tail))))
  (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (recipe package type local-repo) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output))))))))))))) (setq tail (cdr tail)))) (nreverse built))
  (let* ((recipes (delq nil (mapcar (doom-rpartial #'gethash straight--repo-cache) (mapcar #'symbol-name straight-recipe-repositories)))) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (recipe package type local-repo) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output))))))))))))) (setq tail (cdr tail)))) (nreverse built)))
  (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((recipes (delq nil (mapcar (doom-rpartial #'gethash straight--repo-cache) (mapcar #'symbol-name straight-recipe-repositories)))) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (recipe package type local-repo) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output))))))))))))) (setq tail (cdr tail)))) (nreverse built))))
  (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((recipes (delq nil (mapcar (doom-rpartial #'gethash straight--repo-cache) (mapcar #'symbol-name straight-recipe-repositories)))) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (recipe package type local-repo) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output))))))))))))) (setq tail (cdr tail)))) (nreverse built)))))
  (if doom-packages--cli-updated-recipes nil (straight--make-build-cache-available) (doom-print (doom-print--format (doom-print--class 'start "Updating recipe repos..."))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((recipes (delq nil (mapcar (doom-rpartial #'gethash straight--repo-cache) (mapcar #'symbol-name straight-recipe-repositories)))) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (recipe package type local-repo) (let ((esc (if init-file-debug "" "\33[1A")) (ref (straight-vc-get-commit type local-repo)) newref output) (doom-print (doom-print--format (doom-print--class 'start "\15Updating recipes for %s...%s") package esc)) (let ((alist (let* ((buffer (straight--process-buffer)) (start (save-current-buffer (set-buffer buffer) (point-max))) (retval (straight-vc-fetch-from-remote recipe)) (output (save-current-buffer (set-buffer buffer) (buffer-substring start (point-max))))) (let ((saved-match-data (match-data))) (unwind-protect (progn (list (cons 'it retval) (cons 'stdout (substring-no-properties output)) (cons 'success (if (string-match "\n+\\[Return code: \\([0-9-]+\\)\\]\n+" output) (string-to-number (match-string 1 output)))) (cons 'output (string-trim output "^\\(\\$ [^\n]+\n\\)*\n+" "\n+\\[Return code: [0-9-]+\\]\n+")))) (set-match-data saved-match-data t)))))) (let ((\.it (cdr (assq 'it alist))) (\.output (cdr (assq 'output alist)))) (if \.it (progn (setq output \.output) (straight-merge-package package) (if (equal ref (setq newref (straight-vc-get-commit type local-repo))) nil (doom-print (doom-print--format (doom-print--class 'success "\15%s updated (%s -> %s)") package (doom-packages--abbrev-commit ref) (doom-packages--abbrev-commit newref))) (if (string-empty-p output) nil (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (doom-print (doom-print--format (doom-print--class 'item "%s" output))))))))))))) (setq tail (cdr tail)))) (nreverse built))))) (progn (setq straight--recipe-lookup-cache (make-hash-table :test #'eq)) (setq doom-packages--cli-updated-recipes t)))
  doom-packages--cli-recipes-update()
  (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update))
  (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))
  (let* ((--cl-rest-- (append (list :recipe recipe) recipe)) (package (car (cdr (plist-member --cl-rest-- ':package)))) (local-repo (car (cdr (plist-member --cl-rest-- ':local-repo)))) (recipe (car (cdr (plist-member --cl-rest-- ':recipe))))) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e))))))
  (cl-destructuring-bind (&key package local-repo recipe &allow-other-keys) (append (list :recipe recipe) recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e))))))
  (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e))))))
  (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))) (setq tail (cdr tail)))
  (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))) (setq tail (cdr tail))))
  (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))) (setq tail (cdr tail)))) (nreverse built))
  (let* ((recipes recipes) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))) (setq tail (cdr tail)))) (nreverse built)))
  (and t (let* ((recipes recipes) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))) (setq tail (cdr tail)))) (nreverse built))))
  (let* ((built (and t (let* ((recipes recipes) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))) (setq tail (cdr tail)))) (nreverse built)))))) (if built (progn (if (and (featurep 'native-compile) straight--native-comp-available) (progn (doom-packages--compile-site-files) (doom-packages--wait-for-native-compile-jobs) (doom-packages--write-missing-eln-errors))) (delete-directory (straight--modified-dir) 'recursive) (doom-print (doom-print--format (doom-print--class 'success "\15Built %d package(s)") (length built)))) (doom-print (doom-print--format (doom-print--class 'item "No packages need attention"))) nil))
  (let ((straight-check-for-modifications (if (file-directory-p (straight--modified-dir)) (progn '(find-when-checking)))) (straight--allow-find (and straight-check-for-modifications (executable-find straight-find-executable) t)) (straight--packages-not-to-rebuild (or straight--packages-not-to-rebuild (make-hash-table :test #'equal))) (straight--packages-to-rebuild (or (if force-p :all straight--packages-to-rebuild) (make-hash-table :test #'equal))) (recipes (doom-package-recipe-alist)) (pinned (doom-package-pinned-alist))) (add-hook 'native-comp-async-cu-done-functions #'doom-packages--native-compile-done-h) (straight--make-build-cache-available) (let* ((built (and t (let* ((recipes recipes) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))) (setq tail (cdr tail)))) (nreverse built)))))) (if built (progn (if (and (featurep 'native-compile) straight--native-comp-available) (progn (doom-packages--compile-site-files) (doom-packages--wait-for-native-compile-jobs) (doom-packages--write-missing-eln-errors))) (delete-directory (straight--modified-dir) 'recursive) (doom-print (doom-print--format (doom-print--class 'success "\15Built %d package(s)") (length built)))) (doom-print (doom-print--format (doom-print--class 'item "No packages need attention"))) nil)))
  (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((straight-check-for-modifications (if (file-directory-p (straight--modified-dir)) (progn '(find-when-checking)))) (straight--allow-find (and straight-check-for-modifications (executable-find straight-find-executable) t)) (straight--packages-not-to-rebuild (or straight--packages-not-to-rebuild (make-hash-table :test #'equal))) (straight--packages-to-rebuild (or (if force-p :all straight--packages-to-rebuild) (make-hash-table :test #'equal))) (recipes (doom-package-recipe-alist)) (pinned (doom-package-pinned-alist))) (add-hook 'native-comp-async-cu-done-functions #'doom-packages--native-compile-done-h) (straight--make-build-cache-available) (let* ((built (and t (let* ((recipes recipes) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))) (setq tail (cdr tail)))) (nreverse built)))))) (if built (progn (if (and (featurep 'native-compile) straight--native-comp-available) (progn (doom-packages--compile-site-files) (doom-packages--wait-for-native-compile-jobs) (doom-packages--write-missing-eln-errors))) (delete-directory (straight--modified-dir) 'recursive) (doom-print (doom-print--format (doom-print--class 'success "\15Built %d package(s)") (length built)))) (doom-print (doom-print--format (doom-print--class 'item "No packages need attention"))) nil))))
  (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((straight-check-for-modifications (if (file-directory-p (straight--modified-dir)) (progn '(find-when-checking)))) (straight--allow-find (and straight-check-for-modifications (executable-find straight-find-executable) t)) (straight--packages-not-to-rebuild (or straight--packages-not-to-rebuild (make-hash-table :test #'equal))) (straight--packages-to-rebuild (or (if force-p :all straight--packages-to-rebuild) (make-hash-table :test #'equal))) (recipes (doom-package-recipe-alist)) (pinned (doom-package-pinned-alist))) (add-hook 'native-comp-async-cu-done-functions #'doom-packages--native-compile-done-h) (straight--make-build-cache-available) (let* ((built (and t (let* ((recipes recipes) (built nil) (straight-use-package-pre-build-functions (cons #'(lambda (pkg &rest _) (setq built (if (member pkg built) built (cons pkg built)))) straight-use-package-pre-build-functions))) (let ((tail recipes)) (while tail (let ((recipe (car tail))) (straight--with-plist (append (list :recipe recipe) recipe) (package local-repo recipe) (let ((repo-dir (straight--repos-dir (or local-repo package))) (build-dir (straight--build-dir package))) (if force-p nil (let* ((build (if (plist-member recipe :build) (plist-get recipe :build) t)) (want-byte-compile (or (eq build t) (memq 'compile build))) (want-native-compile (or (eq build t) (memq 'native-compile build)))) (and (eq (car-safe build) :not) (progn (setq want-byte-compile (not want-byte-compile)) (setq want-native-compile (not want-native-compile)))) (if (or (not (featurep 'native-compile)) (not straight--native-comp-available)) (progn (setq want-native-compile nil))) (and (or want-byte-compile want-native-compile) (or (file-newer-than-file-p repo-dir build-dir) (file-exists-p (straight--modified-dir package)) (let* ((outdated nil) (--cl-var-- (doom-files-in build-dir :match "\\.el$" :full t)) (file nil)) (while (consp --cl-var--) (setq file (car --cl-var--)) (if (or (if want-byte-compile (doom-packages--elc-file-outdated-p file)) (if want-native-compile (doom-packages--eln-file-outdated-p file))) (progn (setq outdated t) (if want-native-compile (progn (setq doom-packages--eln-output-expected (cons file doom-packages--eln-output-expected)))))) (setq --cl-var-- (cdr --cl-var--))) outdated)) (puthash package t straight--packages-to-rebuild)))) (if (file-directory-p repo-dir) nil (doom-packages--cli-recipes-update)) (condition-case e (let ((straight-vc-git-post-clone-hook (cons #'(lambda (&rest --cl-rest--) "\n\n(fn &key COMMIT &allow-other-keys)" (let* ((commit (car (cdr (plist-member --cl-rest-- ':commit))))) (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let* ((pin (and t (cdr (assoc package pinned))))) (if pin (doom-print (doom-print--format (doom-print--class 'item "Pinned to %s") pin)) (if commit (progn (doom-print (doom-print--format (doom-print--class 'item "Checked out %s") commit)))))))))) straight-vc-git-post-clone-hook))) (straight-use-package (intern package)) (if (file-in-directory-p repo-dir straight-base-dir) (progn (let ((try 0)) (while (not (file-directory-p (doom-path repo-dir ".git"))) (if (= try 3) (progn (error "Failed to clone package"))) (doom-print (doom-print--format (doom-print--class 'warn "Failed to clone %S, trying again (attempt #%d)...") package (1+ try))) (delete-directory repo-dir t) (delete-directory build-dir t) (straight-use-package (intern package)) (setq try (1+ try)))) (if doom--system-windows-p (progn (let ((default-directory repo-dir)) (straight--process-run "git" "config" "core.autocrlf" "true"))))))) ((debug error) (signal 'doom-package-error (list package e)))))) (setq tail (cdr tail)))) (nreverse built)))))) (if built (progn (if (and (featurep 'native-compile) straight--native-comp-available) (progn (doom-packages--compile-site-files) (doom-packages--wait-for-native-compile-jobs) (doom-packages--write-missing-eln-errors))) (delete-directory (straight--modified-dir) 'recursive) (doom-print (doom-print--format (doom-print--class 'success "\15Built %d package(s)") (length built)))) (doom-print (doom-print--format (doom-print--class 'item "No packages need attention"))) nil)))))
  doom-packages-ensure(nil)
  (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t)
  (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t))
  (unwind-protect (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t)) (remove-hook 'kill-emacs-hook #'doom-sync--abort-warning-h))
  (let ((emacs-running? (let* ((--cl-var-- (remove (emacs-pid) (list-system-processes))) (pid nil) (attrs nil) (args nil) (--cl-var-- nil) (--cl-var-- t)) (while (consp --cl-var--) (setq pid (car --cl-var--)) (setq attrs (process-attributes pid)) (setq args (alist-get 'args attrs "")) (if (string-match-p "^\\([^ ]+/\\)?[eE]macs" args) (progn (if (not (string-match-p " --batch" args)) (progn (if (not (string-match-p " --script" args)) (progn (setq --cl-var-- (cons pid --cl-var--)))))))) (setq --cl-var-- (cdr --cl-var--)) (setq --cl-var-- nil)) (nreverse --cl-var--)))) (if (doom-profiles-bootloadable-p) (progn (call! '(profile sync "--all" "--reload")))) (run-hooks 'doom-before-sync-hook) (add-hook 'kill-emacs-hook #'doom-sync--abort-warning-h) (doom-print (doom-print--format (doom-print--class 'item "Using Emacs %s @ %s") emacs-version (doom-print--class 'path invocation-directory invocation-name))) (doom-print (doom-print--format (doom-print--class 'start "Synchronizing %S profile...") (or (car doom-profile) "default"))) (unwind-protect (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t)) (remove-hook 'kill-emacs-hook #'doom-sync--abort-warning-h)))
  (let ((noenvvar? (cdr (assq 'noenvvar? alist))) (update? (cdr (assq 'update? alist))) (noupdate? (cdr (assq 'noupdate? alist))) (purge? (cdr (assq 'purge? alist))) (jobs (cdr (assq 'jobs alist))) (rebuild? (cdr (assq 'rebuild? alist))) (nobuild? (cdr (assq 'nobuild? alist))) (aot? (cdr (assq 'aot? alist))) (context (cdr (assq 'context alist)))) (if aot? (progn (progn (eval-after-load 'straight #'(lambda nil (setq straight--native-comp-available t)))))) (if jobs (progn (setq native-comp-async-jobs-number (truncate jobs)))) (let ((emacs-running? (let* ((--cl-var-- (remove (emacs-pid) (list-system-processes))) (pid nil) (attrs nil) (args nil) (--cl-var-- nil) (--cl-var-- t)) (while (consp --cl-var--) (setq pid (car --cl-var--)) (setq attrs (process-attributes pid)) (setq args (alist-get 'args attrs "")) (if (string-match-p "^\\([^ ]+/\\)?[eE]macs" args) (progn (if (not (string-match-p " --batch" args)) (progn (if (not (string-match-p " --script" args)) (progn (setq --cl-var-- (cons pid --cl-var--)))))))) (setq --cl-var-- (cdr --cl-var--)) (setq --cl-var-- nil)) (nreverse --cl-var--)))) (if (doom-profiles-bootloadable-p) (progn (call! '(profile sync "--all" "--reload")))) (run-hooks 'doom-before-sync-hook) (add-hook 'kill-emacs-hook #'doom-sync--abort-warning-h) (doom-print (doom-print--format (doom-print--class 'item "Using Emacs %s @ %s") emacs-version (doom-print--class 'path invocation-directory invocation-name))) (doom-print (doom-print--format (doom-print--class 'start "Synchronizing %S profile...") (or (car doom-profile) "default"))) (unwind-protect (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t)) (remove-hook 'kill-emacs-hook #'doom-sync--abort-warning-h))))
  #f(lambda (cli alist) [t] (let ((noenvvar? (cdr (assq 'noenvvar? alist))) (update? (cdr (assq 'update? alist))) (noupdate? (cdr (assq 'noupdate? alist))) (purge? (cdr (assq 'purge? alist))) (jobs (cdr (assq 'jobs alist))) (rebuild? (cdr (assq 'rebuild? alist))) (nobuild? (cdr (assq 'nobuild? alist))) (aot? (cdr (assq 'aot? alist))) (context (cdr (assq 'context alist)))) (if aot? (progn (progn (eval-after-load 'straight #'(lambda nil (setq straight--native-comp-available t)))))) (if jobs (progn (setq native-comp-async-jobs-number (truncate jobs)))) (let ((emacs-running? (let* ((--cl-var-- (remove (emacs-pid) (list-system-processes))) (pid nil) (attrs nil) (args nil) (--cl-var-- nil) (--cl-var-- t)) (while (consp --cl-var--) (setq pid (car --cl-var--)) (setq attrs (process-attributes pid)) (setq args (alist-get 'args attrs "")) (if (string-match-p "^\\([^ ]+/\\)?[eE]macs" args) (progn (if (not (string-match-p " --batch" args)) (progn (if (not (string-match-p " --script" args)) (progn (setq --cl-var-- (cons pid --cl-var--)))))))) (setq --cl-var-- (cdr --cl-var--)) (setq --cl-var-- nil)) (nreverse --cl-var--)))) (if (doom-profiles-bootloadable-p) (progn (call! '(profile sync "--all" "--reload")))) (run-hooks 'doom-before-sync-hook) (add-hook 'kill-emacs-hook #'doom-sync--abort-warning-h) (doom-print (doom-print--format (doom-print--class 'item "Using Emacs %s @ %s") emacs-version (doom-print--class 'path invocation-directory invocation-name))) (doom-print (doom-print--format (doom-print--class 'start "Synchronizing %S profile...") (or (car doom-profile) "default"))) (unwind-protect (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t)) (remove-hook 'kill-emacs-hook #'doom-sync--abort-warning-h)))))(#s(doom-cli :command ("doom" "sync") :type nil :docs (("SUMMARY" . "Synchronize your config with Doom Emacs.") ("MAIN" . "This is the equivalent of running autoremove, install, autoloads, then\nrecompile. Run this whenever you:\n\n  1. Modify your `doom!' block,\n  2. Add, remove, or modify `package!' blocks to your config,\n  3. Add, remove, or modify autoloaded functions in module autoloaded files,\n  4. Update Doom manually (e.g. with git),\n  5. Move your Doom config (either $EMACSDIR or $DOOMDIR) to a new location.\n  6. Up or downgrade Emacs itself (e.g. 29.1 -> 29.4).\n\nSync'ing ensures that unneeded packages are removed, needed packages are\ninstalled, autoloads files are up-to-date, and no byte-compiled files have gone\nstale.") ("OPTIONS" . "-j, --jobs\n  Defaults to the maximum number of threads (or 1, if your CPU's threadcount\n  can't be determined).\n--aot\n  Will only perform AOT native-compilation for packages updated/installed\n  during the execution of this command. Use --rebuild as well to do so for all\n  packages.")) :autoload nil :alias nil :options (#s(doom-cli-option :symbol noenvvar? :docs "Don't regenerate the envvar file" :multiple-p nil :flag-p nil :switches ("-e") :arguments nil :default nil) #s(doom-cli-option :symbol update? :docs "Update all installed packages after syncing" :multiple-p nil :flag-p nil :switches ("-u") :arguments nil :default nil) #s(doom-cli-option :symbol noupdate? :docs "Don't update any packages" :multiple-p nil :flag-p nil :switches ("-U") :arguments nil :default nil) #s(doom-cli-option :symbol purge? :docs "Purge orphaned package repos & regraft them" :multiple-p nil :flag-p nil :switches ("--gc") :arguments nil :default nil) #s(doom-cli-option :symbol jobs :docs "How many threads to use for native compilation" :multiple-p nil :flag-p nil :switches ("-j" "--jobs") :arguments (num) :default nil) #s(doom-cli-option :symbol rebuild? :docs "Rebuild all installed packages, unconditionally" :multiple-p nil :flag-p nil :switches ("-b" "--rebuild") :arguments nil :default nil) #s(doom-cli-option :symbol nobuild? :docs "Don't rebuild packages when hostname or Emacs version has changed" :multiple-p nil :flag-p nil :switches ("-B") :arguments nil :default nil) #s(doom-cli-option :symbol aot? :docs "Natively compile packages ahead-of-time (if available)" :multiple-p nil :flag-p nil :switches ("--aot") :arguments nil :default nil)) :arguments ((&context context)) :plist (:benchmark t :prefix (doom) :group "Config Management" :docs "Commands for maintaining your Doom Emacs configuration." :hide nil) :fn #f(lambda (cli alist) [t] (let ((noenvvar? (cdr (assq 'noenvvar? alist))) (update? (cdr (assq 'update? alist))) (noupdate? (cdr (assq 'noupdate? alist))) (purge? (cdr (assq 'purge? alist))) (jobs (cdr (assq 'jobs alist))) (rebuild? (cdr (assq 'rebuild? alist))) (nobuild? (cdr (assq 'nobuild? alist))) (aot? (cdr (assq 'aot? alist))) (context (cdr (assq 'context alist)))) (if aot? (progn (progn (eval-after-load 'straight #'(lambda nil (setq straight--native-comp-available t)))))) (if jobs (progn (setq native-comp-async-jobs-number (truncate jobs)))) (let ((emacs-running? (let* ((--cl-var-- (remove (emacs-pid) (list-system-processes))) (pid nil) (attrs nil) (args nil) (--cl-var-- nil) (--cl-var-- t)) (while (consp --cl-var--) (setq pid (car --cl-var--)) (setq attrs (process-attributes pid)) (setq args (alist-get 'args attrs "")) (if (string-match-p "^\\([^ ]+/\\)?[eE]macs" args) (progn (if (not (string-match-p " --batch" args)) (progn (if (not (string-match-p " --script" args)) (progn (setq --cl-var-- (cons pid --cl-var--)))))))) (setq --cl-var-- (cdr --cl-var--)) (setq --cl-var-- nil)) (nreverse --cl-var--)))) (if (doom-profiles-bootloadable-p) (progn (call! '(profile sync "--all" "--reload")))) (run-hooks 'doom-before-sync-hook) (add-hook 'kill-emacs-hook #'doom-sync--abort-warning-h) (doom-print (doom-print--format (doom-print--class 'item "Using Emacs %s @ %s") emacs-version (doom-print--class 'path invocation-directory invocation-name))) (doom-print (doom-print--format (doom-print--class 'start "Synchronizing %S profile...") (or (car doom-profile) "default"))) (unwind-protect (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t)) (remove-hook 'kill-emacs-hook #'doom-sync--abort-warning-h)))))) ((context . #s(doom-cli-context :init-time (26702 23162 356912 0) :pid 10776 :step 0 :geometry (120 . 30) :pipes nil :suppress-prompts-p nil :prefix "doom" :meta-p nil :error nil :command ("doom" "env") :path nil :whole ("--no-color" "sync") :options (("--deny") ("-d") ("--allow") ("-a") ("-o") ("--deny-all") ("--allow-all") ("--reload" . "--reload") ("--all" . "--all") ("--aot") ("-B") ("--rebuild") ("-b") ("--jobs") ("-j") ("--gc") ("-U") ("-u") ("-e") ("--eval") ("-E") ("--strict-load") ("--load") ("-L") ("--color" . :no) ("--benchmark") ("--profile") ("--pager") ("--emacsdir") ("--doomdir") ("--verbose") ("-v") ("--debug") ("-D") ("--force") ("-!")) :arguments ((t) (("doom" "env")) (("doom") "env")) :stdin #<buffer  *doom-cli stdin*> :stdout #<buffer  *doom-cli stdout*> :stderr #<buffer  *doom-cli stderr*> :state nil)) (aot?) (nobuild?) (rebuild?) (jobs) (purge?) (noupdate?) (update?) (noenvvar?)))
  funcall(#f(lambda (cli alist) [t] (let ((noenvvar? (cdr (assq 'noenvvar? alist))) (update? (cdr (assq 'update? alist))) (noupdate? (cdr (assq 'noupdate? alist))) (purge? (cdr (assq 'purge? alist))) (jobs (cdr (assq 'jobs alist))) (rebuild? (cdr (assq 'rebuild? alist))) (nobuild? (cdr (assq 'nobuild? alist))) (aot? (cdr (assq 'aot? alist))) (context (cdr (assq 'context alist)))) (if aot? (progn (progn (eval-after-load 'straight #'(lambda nil (setq straight--native-comp-available t)))))) (if jobs (progn (setq native-comp-async-jobs-number (truncate jobs)))) (let ((emacs-running? (let* ((--cl-var-- (remove (emacs-pid) (list-system-processes))) (pid nil) (attrs nil) (args nil) (--cl-var-- nil) (--cl-var-- t)) (while (consp --cl-var--) (setq pid (car --cl-var--)) (setq attrs (process-attributes pid)) (setq args (alist-get 'args attrs "")) (if (string-match-p "^\\([^ ]+/\\)?[eE]macs" args) (progn (if (not (string-match-p " --batch" args)) (progn (if (not (string-match-p " --script" args)) (progn (setq --cl-var-- (cons pid --cl-var--)))))))) (setq --cl-var-- (cdr --cl-var--)) (setq --cl-var-- nil)) (nreverse --cl-var--)))) (if (doom-profiles-bootloadable-p) (progn (call! '(profile sync "--all" "--reload")))) (run-hooks 'doom-before-sync-hook) (add-hook 'kill-emacs-hook #'doom-sync--abort-warning-h) (doom-print (doom-print--format (doom-print--class 'item "Using Emacs %s @ %s") emacs-version (doom-print--class 'path invocation-directory invocation-name))) (doom-print (doom-print--format (doom-print--class 'start "Synchronizing %S profile...") (or (car doom-profile) "default"))) (unwind-protect (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t)) (remove-hook 'kill-emacs-hook #'doom-sync--abort-warning-h))))) #s(doom-cli :command ("doom" "sync") :type nil :docs (("SUMMARY" . "Synchronize your config with Doom Emacs.") ("MAIN" . "This is the equivalent of running autoremove, install, autoloads, then\nrecompile. Run this whenever you:\n\n  1. Modify your `doom!' block,\n  2. Add, remove, or modify `package!' blocks to your config,\n  3. Add, remove, or modify autoloaded functions in module autoloaded files,\n  4. Update Doom manually (e.g. with git),\n  5. Move your Doom config (either $EMACSDIR or $DOOMDIR) to a new location.\n  6. Up or downgrade Emacs itself (e.g. 29.1 -> 29.4).\n\nSync'ing ensures that unneeded packages are removed, needed packages are\ninstalled, autoloads files are up-to-date, and no byte-compiled files have gone\nstale.") ("OPTIONS" . "-j, --jobs\n  Defaults to the maximum number of threads (or 1, if your CPU's threadcount\n  can't be determined).\n--aot\n  Will only perform AOT native-compilation for packages updated/installed\n  during the execution of this command. Use --rebuild as well to do so for all\n  packages.")) :autoload nil :alias nil :options (#s(doom-cli-option :symbol noenvvar? :docs "Don't regenerate the envvar file" :multiple-p nil :flag-p nil :switches ("-e") :arguments nil :default nil) #s(doom-cli-option :symbol update? :docs "Update all installed packages after syncing" :multiple-p nil :flag-p nil :switches ("-u") :arguments nil :default nil) #s(doom-cli-option :symbol noupdate? :docs "Don't update any packages" :multiple-p nil :flag-p nil :switches ("-U") :arguments nil :default nil) #s(doom-cli-option :symbol purge? :docs "Purge orphaned package repos & regraft them" :multiple-p nil :flag-p nil :switches ("--gc") :arguments nil :default nil) #s(doom-cli-option :symbol jobs :docs "How many threads to use for native compilation" :multiple-p nil :flag-p nil :switches ("-j" "--jobs") :arguments (num) :default nil) #s(doom-cli-option :symbol rebuild? :docs "Rebuild all installed packages, unconditionally" :multiple-p nil :flag-p nil :switches ("-b" "--rebuild") :arguments nil :default nil) #s(doom-cli-option :symbol nobuild? :docs "Don't rebuild packages when hostname or Emacs version has changed" :multiple-p nil :flag-p nil :switches ("-B") :arguments nil :default nil) #s(doom-cli-option :symbol aot? :docs "Natively compile packages ahead-of-time (if available)" :multiple-p nil :flag-p nil :switches ("--aot") :arguments nil :default nil)) :arguments ((&context context)) :plist (:benchmark t :prefix (doom) :group "Config Management" :docs "Commands for maintaining your Doom Emacs configuration." :hide nil) :fn #f(lambda (cli alist) [t] (let ((noenvvar? (cdr (assq 'noenvvar? alist))) (update? (cdr (assq 'update? alist))) (noupdate? (cdr (assq 'noupdate? alist))) (purge? (cdr (assq 'purge? alist))) (jobs (cdr (assq 'jobs alist))) (rebuild? (cdr (assq 'rebuild? alist))) (nobuild? (cdr (assq 'nobuild? alist))) (aot? (cdr (assq 'aot? alist))) (context (cdr (assq 'context alist)))) (if aot? (progn (progn (eval-after-load 'straight #'(lambda nil (setq straight--native-comp-available t)))))) (if jobs (progn (setq native-comp-async-jobs-number (truncate jobs)))) (let ((emacs-running? (let* ((--cl-var-- (remove (emacs-pid) (list-system-processes))) (pid nil) (attrs nil) (args nil) (--cl-var-- nil) (--cl-var-- t)) (while (consp --cl-var--) (setq pid (car --cl-var--)) (setq attrs (process-attributes pid)) (setq args (alist-get 'args attrs "")) (if (string-match-p "^\\([^ ]+/\\)?[eE]macs" args) (progn (if (not (string-match-p " --batch" args)) (progn (if (not (string-match-p " --script" args)) (progn (setq --cl-var-- (cons pid --cl-var--)))))))) (setq --cl-var-- (cdr --cl-var--)) (setq --cl-var-- nil)) (nreverse --cl-var--)))) (if (doom-profiles-bootloadable-p) (progn (call! '(profile sync "--all" "--reload")))) (run-hooks 'doom-before-sync-hook) (add-hook 'kill-emacs-hook #'doom-sync--abort-warning-h) (doom-print (doom-print--format (doom-print--class 'item "Using Emacs %s @ %s") emacs-version (doom-print--class 'path invocation-directory invocation-name))) (doom-print (doom-print--format (doom-print--class 'start "Synchronizing %S profile...") (or (car doom-profile) "default"))) (unwind-protect (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t)) (remove-hook 'kill-emacs-hook #'doom-sync--abort-warning-h)))))) ((context . #s(doom-cli-context :init-time (26702 23162 356912 0) :pid 10776 :step 0 :geometry (120 . 30) :pipes nil :suppress-prompts-p nil :prefix "doom" :meta-p nil :error nil :command ("doom" "env") :path nil :whole ("--no-color" "sync") :options (("--deny") ("-d") ("--allow") ("-a") ("-o") ("--deny-all") ("--allow-all") ("--reload" . "--reload") ("--all" . "--all") ("--aot") ("-B") ("--rebuild") ("-b") ("--jobs") ("-j") ("--gc") ("-U") ("-u") ("-e") ("--eval") ("-E") ("--strict-load") ("--load") ("-L") ("--color" . :no) ("--benchmark") ("--profile") ("--pager") ("--emacsdir") ("--doomdir") ("--verbose") ("-v") ("--debug") ("-D") ("--force") ("-!")) :arguments ((t) (("doom" "env")) (("doom") "env")) :stdin #<buffer  *doom-cli stdin*> :stdout #<buffer  *doom-cli stdout*> :stderr #<buffer  *doom-cli stderr*> :state nil)) (aot?) (nobuild?) (rebuild?) (jobs) (purge?) (noupdate?) (update?) (noenvvar?)))
  doom-cli-execute(#s(doom-cli :command ("doom" "sync") :type nil :docs (("SUMMARY" . "Synchronize your config with Doom Emacs.") ("MAIN" . "This is the equivalent of running autoremove, install, autoloads, then\nrecompile. Run this whenever you:\n\n  1. Modify your `doom!' block,\n  2. Add, remove, or modify `package!' blocks to your config,\n  3. Add, remove, or modify autoloaded functions in module autoloaded files,\n  4. Update Doom manually (e.g. with git),\n  5. Move your Doom config (either $EMACSDIR or $DOOMDIR) to a new location.\n  6. Up or downgrade Emacs itself (e.g. 29.1 -> 29.4).\n\nSync'ing ensures that unneeded packages are removed, needed packages are\ninstalled, autoloads files are up-to-date, and no byte-compiled files have gone\nstale.") ("OPTIONS" . "-j, --jobs\n  Defaults to the maximum number of threads (or 1, if your CPU's threadcount\n  can't be determined).\n--aot\n  Will only perform AOT native-compilation for packages updated/installed\n  during the execution of this command. Use --rebuild as well to do so for all\n  packages.")) :autoload nil :alias nil :options (#s(doom-cli-option :symbol noenvvar? :docs "Don't regenerate the envvar file" :multiple-p nil :flag-p nil :switches ("-e") :arguments nil :default nil) #s(doom-cli-option :symbol update? :docs "Update all installed packages after syncing" :multiple-p nil :flag-p nil :switches ("-u") :arguments nil :default nil) #s(doom-cli-option :symbol noupdate? :docs "Don't update any packages" :multiple-p nil :flag-p nil :switches ("-U") :arguments nil :default nil) #s(doom-cli-option :symbol purge? :docs "Purge orphaned package repos & regraft them" :multiple-p nil :flag-p nil :switches ("--gc") :arguments nil :default nil) #s(doom-cli-option :symbol jobs :docs "How many threads to use for native compilation" :multiple-p nil :flag-p nil :switches ("-j" "--jobs") :arguments (num) :default nil) #s(doom-cli-option :symbol rebuild? :docs "Rebuild all installed packages, unconditionally" :multiple-p nil :flag-p nil :switches ("-b" "--rebuild") :arguments nil :default nil) #s(doom-cli-option :symbol nobuild? :docs "Don't rebuild packages when hostname or Emacs version has changed" :multiple-p nil :flag-p nil :switches ("-B") :arguments nil :default nil) #s(doom-cli-option :symbol aot? :docs "Natively compile packages ahead-of-time (if available)" :multiple-p nil :flag-p nil :switches ("--aot") :arguments nil :default nil)) :arguments ((&context context)) :plist (:benchmark t :prefix (doom) :group "Config Management" :docs "Commands for maintaining your Doom Emacs configuration." :hide nil) :fn #f(lambda (cli alist) [t] (let ((noenvvar? (cdr (assq 'noenvvar? alist))) (update? (cdr (assq 'update? alist))) (noupdate? (cdr (assq 'noupdate? alist))) (purge? (cdr (assq 'purge? alist))) (jobs (cdr (assq 'jobs alist))) (rebuild? (cdr (assq 'rebuild? alist))) (nobuild? (cdr (assq 'nobuild? alist))) (aot? (cdr (assq 'aot? alist))) (context (cdr (assq 'context alist)))) (if aot? (progn (progn (eval-after-load 'straight #'(lambda nil (setq straight--native-comp-available t)))))) (if jobs (progn (setq native-comp-async-jobs-number (truncate jobs)))) (let ((emacs-running? (let* ((--cl-var-- (remove (emacs-pid) (list-system-processes))) (pid nil) (attrs nil) (args nil) (--cl-var-- nil) (--cl-var-- t)) (while (consp --cl-var--) (setq pid (car --cl-var--)) (setq attrs (process-attributes pid)) (setq args (alist-get 'args attrs "")) (if (string-match-p "^\\([^ ]+/\\)?[eE]macs" args) (progn (if (not (string-match-p " --batch" args)) (progn (if (not (string-match-p " --script" args)) (progn (setq --cl-var-- (cons pid --cl-var--)))))))) (setq --cl-var-- (cdr --cl-var--)) (setq --cl-var-- nil)) (nreverse --cl-var--)))) (if (doom-profiles-bootloadable-p) (progn (call! '(profile sync "--all" "--reload")))) (run-hooks 'doom-before-sync-hook) (add-hook 'kill-emacs-hook #'doom-sync--abort-warning-h) (doom-print (doom-print--format (doom-print--class 'item "Using Emacs %s @ %s") emacs-version (doom-print--class 'path invocation-directory invocation-name))) (doom-print (doom-print--format (doom-print--class 'start "Synchronizing %S profile...") (or (car doom-profile) "default"))) (unwind-protect (progn (let ((doom-print-level (or nil doom-print-level)) (doom-print-indent (+ (if t (or nil doom-print-indent-increment) 0) doom-print-indent))) (let ((x0 (doom-file-read doom-sync-info-file :by 'read :noerror t)) (to-rebuild nil)) (progn (ignore (consp x0)) (let* ((x65 (car-safe x0)) (x66 (cdr-safe x0))) (let ((old-version x65) (hash x66)) (progn (if (and old-version (not (equal old-version emacs-version))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Emacs version has changed since last sync (from %s to %s)") old-version emacs-version)) (setq to-rebuild t))) (if (and (stringp hash) (not (equal hash (doom-sync--system-hash)))) (progn (doom-print (doom-print--format (doom-print--class 'warn "Your system has changed since last sync"))) (setq to-rebuild t))) (if (and to-rebuild (not rebuild?) (not (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 6))))) (progn (cond (nobuild? (doom-print (doom-print--format (doom-print--class 'warn "Packages must be rebuilt, but -B has prevented it. Skipping...")))) ((doom-cli-context-get context 'upgrading) (doom-print (doom-print--format (doom-print--class 'warn "Packages will be rebuilt"))) (setq rebuild? t)) ((y-or-n-p (doom-print--format "  %s" "Installed packages must be rebuilt. Do so now?")) (setq rebuild? t)) ((exit! 0)))))))))) (if (and (not noenvvar?) (file-exists-p doom-env-file)) (progn (call! '(env)))) (doom-packages-ensure rebuild?) (if noupdate? nil (doom-packages-update (not update?))) (doom-packages-purge purge? purge? purge? purge? purge?) (if (doom-profile-generate) (progn (if emacs-running? (progn (doom-print (doom-print--format (doom-print--class 'item "Restart Emacs for changes to take effect"))))) (run-hooks 'doom-after-sync-hook))) (if (or rebuild? (not (file-exists-p doom-sync-info-file))) (progn (let ((temp-file doom-sync-info-file) (temp-buffer (generate-new-buffer " *temp file*" t))) (unwind-protect (prog1 (save-current-buffer (set-buffer temp-buffer) (prin1 (cons emacs-version (doom-sync--system-hash)) (current-buffer))) (save-current-buffer (set-buffer temp-buffer) (write-region nil nil temp-file nil 0))) (and (buffer-name temp-buffer) (kill-buffer temp-buffer)))))) t)) (remove-hook 'kill-emacs-hook #'doom-sync--abort-warning-h)))))) ((context . #s(doom-cli-context :init-time (26702 23162 356912 0) :pid 10776 :step 0 :geometry (120 . 30) :pipes nil :suppress-prompts-p nil :prefix "doom" :meta-p nil :error nil :command ("doom" "env") :path nil :whole ("--no-color" "sync") :options (("--deny") ("-d") ("--allow") ("-a") ("-o") ("--deny-all") ("--allow-all") ("--reload" . "--reload") ("--all" . "--all") ("--aot") ("-B") ("--rebuild") ("-b") ("--jobs") ("-j") ("--gc") ("-U") ("-u") ("-e") ("--eval") ("-E") ("--strict-load") ("--load") ("-L") ("--color" . :no) ("--benchmark") ("--profile") ("--pager") ("--emacsdir") ("--doomdir") ("--verbose") ("-v") ("--debug") ("-D") ("--force") ("-!")) :arguments ((t) (("doom" "env")) (("doom") "env")) :stdin #<buffer  *doom-cli stdin*> :stdout #<buffer  *doom-cli stdout*> :stderr #<buffer  *doom-cli stderr*> :state nil)) (aot?) (nobuild?) (rebuild?) (jobs) (purge?) (noupdate?) (update?) (noenvvar?)))
  (let ((cli x27) (bindings x28)) (doom-cli-execute cli bindings))
  (let* ((x27 (car-safe x26)) (x28 (cdr-safe x26))) (let ((cli x27) (bindings x28)) (doom-cli-execute cli bindings)))
  (progn (ignore (consp x26)) (let* ((x27 (car-safe x26)) (x28 (cdr-safe x26))) (let ((cli x27) (bindings x28)) (doom-cli-execute cli bindings))))
  (let ((x26 (car tail))) (progn (ignore (consp x26)) (let* ((x27 (car-safe x26)) (x28 (cdr-safe x26))) (let ((cli x27) (bindings x28)) (doom-cli-execute cli bindings)))) (setq tail (cdr tail)))
  (while tail (let ((x26 (car tail))) (progn (ignore (consp x26)) (let* ((x27 (car-safe x26)) (x28 (cdr-safe x26))) (let ((cli x27) (bindings x28)) (doom-cli-execute cli bindings)))) (setq tail (cdr tail))))
  (let ((tail (nreverse runners))) (while tail (let ((x26 (car tail))) (progn (ignore (consp x26)) (let* ((x27 (car-safe x26)) (x28 (cdr-safe x26))) (let ((cli x27) (bindings x28)) (doom-cli-execute cli bindings)))) (setq tail (cdr tail)))))
  (let ((seen '(t)) runners) (let ((tail (doom-cli-find command (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2)))))) (while tail (let ((cli (car tail))) (setq runners (cons (cons (doom-cli-get cli) (doom-cli--bindings cli context seen)) runners)) (setq tail (cdr tail))))) (let ((tail (nreverse runners))) (while tail (let ((x26 (car tail))) (progn (ignore (consp x26)) (let* ((x27 (car-safe x26)) (x28 (cdr-safe x26))) (let ((cli x27) (bindings x28)) (doom-cli-execute cli bindings)))) (setq tail (cdr tail))))) context)
  (cond ((null (or command (doom-cli-get (list prefix) t))) (signal 'doom-cli-invalid-prefix-error (list prefix))) ((let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 8))) (let* ((val (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 8))))) (cond ((equal val '"--version") (let nil (doom-cli-call (cons ':version (cdr command)) context) t)) ((member val '("--help" "-?")) (let nil (doom-cli-call (cons ':help (cdr command)) context) t)) (t (let nil (error "In meta mode with no destination!")))))) ((not (and cli (let* ((cl-x (doom-cli-get cli))) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9))))) (signal 'doom-cli-command-not-found-error (append command (alist-get t (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 14))))))) ((let ((seen '(t)) runners) (let ((tail (doom-cli-find command (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2)))))) (while tail (let ((cli (car tail))) (setq runners (cons (cons (doom-cli-get cli) (doom-cli--bindings cli context seen)) runners)) (setq tail (cdr tail))))) (let ((tail (nreverse runners))) (while tail (let ((x26 (car tail))) (progn (ignore (consp x26)) (let* ((x27 (car-safe x26)) (x28 (cdr-safe x26))) (let ((cli x27) (bindings x28)) (doom-cli-execute cli bindings)))) (setq tail (cdr tail))))) context)))
  (let* ((command (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 10)))) (cli (doom-cli-get command t)) (prefix (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 7))))) (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "context-execute: %s" (mapconcat #'doom-cli-command-string (delq nil (list (car (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 11)))) command)) " -> ")))) (cond ((null (or command (doom-cli-get (list prefix) t))) (signal 'doom-cli-invalid-prefix-error (list prefix))) ((let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 8))) (let* ((val (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 8))))) (cond ((equal val '"--version") (let nil (doom-cli-call (cons ':version (cdr command)) context) t)) ((member val '("--help" "-?")) (let nil (doom-cli-call (cons ':help (cdr command)) context) t)) (t (let nil (error "In meta mode with no destination!")))))) ((not (and cli (let* ((cl-x (doom-cli-get cli))) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9))))) (signal 'doom-cli-command-not-found-error (append command (alist-get t (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 14))))))) ((let ((seen '(t)) runners) (let ((tail (doom-cli-find command (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2)))))) (while tail (let ((cli (car tail))) (setq runners (cons (cons (doom-cli-get cli) (doom-cli--bindings cli context seen)) runners)) (setq tail (cdr tail))))) (let ((tail (nreverse runners))) (while tail (let ((x26 (car tail))) (progn (ignore (consp x26)) (let* ((x27 (car-safe x26)) (x28 (cdr-safe x26))) (let ((cli x27) (bindings x28)) (doom-cli-execute cli bindings)))) (setq tail (cdr tail))))) context))))
  doom-cli-context-execute(#s(doom-cli-context :init-time (26702 23162 356912 0) :pid 10776 :step 0 :geometry (120 . 30) :pipes nil :suppress-prompts-p nil :prefix "doom" :meta-p nil :error nil :command ("doom" "env") :path nil :whole ("--no-color" "sync") :options (("--deny") ("-d") ("--allow") ("-a") ("-o") ("--deny-all") ("--allow-all") ("--reload" . "--reload") ("--all" . "--all") ("--aot") ("-B") ("--rebuild") ("-b") ("--jobs") ("-j") ("--gc") ("-U") ("-u") ("-e") ("--eval") ("-E") ("--strict-load") ("--load") ("-L") ("--color" . :no) ("--benchmark") ("--profile") ("--pager") ("--emacsdir") ("--doomdir") ("--verbose") ("-v") ("--debug") ("-D") ("--force") ("-!")) :arguments ((t) (("doom" "env")) (("doom") "env")) :stdin #<buffer  *doom-cli stdin*> :stdout #<buffer  *doom-cli stdout*> :stderr #<buffer  *doom-cli stderr*> :state nil))
  (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result))
  (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0)
  (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))
  (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3)))
  (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context)
  (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context))
  (let ((doom-print-stream standard-output)) (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context)))
  (progn (fset #'message vnew) (let ((doom-print-stream standard-output)) (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context))))
  (unwind-protect (progn (fset #'message vnew) (let ((doom-print-stream standard-output)) (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context)))) (fset #'message old))
  (let* ((vnew (doom-print--redirect-message streamspec (if noninteractive 'debug 'notice))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (let ((doom-print-stream standard-output)) (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context)))) (fset #'message old)))
  (let ((standard-output (doom-print--redirect-standard-output streamspec t))) (let* ((vnew (doom-print--redirect-message streamspec (if noninteractive 'debug 'notice))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (let ((doom-print-stream standard-output)) (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context)))) (fset #'message old))))
  (let ((streamspec (list (list '>= 'notice (let* ((cl-x doomctxt)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 16)))) (cons t (let* ((cl-x doomctxt)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 17))))))) (let ((standard-output (doom-print--redirect-standard-output streamspec t))) (let* ((vnew (doom-print--redirect-message streamspec (if noninteractive 'debug 'notice))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (let ((doom-print-stream standard-output)) (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context)))) (fset #'message old)))))
  (let* ((doomctxt context) (debugger (doom-rpartial #'doom-cli-debugger doomctxt)) (debug-on-error t)) (let ((streamspec (list (list '>= 'notice (let* ((cl-x doomctxt)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 16)))) (cons t (let* ((cl-x doomctxt)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 17))))))) (let ((standard-output (doom-print--redirect-standard-output streamspec t))) (let* ((vnew (doom-print--redirect-message streamspec (if noninteractive 'debug 'notice))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (let ((doom-print-stream standard-output)) (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context)))) (fset #'message old))))))
  (let* ((args (flatten-list args)) (context (make-doom-cli-context :prefix prefix :whole args)) (doom-cli--context context) (write-logs-fn (doom-partial #'doom-cli--output-write-logs-h context)) (show-benchmark-fn (doom-partial #'doom-cli--output-benchmark-h context))) (let* ((doomctxt context) (debugger (doom-rpartial #'doom-cli-debugger doomctxt)) (debug-on-error t)) (let ((streamspec (list (list '>= 'notice (let* ((cl-x doomctxt)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 16)))) (cons t (let* ((cl-x doomctxt)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 17))))))) (let ((standard-output (doom-print--redirect-standard-output streamspec t))) (let* ((vnew (doom-print--redirect-message streamspec (if noninteractive 'debug 'notice))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (let ((doom-print-stream standard-output)) (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context)))) (fset #'message old)))))))
  (let ((doom-context doom-context)) (doom-context-push 'run) (let* ((args (flatten-list args)) (context (make-doom-cli-context :prefix prefix :whole args)) (doom-cli--context context) (write-logs-fn (doom-partial #'doom-cli--output-write-logs-h context)) (show-benchmark-fn (doom-partial #'doom-cli--output-benchmark-h context))) (let* ((doomctxt context) (debugger (doom-rpartial #'doom-cli-debugger doomctxt)) (debug-on-error t)) (let ((streamspec (list (list '>= 'notice (let* ((cl-x doomctxt)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 16)))) (cons t (let* ((cl-x doomctxt)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 17))))))) (let ((standard-output (doom-print--redirect-standard-output streamspec t))) (let* ((vnew (doom-print--redirect-message streamspec (if noninteractive 'debug 'notice))) (old (symbol-function #'message))) (unwind-protect (progn (fset #'message vnew) (let ((doom-print-stream standard-output)) (progn (if (and (not doom-inhibit-log) (or (not noninteractive) (<= 2 doom-log-level))) (progn (doom--log 2 "run!: %s %s" prefix (combine-and-quote-strings args)))) (add-hook 'kill-emacs-hook show-benchmark-fn 94) (add-hook 'kill-emacs-hook write-logs-fn 95) (if (doom-cli-context-pipe-p context :out t) (progn (setq doom-print-backend nil))) (if (doom-cli-context-pipe-p context :in) (progn (save-current-buffer (set-buffer (let* ((cl-x context)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-context-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-context cl-x))) (aref cl-x 15)))) (while (let* ((in (and t (condition-case nil (progn (read-from-minibuffer "")) (error nil))))) (if in (insert in "\n") (condition-case nil (progn (delete-char -1)) (error nil)))))))) (doom-cli--exit (catch 'exit (condition-case e (let* ((args (cons (if (getenv "__DOOMDUMP") :dump prefix) args)) (context (doom-cli-context-restore (getenv "__DOOMCONTEXT") context)) (context (doom-cli-context-parse args context))) (run-hook-with-args 'doom-cli-before-run-functions context) (let ((result (doom-cli-context-execute context))) (run-hook-with-args 'doom-cli-after-run-functions context result)) 0) (doom-cli-wrong-number-of-arguments-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x38 (car-safe val)) (x39 (cdr-safe val))) (progn (ignore (consp x39)) (let* ((x40 (car-safe x39)) (x41 (cdr-safe x39))) (progn (ignore (consp x41)) (let* ((x42 (car-safe x41)) (x43 (cdr-safe x41))) (progn (ignore (consp x43)) (let* ((x44 (car-safe x43)) (x45 (cdr-safe x43))) (progn (ignore (consp x45)) (let* ((x46 (car-safe x45)) (x47 (cdr-safe x45))) (progn (ignore (null x47)) (let ((command x38) (flag x40) (args x42) (min x44) (max x46)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %S expected %s argument%s, but got %d") (or flag (doom-cli-command-string (if (keywordp (car command)) command (cdr command)))) (if (or (= min max) (= max most-positive-fixnum)) min (format "%d-%d" min max)) (if (or (= min 0) (> min 1)) "s" "") (length args))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e))))))))))))))) 5) (doom-cli-unrecognized-option-error (doom-print (doom-print--format (doom-print--style 'red "Error: unknown option %s") (car (cdr e)))) (doom-cli-call (cons ':help (cons "--synopsis" (cons "--postamble" (cdr (doom-cli--command context))))) context e) 5) (doom-cli-invalid-option-error (let* ((val (cdr e))) (progn (ignore (consp val)) (let* ((x48 (car-safe val)) (x49 (cdr-safe val))) (progn (ignore (consp x49)) (let* ((x50 (car-safe x49)) (x51 (cdr-safe x49))) (progn (ignore (consp x51)) (let* ((x52 (car-safe x51)) (x53 (cdr-safe x51))) (progn (ignore (consp x53)) (let* ((x54 (car-safe x53)) (x55 (cdr-safe x53))) (progn (ignore (null x55)) (let ((_types x48) (option x50) (value x52) (errors x54)) (progn (doom-print (doom-print--format (doom-print--style 'red "Error: %s received invalid value %S") (string-join (let* ((cl-x option)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-option-tags) t))) (signal 'wrong-type-argument (list 'doom-cli-option cl-x))) (aref cl-x 5))) "/") value)) (doom-print (doom-print--format (doom-print--style 'bold "\nValidation errors:"))) (let ((tail errors)) (while tail (let ((err (car tail))) (doom-print (doom-print--format (doom-print--class 'item "%s." (doom-print--class 'fill err)))) (setq tail (cdr tail))))))))))))))))) (doom-cli-call (cons ':help (cons "--postamble" (cdr (doom-cli--command context)))) context e) 5) (doom-cli-command-not-found-error (let* ((command (cdr e)) (cli (doom-cli-get command))) (cond ((null cli) (doom-print (doom-print--format (doom-print--style 'red "Error: unrecognized command: %s") (doom-cli-command-string command))) (doom-cli-call (cons ':help (cons "--similar" (cons "--postamble" (cdr command)))) context e)) ((null (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 9)))) (doom-print (doom-print--format (doom-print--style 'red "Error: a subcommand is required"))) (doom-cli-call (cons ':help (cons "--subcommands" (cons "--postamble" (cdr command)))) context e)))) 4) (doom-cli-invalid-prefix-error (let ((prefix (car (cdr e)))) (doom-print (doom-print--format (doom-print--style 'red "Error: `run!' called with invalid prefix %S") prefix)) (let* ((suggested (and t (let* ((--cl-var-- t) --cl-var--) (catch '--cl-block---cl-finish---- (maphash #'(lambda (--cl-var-- cli) (or (if (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 2))) t (progn (setq --cl-var-- (car (let* ((cl-x cli)) (progn (or (let* ((cl-x cl-x)) (progn (and (memq (type-of cl-x) cl-struct-doom-cli-tags) t))) (signal 'wrong-type-argument (list 'doom-cli cl-x))) (aref cl-x 1))))) (setq --cl-var-- nil))) (throw '--cl-block---cl-finish---- nil))) doom-cli--table)) --cl-var--)))) (if suggested (doom-print (doom-print--format "Did you mean %S?" suggested)) (doom-print (doom-print--format "There are no commands defined under %S." prefix))))) 4) (user-error (doom-print (doom-print--format (doom-print--style 'red "Error: %s") (car (cdr e)))) (doom-print (doom-print--format "\nAborting...")) 3))) context)))) (fset #'message old))))))))
  run!("doom" ("--no-color" "sync"))
  load-with-code-conversion("c:/Users/jiacs/AppData/Roaming/.emacs.d/bin/doom" "c:/Users/jiacs/AppData/Roaming/.emacs.d/bin/doom" nil t)
  command-line-1(("--load" "C:\\Users\\jiacs\\AppData\\Roaming\\.emacs.d\\bin/doom" "--" "--no-color" "sync"))
  command-line()
  normal-top-level()
      x The package manager threw an error
      x Last 16 lines of straight's error log:
        [Return code: 0]
        $ cd "c:/Users/jiacs/AppData/Roaming/.emacs.d/.local/straight/repos/emacs-solaire-mode/"
        $ "git" "config" "core.autocrlf" "true"
        [Return code: 0]
        $ cd "c:/Users/jiacs/AppData/Roaming/.emacs.d/.local/straight/repos/melpa/"
        $ "git" "rev-parse" "HEAD"
        ce5b76aae5f740df335ee9d99614e96ae7bc21ba
        [Return code: 0]
        $ cd "c:/Users/jiacs/AppData/Roaming/.emacs.d/.local/straight/repos/melpa/"
        $ "git" "config" "--get" "remote.origin.url"
        https://github.com/melpa/melpa.git
        [Return code: 0]
        $ cd "c:/Users/jiacs/AppData/Roaming/.emacs.d/.local/straight/repos/melpa/"
        $ "git" "fetch" "origin"
        fatal: unable to access 'https://github.com/melpa/melpa.git/': Failed to connect to github.com port 443 after 21038 ms: Could not connect to server
        [Return code: 128]
      ! Wrote extended straight log to ~/.emacs.d/.local/state/logs/cli.doom.250615133034.10776.error
âœ“ Finished in 34.79072s
