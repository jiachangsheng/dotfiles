;; -*- coding: utf-8; lexical-binding: t; -*-
;; This file was autogenerated; do not edit it by hand!
(or (equal doom-version "3.0.0-pre") (error "The installed version of Doom has changed since the last 'doom sync'.

Run 'doom sync' to fix this." "3.0.0-pre" doom-version))(when (and (or initial-window-system (daemonp)) doom-env-file) (doom-load-envvars-file doom-env-file 'noerror))(with-doom-context '(module init) (doom-load (file-name-concat doom-user-dir "init.el") t))(defun doom--startup-vars nil (set-default 'load-path '("c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/parent-mode" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/xref" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/shrink-path" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/expand-region" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/embrace" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/annalist" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/ht" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/popup" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/elisp-refs" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/epl" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/pkg-info" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/f" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/s" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/goto-chg" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/with-editor" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/magit-section" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/llama" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/seq" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/dash" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/async" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/link-hint" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/bash-completion" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/ob-async" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/orgit" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-org" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/org-cliplink" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/toc-org" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/ox-clip" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/htmlize" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/avy" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/org-contrib" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/org" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-markdown" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/edit-indirect" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/markdown-toc" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/markdown-mode" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/buttercup" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/flycheck-package" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/elisp-demos" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/elisp-def" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/overseer" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/macrostep" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/helpful" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/highlight-quoted" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/magit" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/transient" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/request" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/dumb-jump" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/eros" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/quickrun" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/package-lint" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/flycheck-popup-tip" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/flycheck" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/git-modes" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/git-timemachine" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/browse-at-remote" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/vundo" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/undo-fu-session" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/undo-fu" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/diredfl" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/dirvish" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/doom-snippets" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/auto-yasnippet" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-vimish-fold" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/vimish-fold" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/yasnippet" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-collection" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-quick-diff" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/exato" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-visualstar" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-traces" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-textobj-anyblock" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-surround" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-snipe" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-numbers" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-nerd-commenter" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-lion" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-indent-plus" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-exchange" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-escape" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-embrace" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-easymotion" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-args" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/persp-mode" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/vi-tilde-fringe" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/diff-hl" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-goggles" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-anzu" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/anzu" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/doom-modeline" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/hl-todo" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/solaire-mode" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/doom-themes" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/consult-yasnippet" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/wgrep" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/marginalia" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/embark-consult" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/embark" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/consult-flycheck" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/consult-dir" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/consult" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/orderless" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/vertico" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/yasnippet-capf" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/cape" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/corfu" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/which-key" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/general" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/project" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/projectile" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/ws-butler" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/smartparens" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/dtrt-indent" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/better-jumper" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/restart-emacs" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/rainbow-delimiters" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/highlight-numbers" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/hide-mode-line" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/nerd-icons" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/straight" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/gcmh" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/compat" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/auto-minor-mode" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/use-package" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/bind-key" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/repos/straight.el" "c:/Users/jiacs/dotfiles/doom-emacs/lisp/" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/site-lisp" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/site-lisp" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/vc" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/use-package" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/url" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/textmodes" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/progmodes" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/play" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/org" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/nxml" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/net" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/mh-e" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/mail" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/leim" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/language" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/international" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/image" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/gnus" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/eshell" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/erc" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/emulation" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/emacs-lisp" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/cedet" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/calendar" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/calc" "c:/Users/jiacs/scoop/apps/emacs/current/share/emacs/30.1/lisp/obsolete")) (set-default 'auto-mode-alist '(("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode) ("/git-rebase-todo\\'" . git-rebase-mode) ("/git/ignore\\'" . gitignore-mode) ("/info/exclude\\'" . gitignore-mode) ("/\\.gitignore\\'" . gitignore-mode) ("/etc/gitconfig\\'" . gitconfig-mode) ("/\\.gitmodules\\'" . gitconfig-mode) ("/git/config\\'" . gitconfig-mode) ("/modules/.*/config\\'" . gitconfig-mode) ("/\\.git/config\\'" . gitconfig-mode) ("/\\.gitconfig\\'" . gitconfig-mode) ("/git/attributes\\'" . gitattributes-mode) ("/info/attributes\\'" . gitattributes-mode) ("/\\.gitattributes\\'" . gitattributes-mode) ("\\.gpg\\(~\\|\\.~[0-9]+~\\)?\\'" nil epa-file) ("\\.elc\\'" . elisp-byte-code-mode) ("\\.zst\\'" nil jka-compr) ("\\.dz\\'" nil jka-compr) ("\\.xz\\'" nil jka-compr) ("\\.lzma\\'" nil jka-compr) ("\\.lz\\'" nil jka-compr) ("\\.g?z\\'" nil jka-compr) ("\\.bz2\\'" nil jka-compr) ("\\.Z\\'" nil jka-compr) ("\\.vr[hi]?\\'" . vera-mode) ("\\(?:\\.\\(?:rbw?\\|ru\\|rake\\|thor\\|axlsx\\|jbuilder\\|rabl\\|gemspec\\|podspec\\)\\|/\\(?:Gem\\|Rake\\|Cap\\|Thor\\|Puppet\\|Berks\\|Brew\\|Fast\\|Vagrant\\|Guard\\|Pod\\)file\\)\\'" . ruby-mode) ("\\.re?st\\'" . rst-mode) ("/\\(?:Pipfile\\|\\.?flake8\\)\\'" . conf-mode) ("\\.py[iw]?\\'" . python-mode) ("\\.m\\'" . octave-maybe-mode) ("\\.less\\'" . less-css-mode) ("\\.editorconfig\\'" . editorconfig-conf-mode) ("\\.scss\\'" . scss-mode) ("\\.cs\\'" . csharp-mode) ("\\.awk\\'" . awk-mode) ("\\.\\(u?lpc\\|pike\\|pmod\\(\\.in\\)?\\)\\'" . pike-mode) ("\\.idl\\'" . idl-mode) ("\\.java\\'" . java-mode) ("\\.m\\'" . objc-mode) ("\\.ii\\'" . c++-mode) ("\\.i\\'" . c-mode) ("\\.lex\\'" . c-mode) ("\\.y\\(acc\\)?\\'" . c-mode) ("\\.h\\'" . c-or-c++-mode) ("\\.c\\'" . c-mode) ("\\.\\(CC?\\|HH?\\)\\'" . c++-mode) ("\\.[ch]\\(pp\\|xx\\|\\+\\+\\)\\'" . c++-mode) ("\\.\\(cc\\|hh\\)\\'" . c++-mode) ("\\.\\(bat\\|cmd\\)\\'" . bat-mode) ("\\.[sx]?html?\\(\\.[a-zA-Z_]+\\)?\\'" . mhtml-mode) ("\\.svgz?\\'" . image-mode) ("\\.svgz?\\'" . xml-mode) ("\\.x[bp]m\\'" . image-mode) ("\\.x[bp]m\\'" . c-mode) ("\\.p[bpgn]m\\'" . image-mode) ("\\.tiff?\\'" . image-mode) ("\\.gif\\'" . image-mode) ("\\.png\\'" . image-mode) ("\\.jpe?g\\'" . image-mode) ("\\.webp\\'" . image-mode) ("\\.te?xt\\'" . text-mode) ("\\.[tT]e[xX]\\'" . tex-mode) ("\\.ins\\'" . tex-mode) ("\\.ltx\\'" . latex-mode) ("\\.dtx\\'" . doctex-mode) ("\\.org\\'" . org-mode) ("\\.dir-locals\\(?:-2\\)?\\.el\\'" . lisp-data-mode) ("\\.eld\\'" . lisp-data-mode) ("eww-bookmarks\\'" . lisp-data-mode) ("tramp\\'" . lisp-data-mode) ("/archive-contents\\'" . lisp-data-mode) ("places\\'" . lisp-data-mode) ("\\.emacs-places\\'" . lisp-data-mode) ("\\.el\\'" . emacs-lisp-mode) ("Project\\.ede\\'" . emacs-lisp-mode) ("\\(?:\\.\\(?:scm\\|sls\\|sld\\|stk\\|ss\\|sch\\)\\|/\\.guile\\)\\'" . scheme-mode) ("\\.l\\'" . lisp-mode) ("\\.li?sp\\'" . lisp-mode) ("\\.[fF]\\'" . fortran-mode) ("\\.for\\'" . fortran-mode) ("\\.p\\'" . pascal-mode) ("\\.pas\\'" . pascal-mode) ("\\.\\(dpr\\|DPR\\)\\'" . delphi-mode) ("\\.\\([pP]\\([Llm]\\|erl\\|od\\)\\|al\\)\\'" . perl-mode) ("Imakefile\\'" . makefile-imake-mode) ("Makeppfile\\(?:\\.mk\\)?\\'" . makefile-makepp-mode) ("\\.makepp\\'" . makefile-makepp-mode) ("\\.mk\\'" . makefile-gmake-mode) ("\\.make\\'" . makefile-gmake-mode) ("[Mm]akefile\\'" . makefile-gmake-mode) ("\\.am\\'" . makefile-automake-mode) ("\\.texinfo\\'" . texinfo-mode) ("\\.te?xi\\'" . texinfo-mode) ("\\.[sS]\\'" . asm-mode) ("\\.asm\\'" . asm-mode) ("\\.css\\'" . css-mode) ("\\.mixal\\'" . mixal-mode) ("\\.gcov\\'" . compilation-mode) ("/\\.[a-z0-9-]*gdbinit" . gdb-script-mode) ("-gdb\\.gdb" . gdb-script-mode) ("[cC]hange\\.?[lL]og?\\'" . change-log-mode) ("[cC]hange[lL]og[-.][0-9]+\\'" . change-log-mode) ("\\$CHANGE_LOG\\$\\.TXT" . change-log-mode) ("\\.scm\\.[0-9]*\\'" . scheme-mode) ("\\.[ckz]?sh\\'\\|\\.shar\\'\\|/\\.z?profile\\'" . sh-mode) ("\\.bash\\'" . sh-mode) ("/PKGBUILD\\'" . sh-mode) ("\\(/\\|\\`\\)\\.\\(bash_\\(profile\\|history\\|log\\(in\\|out\\)\\)\\|z?log\\(in\\|out\\)\\)\\'" . sh-mode) ("\\(/\\|\\`\\)\\.\\(shrc\\|zshrc\\|m?kshrc\\|bashrc\\|t?cshrc\\|esrc\\)\\'" . sh-mode) ("\\(/\\|\\`\\)\\.\\([kz]shenv\\|xinitrc\\|startxrc\\|xsession\\)\\'" . sh-mode) ("\\.m?spec\\'" . sh-mode) ("\\.m[mes]\\'" . nroff-mode) ("\\.man\\'" . nroff-mode) ("\\.sty\\'" . latex-mode) ("\\.cl[so]\\'" . latex-mode) ("\\.bbl\\'" . latex-mode) ("\\.bib\\'" . bibtex-mode) ("\\.bst\\'" . bibtex-style-mode) ("\\.sql\\'" . sql-mode) ("\\(acinclude\\|aclocal\\|acsite\\)\\.m4\\'" . autoconf-mode) ("\\.m[4c]\\'" . m4-mode) ("\\.mf\\'" . metafont-mode) ("\\.mp\\'" . metapost-mode) ("\\.vhdl?\\'" . vhdl-mode) ("\\.article\\'" . text-mode) ("\\.letter\\'" . text-mode) ("\\.i?tcl\\'" . tcl-mode) ("\\.exp\\'" . tcl-mode) ("\\.itk\\'" . tcl-mode) ("\\.icn\\'" . icon-mode) ("\\.sim\\'" . simula-mode) ("\\.mss\\'" . scribe-mode) ("\\.f9[05]\\'" . f90-mode) ("\\.f0[38]\\'" . f90-mode) ("\\.indent\\.pro\\'" . fundamental-mode) ("\\.\\(pro\\|PRO\\)\\'" . idlwave-mode) ("\\.srt\\'" . srecode-template-mode) ("\\.prolog\\'" . prolog-mode) ("\\.tar\\'" . tar-mode) ("\\.\\(arc\\|zip\\|lzh\\|lha\\|zoo\\|[jew]ar\\|xpi\\|rar\\|cbr\\|7z\\|squashfs\\|ARC\\|ZIP\\|LZH\\|LHA\\|ZOO\\|[JEW]AR\\|XPI\\|RAR\\|CBR\\|7Z\\|SQUASHFS\\)\\'" . archive-mode) ("\\.oxt\\'" . archive-mode) ("\\.\\(deb\\|[oi]pk\\)\\'" . archive-mode) ("\\`/tmp/Re" . text-mode) ("/Message[0-9]*\\'" . text-mode) ("\\`/tmp/fol/" . text-mode) ("\\.oak\\'" . scheme-mode) ("\\.sgml?\\'" . sgml-mode) ("\\.x[ms]l\\'" . xml-mode) ("\\.dbk\\'" . xml-mode) ("\\.dtd\\'" . sgml-mode) ("\\.ds\\(ss\\)?l\\'" . dsssl-mode) ("\\.js[mx]?\\'" . javascript-mode) ("\\.har\\'" . javascript-mode) ("\\.json\\'" . js-json-mode) ("\\.[ds]?va?h?\\'" . verilog-mode) ("\\.by\\'" . bovine-grammar-mode) ("\\.wy\\'" . wisent-grammar-mode) ("\\.erts\\'" . erts-mode) ("[:/\\]\\..*\\(emacs\\|gnus\\|viper\\)\\'" . emacs-lisp-mode) ("\\`\\..*emacs\\'" . emacs-lisp-mode) ("[:/]_emacs\\'" . emacs-lisp-mode) ("/crontab\\.X*[0-9]+\\'" . shell-script-mode) ("\\.ml\\'" . lisp-mode) ("\\.ld[si]?\\'" . ld-script-mode) ("ld\\.?script\\'" . ld-script-mode) ("\\.xs\\'" . c-mode) ("\\.x[abdsru]?[cnw]?\\'" . ld-script-mode) ("\\.zone\\'" . dns-mode) ("\\.soa\\'" . dns-mode) ("\\.asd\\'" . lisp-mode) ("\\.\\(asn\\|mib\\|smi\\)\\'" . snmp-mode) ("\\.\\(as\\|mi\\|sm\\)2\\'" . snmpv2-mode) ("\\.\\(diffs?\\|patch\\|rej\\)\\'" . diff-mode) ("\\.\\(dif\\|pat\\)\\'" . diff-mode) ("\\.[eE]?[pP][sS]\\'" . ps-mode) ("\\.\\(?:PDF\\|EPUB\\|CBZ\\|FB2\\|O?XPS\\|DVI\\|OD[FGPST]\\|DOCX\\|XLSX?\\|PPTX?\\|pdf\\|epub\\|cbz\\|fb2\\|o?xps\\|djvu\\|dvi\\|od[fgpst]\\|docx\\|xlsx?\\|pptx?\\)\\'" . doc-view-mode-maybe) ("configure\\.\\(ac\\|in\\)\\'" . autoconf-mode) ("\\.s\\(v\\|iv\\|ieve\\)\\'" . sieve-mode) ("BROWSE\\'" . ebrowse-tree-mode) ("\\.ebrowse\\'" . ebrowse-tree-mode) ("#\\*mail\\*" . mail-mode) ("\\.g\\'" . antlr-mode) ("\\.mod\\'" . m2-mode) ("\\.ses\\'" . ses-mode) ("\\.docbook\\'" . sgml-mode) ("\\.com\\'" . dcl-mode) ("/config\\.\\(?:bat\\|log\\)\\'" . fundamental-mode) ("/\\.?\\(authinfo\\|netrc\\)\\'" . authinfo-mode) ("\\.\\(?:[iI][nN][iI]\\|[lL][sS][tT]\\|[rR][eE][gG]\\|[sS][yY][sS]\\)\\'" . conf-mode) ("\\.la\\'" . conf-unix-mode) ("\\.ppd\\'" . conf-ppd-mode) ("java.+\\.conf\\'" . conf-javaprop-mode) ("\\.properties\\(?:\\.[a-zA-Z0-9._-]+\\)?\\'" . conf-javaprop-mode) ("\\.toml\\'" . conf-toml-mode) ("\\.desktop\\'" . conf-desktop-mode) ("/\\.redshift\\.conf\\'" . conf-windows-mode) ("\\`/etc/\\(?:DIR_COLORS\\|ethers\\|.?fstab\\|.*hosts\\|lesskey\\|login\\.?de\\(?:fs\\|vperm\\)\\|magic\\|mtab\\|pam\\.d/.*\\|permissions\\(?:\\.d/.+\\)?\\|protocols\\|rpc\\|services\\)\\'" . conf-space-mode) ("\\`/etc/\\(?:acpid?/.+\\|aliases\\(?:\\.d/.+\\)?\\|default/.+\\|group-?\\|hosts\\..+\\|inittab\\|ksysguarddrc\\|opera6rc\\|passwd-?\\|shadow-?\\|sysconfig/.+\\)\\'" . conf-mode) ("[cC]hange[lL]og[-.][-0-9a-z]+\\'" . change-log-mode) ("/\\.?\\(?:gitconfig\\|gnokiirc\\|hgrc\\|kde.*rc\\|mime\\.types\\|wgetrc\\)\\'" . conf-mode) ("/\\.mailmap\\'" . conf-unix-mode) ("/\\.\\(?:asound\\|enigma\\|fetchmail\\|gltron\\|gtk\\|hxplayer\\|mairix\\|mbsync\\|msmtp\\|net\\|neverball\\|nvidia-settings-\\|offlineimap\\|qt/.+\\|realplayer\\|reportbug\\|rtorrent\\.\\|screen\\|scummvm\\|sversion\\|sylpheed/.+\\|xmp\\)rc\\'" . conf-mode) ("/\\.\\(?:gdbtkinit\\|grip\\|mpdconf\\|notmuch-config\\|orbital/.+txt\\|rhosts\\|tuxracer/options\\)\\'" . conf-mode) ("/\\.?X\\(?:default\\|resource\\|re\\)s\\>" . conf-xdefaults-mode) ("/X11.+app-defaults/\\|\\.ad\\'" . conf-xdefaults-mode) ("/X11.+locale/.+/Compose\\'" . conf-colon-mode) ("/X11.+locale/compose\\.dir\\'" . conf-javaprop-mode) ("\\.~?[0-9]+\\.[0-9][-.0-9]*~?\\'" nil t) ("\\.\\(?:orig\\|in\\|[bB][aA][kK]\\)\\'" nil t) ("[/.]c\\(?:on\\)?f\\(?:i?g\\)?\\(?:\\.[a-zA-Z0-9._-]+\\)?\\'" . conf-mode-maybe) ("\\.[1-9]\\'" . nroff-mode) ("\\.art\\'" . image-mode) ("\\.avs\\'" . image-mode) ("\\.bmp\\'" . image-mode) ("\\.cmyk\\'" . image-mode) ("\\.cmyka\\'" . image-mode) ("\\.crw\\'" . image-mode) ("\\.dcr\\'" . image-mode) ("\\.dcx\\'" . image-mode) ("\\.dng\\'" . image-mode) ("\\.dpx\\'" . image-mode) ("\\.fax\\'" . image-mode) ("\\.heic\\'" . image-mode) ("\\.hrz\\'" . image-mode) ("\\.icb\\'" . image-mode) ("\\.icc\\'" . image-mode) ("\\.icm\\'" . image-mode) ("\\.ico\\'" . image-mode) ("\\.icon\\'" . image-mode) ("\\.jbg\\'" . image-mode) ("\\.jbig\\'" . image-mode) ("\\.jng\\'" . image-mode) ("\\.jnx\\'" . image-mode) ("\\.miff\\'" . image-mode) ("\\.mng\\'" . image-mode) ("\\.mvg\\'" . image-mode) ("\\.otb\\'" . image-mode) ("\\.p7\\'" . image-mode) ("\\.pcx\\'" . image-mode) ("\\.pdb\\'" . image-mode) ("\\.pfa\\'" . image-mode) ("\\.pfb\\'" . image-mode) ("\\.picon\\'" . image-mode) ("\\.pict\\'" . image-mode) ("\\.rgb\\'" . image-mode) ("\\.rgba\\'" . image-mode) ("\\.tga\\'" . image-mode) ("\\.wbmp\\'" . image-mode) ("\\.webp\\'" . image-mode) ("\\.wmf\\'" . image-mode) ("\\.wpg\\'" . image-mode) ("\\.xcf\\'" . image-mode) ("\\.xmp\\'" . image-mode) ("\\.xwd\\'" . image-mode) ("\\.yuv\\'" . image-mode) ("\\.tgz\\'" . tar-mode) ("\\.tbz2?\\'" . tar-mode) ("\\.txz\\'" . tar-mode) ("\\.tzst\\'" . tar-mode))) (set-default 'interpreter-mode-alist '(("j?ruby\\(?:[0-9.]+\\)" . ruby-mode) ("jruby" . ruby-mode) ("rbx" . ruby-mode) ("ruby" . ruby-mode) ("python[0-9.]*" . python-mode) ("rhino" . js-mode) ("gjs" . js-mode) ("nodejs" . js-mode) ("node" . js-mode) ("gawk" . awk-mode) ("nawk" . awk-mode) ("mawk" . awk-mode) ("awk" . awk-mode) ("pike" . pike-mode) ("\\(mini\\)?perl5?" . perl-mode) ("wishx?" . tcl-mode) ("tcl\\(sh\\)?" . tcl-mode) ("expect" . tcl-mode) ("octave" . octave-mode) ("scm" . scheme-mode) ("[acjkwz]sh" . sh-mode) ("r?bash2?" . sh-mode) ("dash" . sh-mode) ("mksh" . sh-mode) ("\\(dt\\|pd\\|w\\)ksh" . sh-mode) ("es" . sh-mode) ("i?tcsh" . sh-mode) ("oash" . sh-mode) ("rc" . sh-mode) ("rpm" . sh-mode) ("sh5?" . sh-mode) ("tail" . text-mode) ("more" . text-mode) ("less" . text-mode) ("pg" . text-mode) ("make" . makefile-gmake-mode) ("guile" . scheme-mode) ("clisp" . lisp-mode) ("emacs" . emacs-lisp-mode))) (set-default 'magic-mode-alist 'nil) (set-default 'magic-fallback-mode-alist '((image-type-auto-detected-p . image-mode) ("\\(PK00\\)?[P]K\3\4" . archive-mode) ("\\(?:<\\?xml[ \11\15\n]+[^>]*>\\)?[ \11\15\n]*<\\(?:!--\\(?:[^-]\\|-[^-]\\)*-->[ \11\15\n]*<\\)*\\(?:!DOCTYPE[ \11\15\n]+[^>]*>[ \11\15\n]*<[ \11\15\n]*\\(?:!--\\(?:[^-]\\|-[^-]\\)*-->[ \11\15\n]*<\\)*\\)?[Hh][Tt][Mm][Ll]" . mhtml-mode) ("<![Dd][Oo][Cc][Tt][Yy][Pp][Ee][ \11\15\n]+[Hh][Tt][Mm][Ll]" . mhtml-mode) ("<\\?xml " . xml-mode) ("[ \11\15\n]*<\\(?:!--\\(?:[^-]\\|-[^-]\\)*-->[ \11\15\n]*<\\)*!DOCTYPE " . sgml-mode) ("\320\317\21\340\241\261\32\341" . doc-view-mode-maybe) ("%!PS" . ps-mode) ("# xmcd " . conf-unix-mode))) (set-default 'Info-directory-list '("c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/use-package/" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/org/" "c:/Users/jiacs/scoop/apps/emacs/current/share/info/")) (put 'doom-version 'major '3) (put 'doom-version 'minor '0) (put 'doom-version 'build '0) (put 'doom-version 'tag '"pre") (put 'doom-version 'ref 'nil) (put 'doom-version 'branch 'nil))(defun doom--startup-loaddefs-doom nil (let ((load-in-progress t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/buffers.el") (load-true-file-name load-file-name)) (defvar doom-real-buffer-functions '(doom-dired-buffer-p) "A list of predicate functions run to determine if a buffer is real, unlike\n`doom-unreal-buffer-functions'. They are passed one argument: the buffer to be\ntested.\n\nShould any of its function returns non-nil, the rest of the functions are\nignored and the buffer is considered real.\n\nSee `doom-real-buffer-p' for more information.") (defvar doom-unreal-buffer-functions '(minibufferp doom-special-buffer-p doom-non-file-visiting-buffer-p) "A list of predicate functions run to determine if a buffer is *not* real,\nunlike `doom-real-buffer-functions'. They are passed one argument: the buffer to\nbe tested.\n\nShould any of these functions return non-nil, the rest of the functions are\nignored and the buffer is considered unreal.\n\nSee `doom-real-buffer-p' for more information.") (defvar-local doom-real-buffer-p nil "If non-nil, this buffer should be considered real no matter what. See\n`doom-real-buffer-p' for more information.") (defvar doom-fallback-buffer-name "*scratch*" "The name of the buffer to fall back to if no other buffers exist (will create\nit if it doesn't exist).") (autoload 'doom-buffer-frame-predicate "~/doom-emacs/lisp/lib/buffers" "To be used as the default frame buffer-predicate parameter. Returns nil if\nBUF should be skipped over by functions like `next-buffer' and `other-buffer'.\n\n(fn BUF)") (autoload 'doom-fallback-buffer "~/doom-emacs/lisp/lib/buffers" "Returns the fallback buffer, creating it if necessary. By default this is the\nscratch buffer. See `doom-fallback-buffer-name' to change this.") (defalias 'doom-buffer-list #'buffer-list) (autoload 'doom-project-buffer-list "~/doom-emacs/lisp/lib/buffers" "Return a list of buffers belonging to the specified PROJECT.\n\nIf PROJECT is nil, default to the current project.\n\nIf no project is active, return all buffers.\n\n(fn &optional PROJECT)") (autoload 'doom-open-projects "~/doom-emacs/lisp/lib/buffers" "Return a list of projects with open buffers.") (autoload 'doom-dired-buffer-p "~/doom-emacs/lisp/lib/buffers" "Returns non-nil if BUF is a dired buffer.\n\n(fn BUF)") (autoload 'doom-special-buffer-p "~/doom-emacs/lisp/lib/buffers" "Returns non-nil if BUF's name starts and ends with an *.\n\n(fn BUF)") (autoload 'doom-temp-buffer-p "~/doom-emacs/lisp/lib/buffers" "Returns non-nil if BUF is temporary.\n\n(fn BUF)") (autoload 'doom-visible-buffer-p "~/doom-emacs/lisp/lib/buffers" "Return non-nil if BUF is visible.\n\n(fn BUF)") (autoload 'doom-buried-buffer-p "~/doom-emacs/lisp/lib/buffers" "Return non-nil if BUF is not visible.\n\n(fn BUF)") (autoload 'doom-non-file-visiting-buffer-p "~/doom-emacs/lisp/lib/buffers" "Returns non-nil if BUF does not have a value for `buffer-file-name'.\n\n(fn BUF)") (autoload 'doom-real-buffer-list "~/doom-emacs/lisp/lib/buffers" "Return a list of buffers that satisfy `doom-real-buffer-p'.\n\n(fn &optional BUFFER-LIST)") (autoload 'doom-real-buffer-p "~/doom-emacs/lisp/lib/buffers" "Returns t if BUFFER-OR-NAME is a 'real' buffer.\n\nA real buffer is a useful buffer; a first class citizen in Doom. Real ones\nshould get special treatment, because we will be spending most of our time in\nthem. Unreal ones should be low-profile and easy to cast aside, so we can focus\non real ones.\n\nThe exact criteria for a real buffer is:\n\n  1. A non-nil value for the buffer-local value of the `doom-real-buffer-p'\n     variable OR\n  2. Any function in `doom-real-buffer-functions' returns non-nil OR\n  3. None of the functions in `doom-unreal-buffer-functions' must return\n     non-nil.\n\nIf BUFFER-OR-NAME is omitted or nil, the current buffer is tested.\n\n(fn BUFFER-OR-NAME)") (autoload 'doom-unreal-buffer-p "~/doom-emacs/lisp/lib/buffers" "Return t if BUFFER-OR-NAME is an 'unreal' buffer.\n\nSee `doom-real-buffer-p' for details on what that means.\n\n(fn BUFFER-OR-NAME)") (autoload 'doom-buffers-in-mode "~/doom-emacs/lisp/lib/buffers" "Return a list of buffers whose `major-mode' is `eq' to MODE(S).\n\nIf DERIVED-P, test with `derived-mode-p', otherwise use `eq'.\n\n(fn MODES &optional BUFFER-LIST DERIVED-P)") (autoload 'doom-visible-windows "~/doom-emacs/lisp/lib/buffers" "Return a list of the visible, non-popup (dedicated) windows.\n\n(fn &optional WINDOW-LIST)") (autoload 'doom-visible-buffers "~/doom-emacs/lisp/lib/buffers" "Return a list of visible buffers (i.e. not buried).\n\n(fn &optional BUFFER-LIST ALL-FRAMES)") (autoload 'doom-buried-buffers "~/doom-emacs/lisp/lib/buffers" "Get a list of buffers that are buried.\n\n(fn &optional BUFFER-LIST)") (autoload 'doom-matching-buffers "~/doom-emacs/lisp/lib/buffers" "Get a list of all buffers that match the regex PATTERN.\n\n(fn PATTERN &optional BUFFER-LIST)") (autoload 'doom-set-buffer-real "~/doom-emacs/lisp/lib/buffers" "Forcibly mark BUFFER as FLAG (non-nil = real).\n\nSee `doom-real-buffer-p' for an explanation for real buffers.\n\n(fn BUFFER FLAG)") (autoload 'doom-kill-buffer-and-windows "~/doom-emacs/lisp/lib/buffers" "Kill the buffer and delete all the windows it's displayed in.\n\n(fn BUFFER)") (autoload 'doom-fixup-windows "~/doom-emacs/lisp/lib/buffers" "Ensure that each of WINDOWS is showing a real buffer or the fallback buffer.\n\n(fn WINDOWS)") (autoload 'doom-kill-buffer-fixup-windows "~/doom-emacs/lisp/lib/buffers" "Kill the BUFFER and ensure all the windows it was displayed in have switched\nto a real buffer or the fallback buffer.\n\n(fn BUFFER)") (autoload 'doom-kill-buffers-fixup-windows "~/doom-emacs/lisp/lib/buffers" "Kill the BUFFERS and ensure all the windows they were displayed in have\nswitched to a real buffer or the fallback buffer.\n\n(fn BUFFERS)") (autoload 'doom-kill-matching-buffers "~/doom-emacs/lisp/lib/buffers" "Kill all buffers (in current workspace OR in BUFFER-LIST) that match the\nregex PATTERN. Returns the number of killed buffers.\n\n(fn PATTERN &optional BUFFER-LIST)") (autoload 'doom-mark-buffer-as-real-h "~/doom-emacs/lisp/lib/buffers" "Hook function that marks the current buffer as real.\n\nSee `doom-real-buffer-p' for an explanation for real buffers.") (autoload 'doom/save-and-kill-buffer "~/doom-emacs/lisp/lib/buffers" "Save the current buffer to file, then kill it." t) (autoload 'doom/kill-this-buffer-in-all-windows "~/doom-emacs/lisp/lib/buffers" "Kill BUFFER globally and ensure all windows previously showing this buffer\nhave switched to a real buffer or the fallback buffer.\n\nIf DONT-SAVE, don't prompt to save modified buffers (discarding their changes).\n\n(fn BUFFER &optional DONT-SAVE)" t) (autoload 'doom/kill-all-buffers "~/doom-emacs/lisp/lib/buffers" "Kill all buffers and closes their windows.\n\nIf the prefix arg is passed, doesn't close windows and only kill buffers that\nbelong to the current project.\n\n(fn &optional BUFFER-LIST INTERACTIVE)" t) (autoload 'doom/kill-other-buffers "~/doom-emacs/lisp/lib/buffers" "Kill all other buffers (besides the current one).\n\nIf the prefix arg is passed, kill only buffers that belong to the current\nproject.\n\n(fn &optional BUFFER-LIST INTERACTIVE)" t) (autoload 'doom/kill-matching-buffers "~/doom-emacs/lisp/lib/buffers" "Kill buffers that match PATTERN in BUFFER-LIST.\n\nIf the prefix arg is passed, only kill matching buffers in the current project.\n\n(fn PATTERN &optional BUFFER-LIST INTERACTIVE)" t) (autoload 'doom/kill-buried-buffers "~/doom-emacs/lisp/lib/buffers" "Kill buffers that are buried.\n\nIf PROJECT-P (universal argument), only kill buried buffers belonging to the\ncurrent project.\n\n(fn &optional BUFFER-LIST INTERACTIVE)" t) (autoload 'doom/kill-project-buffers "~/doom-emacs/lisp/lib/buffers" "Kill buffers for the specified PROJECT.\n\n(fn PROJECT &optional INTERACTIVE)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/config.el") (load-true-file-name load-file-name)) (defvar doom-after-reload-hook nil "A list of hooks to run after `doom/reload' has reloaded Doom.") (defvar doom-before-reload-hook nil "A list of hooks to run before `doom/reload' has reloaded Doom.") (autoload 'doom/open-private-config "~/doom-emacs/lisp/lib/config" "Browse your `doom-user-dir'." t) (autoload 'doom/find-file-in-private-config "~/doom-emacs/lisp/lib/config" "Search for a file in `doom-user-dir'." t) (autoload 'doom/reload "~/doom-emacs/lisp/lib/config" "Reloads your private config.\n\nWARNING: This command is experimental! If you haven't configured your config to\nbe idempotent, then this could cause compounding slowness or errors.\n\nThis is experimental! It will try to do as `bin/doom sync' does, but from within\nthis Emacs session. i.e. it reload autoloads files (if necessary), reloads your\npackage list, and lastly, reloads your private config.el.\n\nRuns `doom-after-reload-hook' afterwards." t) (autoload 'doom/reload-autoloads "~/doom-emacs/lisp/lib/config" "Reload only the autoloads of the current profile.\n\nThis is much faster and safer than `doom/reload', but not as comprehensive. This\nreloads your package and module visibility, but does not install new packages or\nremove orphaned ones. It also doesn't reload your private config.\n\nIt is useful to only pull in changes performed by 'doom sync' on the command\nline." t) (autoload 'doom/reload-env "~/doom-emacs/lisp/lib/config" "Reloads your envvar file.\n\nDOES NOT REGENERATE IT. You must run 'doom env' in your shell OUTSIDE of Emacs.\nDoing so from within Emacs will taint your shell environment.\n\nAn envvar file contains a snapshot of your shell environment, which can be\nimported into Emacs." t) (autoload 'doom/upgrade "~/doom-emacs/lisp/lib/config" "Run 'doom upgrade' then prompt to restart Emacs." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/debug.el") (load-true-file-name load-file-name)) (defvar doom-debug--variables `((doom-print-minimum-level . debug) (doom-inhibit-log) (async-debug t 2) debug-on-error (gcmh-verbose t 3) init-file-debug (jka-compr-verbose t 3) (message-log-max 16384) (native-comp-async-report-warnings-errors silent 2) (native-comp-warning-on-missing-source t 2) url-debug use-package-verbose (warning-suppress-types nil))) (cl-defun set-debug-variable! (var &optional (debug-val t) (level 1)) "Set VAR to DEBUG-VAL (or `t') when `doom-debug-mode' is active at >=LEVEL." (setf (alist-get var doom-debug--variables) (cons debug-val level))) (defvar doom-debug-mode nil "Non-nil if Doom-Debug mode is enabled.\nSee the `doom-debug-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `doom-debug-mode'.") (autoload 'doom-debug-mode "~/doom-emacs/lisp/lib/debug" "Toggle `debug-on-error' and `init-file-debug' for verbose logging.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Doom-Debug mode' mode.  If the prefix argument is positive, enable the\nmode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\nif ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='doom-debug-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when it is\ndisabled.\n\n(fn &optional ARG)" t) (autoload 'doom-backtrace "~/doom-emacs/lisp/lib/debug" "Return a stack trace as a list of `backtrace-frame' objects.") (autoload 'doom-run-all-startup-hooks-h "~/doom-emacs/lisp/lib/debug" "Run all startup Emacs hooks. Meant to be executed after starting Emacs with\n-q or -Q, for example:\n\n  emacs -Q -l init.el -f doom-run-all-startup-hooks-h") (autoload 'doom-info "~/doom-emacs/lisp/lib/debug" "Returns diagnostic information about the current Emacs session in markdown,\nready to be pasted in a bug report on github.") (autoload 'doom-info-string "~/doom-emacs/lisp/lib/debug" "Return the `doom-info' as a compact string.\n\nFILL-COLUMN determines the column at which lines will be broken.\n\n(fn &optional WIDTH NOCOLOR)") (autoload 'doom/version "~/doom-emacs/lisp/lib/debug" "Display the running version of Doom core, module sources, and Emacs." t) (autoload 'doom/info "~/doom-emacs/lisp/lib/debug" "Collects some debug information about your Emacs session, formats it and\ncopies it to your clipboard, ready to be pasted into bug reports!" t) (autoload 'doom/toggle-profiler "~/doom-emacs/lisp/lib/debug" "Toggle the Emacs profiler. Run it again to see the profiling report." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/docs.el") (load-true-file-name load-file-name)) (defvar doom-docs-dir (file-name-concat doom-emacs-dir "docs/") "Where Doom's documentation files are stored. Must end with a slash.") (autoload 'doom-docs-mode "~/doom-emacs/lisp/lib/docs" "Hides metadata, tags, & drawers and activates all org-mode prettifications.\n\nThis primes `org-mode' for reading.\n\nThis is a minor mode.  If called interactively, toggle the `Doom-Docs\nmode' mode.  If the prefix argument is positive, enable the mode, and if\nit is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\nif ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate the variable `doom-docs-mode'.\n\nThe mode's hook is called both when the mode is enabled and when it is\ndisabled.\n\n(fn &optional ARG)" t) (autoload 'doom/reload-docs "~/doom-emacs/lisp/lib/docs" "Reload the ID locations in Doom's documentation and open docs buffers.\n\n(fn &optional FORCE)" t) (autoload 'doom-docs-generate-id "~/doom-emacs/lisp/lib/docs" "Generate an ID for a `doom-docs-org-mode' buffer.\n\n(fn &optional FORCE?)") (autoload 'doom-docs-org-mode "~/doom-emacs/lisp/lib/docs" "A derivative of `org-mode' for Doom's documentation files.\n\nKeeps track of its own IDs in `doom-docs-dir' and toggles `doom-docs-mode' when\n`read-only-mode' is activated.\n\n(fn)" t) (autoload 'doom-docs-read-only-h "~/doom-emacs/lisp/lib/docs" "Activate `read-only-mode' if the current file exists and is non-empty.")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/files.el") (load-true-file-name load-file-name)) (autoload 'doom-path "~/doom-emacs/lisp/lib/files" "Return an path expanded after concatenating SEGMENTS with path separators.\n\nIgnores `nil' elements in SEGMENTS, and is intended as a fast compromise between\n`expand-file-name' (slow, but accurate), `file-name-concat' (fast, but\ninaccurate).\n\n(fn &rest SEGMENTS)") (function-put 'doom-path 'side-effect-free 't) (autoload 'doom-glob "~/doom-emacs/lisp/lib/files" "Return file list matching the glob created by joining SEGMENTS.\n\nThe returned file paths will be relative to `default-directory', unless SEGMENTS\nconcatenate into an absolute path.\n\nReturns nil if no matches exist.\nIgnores `nil' elements in SEGMENTS.\nIf the glob ends in a slash, only returns matching directories.\n\n(fn &rest SEGMENTS)") (function-put 'doom-glob 'side-effect-free 't) (define-obsolete-function-alias 'doom-dir 'doom-path "3.0.0") (autoload 'doom-files-in "~/doom-emacs/lisp/lib/files" "Return a list of files/directories in PATHS (one string or a list of them).\n\nFILTER is a function or symbol that takes one argument (the path). If it returns\nnon-nil, the entry will be excluded.\n\nMAP is a function or symbol which will be used to transform each entry in the\nresults.\n\nTYPE determines what kind of path will be included in the results. This can be t\n(files and folders), 'files or 'dirs.\n\nBy default, this function returns paths relative to PATH-OR-PATHS if it is a\nsingle path. If it a list of paths, this function returns absolute paths.\nOtherwise, by setting RELATIVE-TO to a path, the results will be transformed to\nbe relative to it.\n\nThe search recurses up to DEPTH and no further. DEPTH is an integer.\n\nMATCH is a string regexp. Only entries that match it will be included.\n\n(fn PATHS &rest REST &key FILTER MAP (FULL t) (FOLLOW-SYMLINKS t) (TYPE \\='files) (RELATIVE-TO (unless full default-directory)) (DEPTH 99999) (MINDEPTH 0) (MATCH \"/[^._][^/]+\"))") (autoload 'doom-file-cookie "~/doom-emacs/lisp/lib/files" "Returns the quoted FORM in a ;;;###COOKIE FORM at the top of FILE.\n\nIf COOKIE doesn't exist, or cookie isn't within the first 256 bytes of FILE,\nreturn NULL-VALUE.\n\n(fn FILE &optional COOKIE NULL-VALUE)") (autoload 'doom-file-cookie-p "~/doom-emacs/lisp/lib/files" "Returns the evaluated result of FORM in a ;;;###COOKIE FORM at the top of\nFILE.\n\nIf COOKIE doesn't exist, or cookie isn't within the first 256 bytes of FILE,\nreturn NULL-VALUE.\n\n(fn FILE &optional COOKIE NULL-VALUE)") (autoload 'file-exists-p! "~/doom-emacs/lisp/lib/files" "Returns non-nil if the FILES in DIRECTORY all exist.\n\nDIRECTORY is a path; defaults to `default-directory'.\n\nReturns the last file found to meet the rules set by FILES, which can be a\nsingle file or nested compound statement of `and' and `or' statements.\n\n(fn FILES &optional DIRECTORY)" nil t) (autoload 'doom-file-size "~/doom-emacs/lisp/lib/files" "Returns the size of FILE (in DIR) in bytes.\n\n(fn FILE &optional DIR)") (autoload 'doom-directory-size "~/doom-emacs/lisp/lib/files" "Returns the size of FILE (in DIR) in kilobytes.\n\n(fn DIR)") (autoload 'doom-file-read "~/doom-emacs/lisp/lib/files" "Read FILE and return its contents.\n\nSet BY to change how its contents are consumed. It accepts any function, to be\ncalled with no arguments and expected to return the contents as any arbitrary\ndata. By default, BY is set to `buffer-string'. Otherwise, BY recognizes these\nspecial values:\n\n'insert      -- insert FILE's contents into the current buffer before point.\n'read        -- read the first form in FILE and return it as a single S-exp.\n'read*       -- read all forms in FILE and return it as a list of S-exps.\n'(read . N)  -- read the first N (an integer) S-exps in FILE.\n\nCODING dictates the encoding of the buffer. This defaults to `utf-8'. If set to\nnil, `binary' is used.\n\nIf NOERROR is non-nil, don't throw an error if FILE doesn't exist. This will\nstill throw an error if FILE is unreadable, however.\n\nIf BEG and/or END are integers, only that region will be read from FILE.\n\n(fn FILE &key (BY \\='buffer-string) (CODING (or coding-system-for-read \\='utf-8)) NOERROR BEG END)") (autoload 'doom-file-write "~/doom-emacs/lisp/lib/files" "Write CONTENTS (a string or list of forms) to FILE (a string path).\n\nIf CONTENTS is list of forms. Any literal strings in the list are inserted\nverbatim, as text followed by a newline, with `insert'. Sexps are inserted with\n`prin1'. BY is the function to use to emit\n\nMODE dictates the permissions of created file and directories. MODE is either an\ninteger or a cons cell whose car is the mode for files and cdr the mode for\ndirectories. If FILE already exists, its permissions will be changed. The\npermissions of existing directories will never be changed.\n\nCODING dictates the encoding to read/write with (see `coding-system-for-write').\nThis defaults to `utf-8'. If set to nil, `binary' is used.\n\nAPPEND dictates where CONTENTS will be written. If neither is set,\nthe file will be overwritten. If both are, the contents will be written to both\nends. Set either APPEND or PREPEND to `noerror' to silently ignore read errors.\n\n(fn FILE CONTENTS &key APPEND (CODING \\='utf-8) MODE (MKDIR \\='parents) (INSERTFN #\\='insert) (PRINTFN #\\='prin1))") (autoload 'with-file-contents! "~/doom-emacs/lisp/lib/files" "Create a temporary buffer with FILE's contents and execute BODY in it.\n\nThe point is at the beginning of the buffer afterwards.\n\nA convenience macro to express the common `with-temp-buffer' +\n`insert-file-contents' idiom more succinctly, enforce `utf-8', and perform some\noptimizations for `binary' IO.\n\n(fn FILE &rest BODY)" nil t) (function-put 'with-file-contents! 'lisp-indent-function 1) (autoload 'with-file! "~/doom-emacs/lisp/lib/files" "Evaluate BODY in a temp buffer, then write its contents to FILE.\n\nUnlike `with-temp-file', this uses the `utf-8' encoding by default and performs\nsome optimizations for `binary' IO.\n\n(fn FILE &rest BODY)" nil t) (function-put 'with-file! 'lisp-indent-function 1) (autoload 'doom/delete-this-file "~/doom-emacs/lisp/lib/files" "Delete PATH, kill its buffers and expunge it from vc/magit cache.\n\nIf PATH is not specified, default to the current buffer's file.\n\nIf FORCE-P, delete without confirmation.\n\n(fn &optional PATH FORCE-P)" t) (autoload 'doom/copy-this-file "~/doom-emacs/lisp/lib/files" "Copy current buffer's file to NEW-PATH then open NEW-PATH.\n\nIf FORCE-P, overwrite the destination file if it exists, without confirmation.\n\n(fn NEW-PATH &optional FORCE-P)" t) (autoload 'doom/move-this-file "~/doom-emacs/lisp/lib/files" "Move current buffer's file to NEW-PATH.\n\nIf FORCE-P, overwrite the destination file if it exists, without confirmation.\n\n(fn NEW-PATH &optional FORCE-P)" t) (autoload 'doom/sudo-find-file "~/doom-emacs/lisp/lib/files" "Open FILE as root.\n\nThis will prompt you to save the current buffer, unless prefix ARG is given, in\nwhich case it will save it without prompting.\n\n(fn FILE &optional ARG)" t) (autoload 'doom/sudo-this-file "~/doom-emacs/lisp/lib/files" "Open the current file as root." t) (autoload 'doom/sudo-save-buffer "~/doom-emacs/lisp/lib/files" "Save this file as root." t) (autoload 'doom/remove-recent-file "~/doom-emacs/lisp/lib/files" "Remove FILE from your recently-opened-files list.\n\n(fn FILE)" t) (static-unless (fboundp 'find-sibling-file) (defvar find-sibling-rules nil) (defun find-sibling-file (file) "Visit a \"sibling\" file of FILE.\nWhen called interactively, FILE is the currently visited file.\n\nThe \"sibling\" file is defined by the `find-sibling-rules' variable." (interactive (progn (unless buffer-file-name (user-error "Not visiting a file")) (list buffer-file-name))) (unless find-sibling-rules (user-error "The `find-sibling-rules' variable has not been configured")) (let ((siblings (find-sibling-file-search (expand-file-name file) find-sibling-rules))) (cond ((null siblings) (user-error "Couldn't find any sibling files")) ((length= siblings 1) (find-file (car siblings))) (t (let ((relatives (mapcar (lambda (sibling) (file-relative-name sibling (file-name-directory file))) siblings))) (find-file (completing-read (format-prompt "Find file" (car relatives)) relatives nil t nil nil (car relatives)))))))) (defun find-sibling-file-search (file &optional rules) "Return a list of FILE's \"siblings\".\nRULES should be a list on the form defined by `find-sibling-rules' (which\nsee), and if nil, defaults to `find-sibling-rules'." (let ((results nil)) (pcase-dolist (`(,match \, expansions) (or rules find-sibling-rules)) (when (string-match match file) (let ((match-data (match-data))) (dolist (expansion expansions) (let ((start 0)) (while (string-match "\\\\\\([&0-9]+\\)" expansion start) (let ((index (string-to-number (match-string 1 expansion)))) (setq start (match-end 0) expansion (replace-match (substring file (elt match-data (* index 2)) (elt match-data (1+ (* index 2)))) t t expansion))))) (let ((default-directory (substring file 0 (car match-data)))) (setq results (nconc results (mapcar #'expand-file-name (letf! (defun wildcard-to-regexp (wildcard) (concat "\\`" wildcard "\\'")) (file-expand-wildcards expansion nil)))))))))) (delete file (delete-dups results)))))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/fonts.el") (load-true-file-name load-file-name)) (defvar doom-font-increment 2 "How many steps to increase the font size each time `doom/increase-font-size'\nor `doom/decrease-font-size' are invoked.") (defvar doom-big-font nil "The font to use for `doom-big-font-mode'.\nIf nil, `doom-font' will be used, scaled up by `doom-big-font-increment'. See\n`doom-font' for details on acceptable values for this variable.") (defvar doom-big-font-increment 4 "How many steps to increase the font size (with `doom-font' as the base) when\n`doom-big-font-mode' is enabled and `doom-big-font' is nil.") (autoload 'doom-normalize-font "~/doom-emacs/lisp/lib/fonts" "Return FONT as a normalized font spec.\n\nThe font will be normalized (i.e. :weight, :slant, and :width will set to\n'normal if not specified) before it is converted.\n\nFONT can be a `font-spec', a font object, an XFT font string, or an XLFD font\nstring.\n\n(fn FONT)") (autoload 'doom-adjust-font-size "~/doom-emacs/lisp/lib/fonts" "Increase size of font in FRAME by INCREMENT.\n\nIf FIXED-SIZE-P is non-nil, treat INCREMENT as a font size, rather than a\nscaling factor.\n\nFONT-ALIST is an alist give temporary values to certain Doom font variables,\nlike `doom-font' or `doom-variable-pitch-font'. e.g.\n\n  `((doom-font . ,(font-spec :family \"Sans Serif\" :size 12)))\n\nDoesn't work in terminal Emacs.\n\n(fn INCREMENT &optional FIXED-SIZE-P FONT-ALIST)") (autoload 'doom-font-exists-p "~/doom-emacs/lisp/lib/fonts" "Return non-nil if FONT exists on this system.\n\n(fn FONT)") (function-put 'doom-font-exists-p 'pure 't) (function-put 'doom-font-exists-p 'side-effect-free 't) (autoload 'doom/reload-font "~/doom-emacs/lisp/lib/fonts" "Reload your fonts, if they're set.\nSee `doom-init-fonts-h'." t) (autoload 'doom/increase-font-size "~/doom-emacs/lisp/lib/fonts" "Enlargens the font size across the current and child frames.\n\n(fn COUNT &optional INCREMENT)" t) (autoload 'doom/decrease-font-size "~/doom-emacs/lisp/lib/fonts" "Shrinks the font size across the current and child frames.\n\n(fn COUNT &optional INCREMENT)" t) (autoload 'doom/reset-font-size "~/doom-emacs/lisp/lib/fonts" "Reset font size and `text-scale'.\n\nAssuming it has been adjusted via `doom/increase-font-size' and\n`doom/decrease-font-size', or `text-scale-*' commands." t) (defvar doom-big-font-mode nil "Non-nil if Doom-BIG-Font mode is enabled.\nSee the `doom-big-font-mode' command\nfor a description of this minor mode.\nSetting this variable directly does not take effect;\neither customize it (see the info node `Easy Customization')\nor call the function `doom-big-font-mode'.") (autoload 'doom-big-font-mode "~/doom-emacs/lisp/lib/fonts" "Globally resizes your fonts for streams, screen-sharing or presentations.\n\nUses `doom-big-font' if its set, otherwise uses `doom-font' (falling back to\nyour system font).\n\nAlso resizees `doom-variable-pitch-font' and `doom-serif-font'.\n\nThis is a global minor mode.  If called interactively, toggle the\n`Doom-BIG-Font mode' mode.  If the prefix argument is positive, enable\nthe mode, and if it is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\nif ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate `(default-value \\='doom-big-font-mode)'.\n\nThe mode's hook is called both when the mode is enabled and when it is\ndisabled.\n\n(fn &optional ARG)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/git.el") (load-true-file-name load-file-name)) (autoload 'doom-git-toplevel "~/doom-emacs/lisp/lib/git" "Return the path to the current repo's root.\n\n(fn &rest SEGMENTS)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/help.el") (load-true-file-name load-file-name)) (autoload 'doom-active-minor-modes "~/doom-emacs/lisp/lib/help" "Return a list of active minor-mode symbols.") (defalias 'doom/describe-autodefs #'doom/help-autodefs) (defalias 'doom/describe-module #'doom/help-modules) (defalias 'doom/describe-package #'doom/help-packages) (autoload 'doom/describe-active-minor-mode "~/doom-emacs/lisp/lib/help" "Get information on an active minor mode. Use `describe-minor-mode' for a\nselection of all minor-modes, active or not.\n\n(fn MODE)" t) (autoload 'doom/describe-char "~/doom-emacs/lisp/lib/help" "Like `describe-char', but will operate at mouse point if given prefix arg.\n\n(fn EVENT)" t) (autoload 'doom-completing-read-org-headings "~/doom-emacs/lisp/lib/help" "TODO\n\n(fn PROMPT FILES &rest PLIST &key DEPTH MINDEPTH INCLUDE-FILES INITIAL-INPUT EXTRA-CANDIDATES ACTION)") (autoload 'doom/homepage "~/doom-emacs/lisp/lib/help" "Open the doom emacs homepage in the browser." t) (autoload 'doom/issue-tracker "~/doom-emacs/lisp/lib/help" "Open Doom Emacs' global issue tracker on Discourse." t) (autoload 'doom/report-bug "~/doom-emacs/lisp/lib/help" "Open the browser on our Discourse.\n\nIf called when a backtrace buffer is present, it and the output of `doom-info'\nwill be automatically appended to the result." t) (autoload 'doom/discourse "~/doom-emacs/lisp/lib/help" "Open Doom Emacs' issue tracker on Discourse." t) (autoload 'doom/help "~/doom-emacs/lisp/lib/help" "Open Doom's user manual." t) (autoload 'doom/help-search-headings "~/doom-emacs/lisp/lib/help" "Search Doom's documentation and jump to a headline.\n\n(fn &optional INITIAL-INPUT)" t) (autoload 'doom/help-search "~/doom-emacs/lisp/lib/help" "Perform a text search on all of Doom's documentation.\n\n(fn &optional INITIAL-INPUT)" t) (autoload 'doom/help-search-news "~/doom-emacs/lisp/lib/help" "Search headlines in Doom's newsletters.\n\n(fn &optional INITIAL-INPUT)" t) (autoload 'doom/help-faq "~/doom-emacs/lisp/lib/help" "Search Doom's FAQ and jump to a question.\n\n(fn &optional INITIAL-INPUT)" t) (autoload 'doom/help-news "~/doom-emacs/lisp/lib/help" "Open a Doom newsletter.\nThe latest newsletter will be selected by default." t) (autoload 'doom/help-autodefs "~/doom-emacs/lisp/lib/help" "Open documentation for an autodef.\n\nAn autodef is a Doom concept. It is a function or macro that is always defined,\nwhether or not its containing module is disabled (in which case it will safely\nno-op without evaluating its arguments). This syntactic sugar lets you use them\nwithout needing to check if they are available.\n\n(fn AUTODEF)" t) (autoload 'doom/help-modules "~/doom-emacs/lisp/lib/help" "Open the documentation for a Doom module.\n\nCATEGORY is a keyword and MODULE is a symbol. e.g. :editor and 'evil.\n\nIf VISIT-DIR is non-nil, visit the module's directory rather than its\ndocumentation.\n\nAutomatically selects a) the module at point (in private init files), b) the\nmodule derived from a `modulep!' or `require!' call, c) the module that the\ncurrent file is in, or d) the module associated with the current major mode (see\n`doom--help-major-mode-module-alist').\n\n(fn CATEGORY MODULE &optional VISIT-DIR)" t) (autoload 'doom/help-custom-variable "~/doom-emacs/lisp/lib/help" "Look up documentation for a custom variable.\n\nUnlike `describe-variable' or `helpful-variable', which casts a wider net that\nincludes internal variables, this only lists variables that exist to be\ncustomized (defined with `defcustom').\n\n(fn VAR)" t) (autoload 'doom/help-packages "~/doom-emacs/lisp/lib/help" "Like `describe-package', but for packages installed by Doom modules.\n\nOnly shows installed packages. Includes information about where packages are\ndefined and configured.\n\nIf prefix arg is present, refresh the cache.\n\n(fn PACKAGE)" t) (autoload 'doom/help-package-config "~/doom-emacs/lisp/lib/help" "Jump to any `use-package!', `after!' or ;;;###package block for PACKAGE.\n\nThis only searches `doom-emacs-dir' (typically ~/.emacs.d) and does not include\nconfig blocks in your private config.\n\n(fn PACKAGE)" t) (defalias 'doom/help-package-homepage #'straight-visit-package-website) (autoload 'doom/help-search-load-path "~/doom-emacs/lisp/lib/help" "Perform a text search on your `load-path'.\nUses the symbol at point or the current selection, if available.\n\n(fn QUERY)" t) (autoload 'doom/help-search-loaded-files "~/doom-emacs/lisp/lib/help" "Perform a text search on your `load-path'.\nUses the symbol at point or the current selection, if available.\n\n(fn QUERY)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/modules.el") (load-true-file-name load-file-name)) (autoload 'doom-modules-initialize "~/doom-emacs/lisp/lib/modules" "Initializes module metadata.\n\n(fn &optional FORCE?)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/packages.el") (load-true-file-name load-file-name)) (autoload 'doom-initialize-core-packages "~/doom-emacs/lisp/lib/packages" "Ensure `straight' is installed and was compiled with this version of Emacs.\n\n(fn &optional FORCE-P)") (autoload 'doom-initialize-packages "~/doom-emacs/lisp/lib/packages" "Process all packages, essential and otherwise, if they haven't already been.\n\nIf FORCE-P is non-nil, do it anyway.\n\nThis ensures `doom-packages' is populated and `straight' recipes are properly\nprocessed.\n\n(fn &optional FORCE-P)") (autoload 'doom-package-get "~/doom-emacs/lisp/lib/packages" "Returns PACKAGE's `package!' recipe from `doom-packages'.\n\n(fn PACKAGE &optional PROP NIL-VALUE)") (autoload 'doom-package-set "~/doom-emacs/lisp/lib/packages" "Set PROPERTY in PACKAGE's recipe to VALUE.\n\n(fn PACKAGE PROP VALUE)") (autoload 'doom-package-recipe "~/doom-emacs/lisp/lib/packages" "Returns the `straight' recipe PACKAGE was registered with.\n\n(fn PACKAGE &optional PROP NIL-VALUE)") (autoload 'doom-package-recipe-repo "~/doom-emacs/lisp/lib/packages" "Resolve and return PACKAGE's (symbol) local-repo property.\n\n(fn PACKAGE)") (autoload 'doom-package-build-recipe "~/doom-emacs/lisp/lib/packages" "Returns the `straight' recipe PACKAGE was installed with.\n\n(fn PACKAGE &optional PROP NIL-VALUE)") (autoload 'doom-package-dependencies "~/doom-emacs/lisp/lib/packages" "Return a list of dependencies for a package.\n\nIf RECURSIVE is `tree', return a tree of dependencies.\nIf RECURSIVE is nil, only return PACKAGE's immediate dependencies.\nIf NOERROR, return nil in case of error.\n\n(fn PACKAGE &optional RECURSIVE NOERROR)") (autoload 'doom-package-depending-on "~/doom-emacs/lisp/lib/packages" "Return a list of packages that depend on PACKAGE.\n\nIf PACKAGE (a symbol) isn't installed, throw an error, unless NOERROR is\nnon-nil.\n\n(fn PACKAGE &optional NOERROR)") (autoload 'doom-package-built-in-p "~/doom-emacs/lisp/lib/packages" "Return non-nil if PACKAGE (a symbol) is built-in.\n\n(fn PACKAGE)") (autoload 'doom-package-installed-p "~/doom-emacs/lisp/lib/packages" "Return non-nil if PACKAGE (a symbol) is installed.\n\n(fn PACKAGE)") (autoload 'doom-package-is-type-p "~/doom-emacs/lisp/lib/packages" "TODO\n\n(fn PACKAGE TYPE)") (autoload 'doom-package-in-module-p "~/doom-emacs/lisp/lib/packages" "Return non-nil if PACKAGE was installed by the user's private config.\n\n(fn PACKAGE CATEGORY &optional MODULE)") (autoload 'doom-package-backend "~/doom-emacs/lisp/lib/packages" "Return 'straight, 'builtin, 'elpa or 'other, depending on how PACKAGE is\ninstalled.\n\n(fn PACKAGE)") (autoload 'doom-package-list "~/doom-emacs/lisp/lib/packages" "Retrieve a list of explicitly declared packages from MODULE-LIST.\n\nIf MODULE-LIST is omitted, read enabled module list in configdepth order (see\n`doom-module-set'). Otherwise, MODULE-LIST may be any symbol (or t) to mean read\nall modules in `doom-modules-dir', including :doom and :user. MODULE-LIST may\nalso be a list of module keys.\n\n(fn &optional MODULE-LIST)") (autoload 'doom-package-pinned-alist "~/doom-emacs/lisp/lib/packages" "Return an alist mapping package names (strings) to pinned commits (strings).") (autoload 'doom-package-recipe-alist "~/doom-emacs/lisp/lib/packages" "Return straight recipes for non-builtin packages with a local-repo.") (autoload 'doom-package-homepage "~/doom-emacs/lisp/lib/packages" "return the url to package's homepage (usually a repo).\n\n(fn PACKAGE)") (autoload 'doom/reload-packages "~/doom-emacs/lisp/lib/packages" "Reload `doom-packages', `package' and `quelpa'." t) (autoload 'doom/bumpify-package-at-point "~/doom-emacs/lisp/lib/packages" "Convert `package!' call at point to a bump string." t) (autoload 'doom/bumpify-packages-in-buffer "~/doom-emacs/lisp/lib/packages" "Convert all `package!' calls in buffer into bump strings." t) (autoload 'doom/bump-package-at-point "~/doom-emacs/lisp/lib/packages" "Inserts or updates a `:pin' for the `package!' statement at point.\nGrabs the latest commit id of the package using 'git'.\n\n(fn &optional SELECT)" t) (autoload 'doom/bump-packages-in-buffer "~/doom-emacs/lisp/lib/packages" "Inserts or updates a `:pin' to all `package!' statements in current buffer.\nIf SELECT (prefix arg) is non-nil, prompt you to choose a specific commit for\neach package.\n\n(fn &optional SELECT)" t) (autoload 'doom/bump-module "~/doom-emacs/lisp/lib/packages" "Bump packages in CATEGORY MODULE.\nIf SELECT (prefix arg) is non-nil, prompt you to choose a specific commit for\neach package.\n\n(fn CATEGORY &optional MODULE SELECT)" t) (autoload 'doom/bump-package "~/doom-emacs/lisp/lib/packages" "Bump PACKAGE in all modules that install it.\n\n(fn PACKAGE)" t) (autoload 'doom/bumpify-diff "~/doom-emacs/lisp/lib/packages" "Copy user/repo@hash -> user/repo@hash's of changed packages to clipboard.\n\nMust be run from a magit diff buffer.\n\n(fn &optional INTERACTIVE)" t) (autoload 'doom/commit-bumps "~/doom-emacs/lisp/lib/packages" "Create a pre-filled magit commit for currently bumped packages." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/plist.el") (load-true-file-name load-file-name)) (autoload 'plist-put! "~/doom-emacs/lisp/lib/plist" "Set each PROP VALUE pair in REST to PLIST in-place.\n\n(fn PLIST &rest REST)" nil t) (define-obsolete-function-alias 'doom-plist-get #'cl-getf "3.0.0") (autoload 'doom-plist-map "~/doom-emacs/lisp/lib/plist" "Map FN on each keyword/value pair in PLIST.\n\nFN is a function that takes two arguments: a keyword and value, and its return\nvalues are accumulated ala `mapcar'.\n\n(fn FN PLIST)") (autoload 'doom-plist-map* "~/doom-emacs/lisp/lib/plist" "Apply FN to each variadic property in VPLIST.\n\nFN is a variadic function, whose first argument is the keyword and the rest the\nvalues that follow (until the next keyword). Its return value is accumulated ala\n`mapcar'.\n\nVPLIST is a variadic-property list (a plist whose key may be followed by one or\nmore values).\n\n(fn FN VPLIST)") (autoload 'doom-plist-merge "~/doom-emacs/lisp/lib/plist" "Non-destructively merge FROM-PLIST onto TO-PLIST\n\n(fn FROM-PLIST TO-PLIST)") (autoload 'doom-plist-delete-nil "~/doom-emacs/lisp/lib/plist" "Delete `nil' properties from a copy of PLIST.\n\n(fn PLIST)") (autoload 'doom-plist-keys "~/doom-emacs/lisp/lib/plist" "Return the keys in PLIST.\n\n(fn PLIST)") (autoload 'doom-plist-values "~/doom-emacs/lisp/lib/plist" "Return the values in PLIST.\n\n(fn PLIST)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/print.el") (load-true-file-name load-file-name)) (autoload 'doom-print "~/doom-emacs/lisp/lib/print" "Print OUTPUT to stdout.\n\nUnlike `message', this:\n- Respects the value of `standard-output' (if `doom-print-stream' is nil).\n- Indents according to `doom-print-indent' (if FORMAT is non-nil).\n- Prints to stdout instead of stderr in batch mode.\n- Recognizes more terminal escape codes (only in batch mode).\n- No-ops if OUTPUT is nil or an empty/blank string.\n\nReturns OUTPUT.\n\n(fn OUTPUT &key (FORMAT nil) (LEVEL doom-print-level) (NEWLINE t) (STREAM (or doom-print-stream standard-output)))") (autoload 'format! "~/doom-emacs/lisp/lib/print" "An alternative to `format' that understands `print!'s style syntax.\n\n(fn MESSAGE &rest ARGS)" nil t) (autoload 'print-group! "~/doom-emacs/lisp/lib/print" "Indents any `print!' or `format!' output within BODY.\n\n(fn &rest BODY)" nil t) (function-put 'print-group! 'lisp-indent-function 'defun) (autoload 'print! "~/doom-emacs/lisp/lib/print" "Prints MESSAGE, formatted with ARGS, to stdout.\n\nReturns non-nil if the message is a non-empty string.\n\nCan be colored using (color ...) blocks:\n\n  (print! \"Hello %s\" (bold (blue \"How are you?\")))\n  (print! \"Hello %s\" (red \"World\"))\n  (print! (green \"Great %s!\") \"success\")\n\nUses faces in interactive sessions and ANSI codes otherwise.\n\n(fn MESSAGE &rest ARGS)" nil t) (autoload 'insert! "~/doom-emacs/lisp/lib/print" "Like `insert', but with the power of `format!'.\n\nEach argument in ARGS can be a list, as if they were arguments to `format!':\n(MESSAGE [ARGS...]).\n\n(fn &rest (MESSAGE . ARGS)...)" nil t) (autoload 'with-output-to! "~/doom-emacs/lisp/lib/print" "Capture all output within BODY according to STREAMSPEC.\n\nSTREAMSPEC is a list of log specifications, indicating where to write output\nbased on the print level of the message. For example:\n\n  `((>= notice ,(get-buffer-create \"*stdout*\"))\n    (= error   ,(get-buffer-create \"*errors*\"))\n    (t . ,(get-buffer-create \"*debug*\")))\n\n(fn STREAMSPEC &rest BODY)" nil t) (function-put 'with-output-to! 'lisp-indent-function 1) (autoload 'doom-print--format "~/doom-emacs/lisp/lib/print" "\n\n(fn MESSAGE &rest ARGS)") (autoload 'doom-print--indent "~/doom-emacs/lisp/lib/print" "Indent TEXT by WIDTH spaces. If ARGS, format TEXT with them.\n\n(fn TEXT &optional PREFIX)") (autoload 'doom-print--fill "~/doom-emacs/lisp/lib/print" "Ensure MSG is split into lines no longer than `fill-column'.\n\n(fn MESSAGE &optional COLUMN INDENT)") (autoload 'doom-print--paragraph "~/doom-emacs/lisp/lib/print" "TODO\n\n(fn &rest LINES)") (autoload 'doom-print--join "~/doom-emacs/lisp/lib/print" "Ensure SEQUENCE is joined with SEPARATOR.\n\n`nil' and empty strings in SEQUENCE are omitted.\n\n(fn SEQUENCE &optional SEPARATOR)") (autoload 'doom-print--truncate "~/doom-emacs/lisp/lib/print" "Replaces basic org markup with ansi/text-properties.\n\n(fn TEXT &optional COL ELLIPSIS)") (autoload 'doom-print--buffer "~/doom-emacs/lisp/lib/print" "Replaces basic org markup with ansi/text-properties.\n\n(fn BUFFER &optional BEG END)") (autoload 'doom-print--cli-markup "~/doom-emacs/lisp/lib/print" "Replace `...', `...`, and ```...``` quotes in TEXT with CLI formatting.\n\n- `$ENVVAR' = bolded\n- `--switch' = bolded\n- `ARG' = underlined\n- `symbol' = highlighted in blue\n- `arbitrary code` = highlighted in blue\n- ```\n  Arbitrary multiline code gets highlighted in blue too.\n  ```\n\n(fn TEXT)") (autoload 'doom-print--org "~/doom-emacs/lisp/lib/print" "Replaces basic Org markup with ansi/text-properties.\n\nAll emphasis markers need to be preceded by a backslash.\n\n(fn TEXT)") (autoload 'doom-print--style "~/doom-emacs/lisp/lib/print" "Apply STYLE to formatted MESSAGE with ARGS.\n\nSTYLE is a symbol that correlates to `doom-print-ansi-alist'.\n\nIn a noninteractive session, this wraps the result in ansi color codes.\nOtherwise, it maps colors to a term-color-* face.\n\n(fn STYLE FORMAT &rest ARGS)") (autoload 'doom-print--class "~/doom-emacs/lisp/lib/print" "Apply CLASS to formatted format with ARGS.\n\nCLASS is derived from `doom-print-class-alist', and can contain any arbitrary,\ntransformative logic.\n\n(fn CLASS FORMAT &rest ARGS)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/process.el") (load-true-file-name load-file-name)) (autoload 'doom-call-process "~/doom-emacs/lisp/lib/process" "Execute COMMAND with ARGS synchronously.\n\nReturns (STATUS . OUTPUT) when it is done, where STATUS is the returned error\ncode of the process and OUTPUT is its stdout output.\n\n(fn COMMAND &rest ARGS)") (autoload 'doom-exec-process "~/doom-emacs/lisp/lib/process" "Execute COMMAND with ARGS synchronously.\n\nUnlike `doom-call-process', this pipes output to `standard-output' on the fly to\nsimulate 'exec' in the shell, so batch scripts could run external programs\nsynchronously without sacrificing their output.\n\nWarning: freezes indefinitely on any stdin prompt.\n\n(fn COMMAND &rest ARGS)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/projects.el") (load-true-file-name load-file-name)) (defvar projectile-project-root nil) (defvar projectile-enable-caching (not noninteractive)) (defvar projectile-require-project-root 'prompt) (autoload 'project-file-exists-p! "~/doom-emacs/lisp/lib/projects" "Checks if FILES exist at the current project's root.\n\nThe project's root is determined by `projectile', starting from BASE-DIRECTORY\n(defaults to `default-directory'). FILES are paths relative to the project root,\nunless they begin with a slash.\n\n(fn FILES &optional BASE-DIRECTORY)" nil t) (autoload 'doom/find-file-in-other-project "~/doom-emacs/lisp/lib/projects" "Performs `projectile-find-file' in a known project of your choosing.\n\n(fn PROJECT-ROOT)" t) (autoload 'doom/browse-in-other-project "~/doom-emacs/lisp/lib/projects" "Performs `find-file' in a known project of your choosing.\n\n(fn PROJECT-ROOT)" t) (autoload 'doom/browse-in-emacsd "~/doom-emacs/lisp/lib/projects" "Browse files from `doom-emacs-dir'." t) (autoload 'doom/find-file-in-emacsd "~/doom-emacs/lisp/lib/projects" "Find a file under `doom-emacs-dir', recursively." t) (autoload 'doom/add-directory-as-project "~/doom-emacs/lisp/lib/projects" "Register an arbitrary directory as a project.\n\nUnlike `projectile-add-known-project', if DIR isn't a valid project, a .project\nfile will be created within it so that it will always be treated as one. This\ncommand will throw an error if a parent of DIR is a valid project (which would\nmask DIR).\n\n(fn DIR)" t) (autoload 'doom-project-p "~/doom-emacs/lisp/lib/projects" "Return t if DIR (defaults to `default-directory') is a valid project.\n\n(fn &optional DIR)") (autoload 'doom-project-root "~/doom-emacs/lisp/lib/projects" "Return the project root of DIR (defaults to `default-directory').\nReturns nil if not in a project.\n\n(fn &optional DIR)") (autoload 'doom-project-name "~/doom-emacs/lisp/lib/projects" "Return the name of the current project.\n\nReturns '-' if not in a valid project.\n\n(fn &optional DIR)") (autoload 'doom-project-expand "~/doom-emacs/lisp/lib/projects" "Expand NAME to project root.\n\n(fn NAME &optional DIR)") (autoload 'doom-project-find-file "~/doom-emacs/lisp/lib/projects" "Jump to a file in DIR (searched recursively).\n\nIf DIR is not a project, it will be indexed (but not cached).\n\n(fn DIR)") (autoload 'doom-project-browse "~/doom-emacs/lisp/lib/projects" "Traverse a file structure starting linearly from DIR.\n\n(fn DIR)") (autoload 'doom-project-ignored-p "~/doom-emacs/lisp/lib/projects" "Return non-nil if temporary file or a straight package.\n\n(fn PROJECT-ROOT)") (progn (autoload 'set-project-type! "~/doom-emacs/lisp/lib/projects.el" "Add a project type to `projectile-project-type'.\n\n(fn NAME &key PREDICATE COMPILE RUN TEST CONFIGURE DIR)") (function-put 'set-project-type! 'lisp-indent-function 1)) (put 'set-project-type! 'doom-module '(:doom))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/sandbox.el") (load-true-file-name load-file-name)) (autoload 'doom/sandbox "~/doom-emacs/lisp/lib/sandbox" "Open the Emacs Lisp sandbox.\n\nThis is a test bed for running Emacs Lisp in another instance of Emacs with\nvarying amounts of Doom loaded, including:\n\n  a) vanilla Emacs (nothing loaded),\n  b) vanilla Doom (only Doom core),\n  c) Doom + modules - your private config or\n  c) Doom + modules + your private config (a complete Doom session)\n\nThis is done without sacrificing access to installed packages. Use the sandbox\nto reproduce bugs and determine if Doom is to blame." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/scratch.el") (load-true-file-name load-file-name)) (autoload 'doom-scratch-buffer "~/doom-emacs/lisp/lib/scratch" "Return a scratchpad buffer in major MODE.\n\n(fn &optional DONT-RESTORE-P MODE DIRECTORY PROJECT-NAME)") (autoload 'doom-persist-scratch-buffer-h "~/doom-emacs/lisp/lib/scratch" "Save the current buffer to `doom-scratch-dir'.") (autoload 'doom-persist-scratch-buffers-h "~/doom-emacs/lisp/lib/scratch" "Save all scratch buffers to `doom-scratch-dir'.") (autoload 'doom-persist-scratch-buffers-after-switch-h "~/doom-emacs/lisp/lib/scratch" "Kill scratch buffers when they are no longer visible, saving them to disk.") (unless noninteractive (add-hook 'kill-emacs-hook #'doom-persist-scratch-buffers-h)) (autoload 'doom/open-scratch-buffer "~/doom-emacs/lisp/lib/scratch" "Pop up a persistent scratch buffer.\n\nIf passed the prefix ARG, do not restore the last scratch buffer.\nIf PROJECT-P is non-nil, open a persistent scratch buffer associated with the\n  current project.\n\n(fn &optional ARG PROJECT-P SAME-WINDOW-P)" t) (autoload 'doom/switch-to-scratch-buffer "~/doom-emacs/lisp/lib/scratch" "Like `doom/open-scratch-buffer', but switches to it in the current window.\n\nIf passed the prefix ARG, do not restore the last scratch buffer.\n\n(fn &optional ARG PROJECT-P)" t) (autoload 'doom/open-project-scratch-buffer "~/doom-emacs/lisp/lib/scratch" "Opens the (persistent) project scratch buffer in a popup.\n\nIf passed the prefix ARG, do not restore the last scratch buffer.\n\n(fn &optional ARG SAME-WINDOW-P)" t) (autoload 'doom/switch-to-project-scratch-buffer "~/doom-emacs/lisp/lib/scratch" "Like `doom/open-project-scratch-buffer', but switches to it in the current\nwindow.\n\nIf passed the prefix ARG, do not restore the last scratch buffer.\n\n(fn &optional ARG)" t) (autoload 'doom/revert-scratch-buffer "~/doom-emacs/lisp/lib/scratch" "Revert scratch buffer to last persistent state." t) (autoload 'doom/delete-persistent-scratch-file "~/doom-emacs/lisp/lib/scratch" "Deletes a scratch buffer file in `doom-scratch-dir'.\n\nIf prefix ARG, delete all persistent scratches.\n\n(fn &optional ARG)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/sessions.el") (load-true-file-name load-file-name)) (autoload 'doom-session-file "~/doom-emacs/lisp/lib/sessions" "TODO\n\n(fn &optional NAME)") (autoload 'doom-save-session "~/doom-emacs/lisp/lib/sessions" "TODO\n\n(fn &optional FILE)") (autoload 'doom-load-session "~/doom-emacs/lisp/lib/sessions" "TODO\n\n(fn &optional FILE)") (autoload 'doom/quickload-session "~/doom-emacs/lisp/lib/sessions" "Load the last session saved.\nIf the FORCE \\[universal-argument] is provided\nthen no confirmation is asked.\n\n(fn FORCE)" t) (autoload 'doom/quicksave-session "~/doom-emacs/lisp/lib/sessions" "TODO" t) (autoload 'doom/load-session "~/doom-emacs/lisp/lib/sessions" "TODO\n\n(fn FILE)" t) (autoload 'doom/save-session "~/doom-emacs/lisp/lib/sessions" "TODO\n\n(fn FILE)" t) (autoload 'doom/restart "~/doom-emacs/lisp/lib/sessions" "Restart Emacs (and the daemon, if active).\n\nUnlike `doom/restart-and-restore', does not restart the current session." t) (autoload 'doom/restart-and-restore "~/doom-emacs/lisp/lib/sessions" "Restart Emacs (and the daemon, if active).\n\nIf DEBUG (the prefix arg) is given, start the new instance with the --debug\nswitch.\n\n(fn &optional DEBUG)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/store.el") (load-true-file-name load-file-name)) (autoload 'doom-store-persist "~/doom-emacs/lisp/lib/store" "Persist VARIABLES (list of symbols) in LOCATION (symbol).\nThis populates these variables with cached values, if one exists, and saves them\nto file when Emacs quits. This cannot persist buffer-local variables.\n\n(fn LOCATION VARIABLES)") (autoload 'doom-store-desist "~/doom-emacs/lisp/lib/store" "Unregisters VARIABLES (list of symbols) in LOCATION (symbol).\nVariables to persist are recorded in `doom-store-persist-alist'. Does not affect\nthe actual variables themselves or their values.\n\n(fn LOCATION &optional VARIABLES)") (autoload 'doom-store-get "~/doom-emacs/lisp/lib/store" "Retrieve KEY from LOCATION (defaults to `doom-store-location').\nIf it doesn't exist or has expired, DEFAULT_VALUE is returned.\n\n(fn KEY &optional LOCATION DEFAULT-VALUE NOFLUSH)") (autoload 'doom-store-put "~/doom-emacs/lisp/lib/store" "Set KEY to VALUE in the store at LOCATION.\nKEY can be any lisp object that is comparable with `equal'. TTL is the duration\n(in seconds) after which this cache entry expires; if nil, no cache expiration.\nLOCATION is the super-key to store this cache item under. It defaults to\n`doom-store-location'.\n\n(fn KEY VALUE &optional TTL LOCATION NOFLUSH)") (autoload 'doom-store-rem "~/doom-emacs/lisp/lib/store" "Clear a cache LOCATION (defaults to `doom-store-location').\n\n(fn KEY &optional LOCATION NOFLUSH)") (autoload 'doom-store-member-p "~/doom-emacs/lisp/lib/store" "Return t if KEY in LOCATION exists.\nLOCATION defaults to `doom-store-location'.\n\n(fn KEY &optional LOCATION)") (autoload 'doom-store-clear "~/doom-emacs/lisp/lib/store" "Clear the store at LOCATION (defaults to `doom-store-location').\n\n(fn &optional LOCATION)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/strings.el") (load-true-file-name load-file-name)) (autoload 'doom-pcre-quote "~/doom-emacs/lisp/lib/strings" "Like `reqexp-quote', but for PCREs.\n\n(fn STR)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/system.el") (load-true-file-name load-file-name)) (autoload 'doom-system-distro "~/doom-emacs/lisp/lib/system" "Return a symbol representing the installed distro.") (autoload 'doom-system-distro-version "~/doom-emacs/lisp/lib/system" "Return a distro name and version string.") (autoload 'doom-system-distro-icon "~/doom-emacs/lisp/lib/system" "Display icon for the installed distro.") (autoload 'doom-system-cpus "~/doom-emacs/lisp/lib/system" "Return the max number of processing units on this system.\nTries to be portable. Returns 1 if cannot be determined.") (autoload 'doom-system-supports-symlinks-p "~/doom-emacs/lisp/lib/system" "Return non-nil if this system supports symlinks")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/text.el") (load-true-file-name load-file-name)) (autoload 'doom-syntax-ppss "~/doom-emacs/lisp/lib/text" "Memoize the last result of `syntax-ppss'.\n\nP is the point at which we run `syntax-ppss'\n\n(fn &optional P)") (autoload 'doom-surrounded-p "~/doom-emacs/lisp/lib/text" "Returns t if point is surrounded by a brace delimiter: {[(\n\nIf INLINE is non-nil, only returns t if braces are on the same line, and\nwhitespace is balanced on either side of the cursor.\n\nIf INLINE is nil, returns t if the opening and closing braces are on adjacent\nlines, above and below, with only whitespace in between.\n\n(fn PAIR &optional INLINE BALANCED)") (autoload 'doom-point-in-comment-p "~/doom-emacs/lisp/lib/text" "Return non-nil if point is in a comment.\nPT defaults to the current position.\n\n(fn &optional PT)") (autoload 'doom-point-in-string-p "~/doom-emacs/lisp/lib/text" "Return non-nil if point is inside string.\n\nThis function actually returns the 3rd element of `syntax-ppss'\nwhich can be a number if the string is delimited by that\ncharacter or t if the string is delimited by general string\nfences.\n\nIf optional argument PT is present test this instead of point.\n\n(fn &optional PT)") (autoload 'doom-point-in-string-or-comment-p "~/doom-emacs/lisp/lib/text" "Return non-nil if POS is in a string or comment.\n\n(fn &optional POS)") (autoload 'doom-region-active-p "~/doom-emacs/lisp/lib/text" "Return non-nil if selection is active.\nDetects evil visual mode as well.") (function-put 'doom-region-active-p 'side-effect-free 't) (autoload 'doom-region-beginning "~/doom-emacs/lisp/lib/text" "Return beginning position of selection.\nUses `evil-visual-beginning' if available.") (function-put 'doom-region-beginning 'side-effect-free 't) (autoload 'doom-region-end "~/doom-emacs/lisp/lib/text" "Return end position of selection.\nUses `evil-visual-end' if available.") (function-put 'doom-region-end 'side-effect-free 't) (autoload 'doom-region "~/doom-emacs/lisp/lib/text" "Return the bounds of the current seelction.\n\nIf AS-LIST is non-nil, returns (BEG END). Otherwise returns a cons cell (BEG .\nEND).\n\n(fn &optional AS-LIST)") (autoload 'doom-thing-at-point-or-region "~/doom-emacs/lisp/lib/text" "Grab the current selection, THING at point, or xref identifier at point.\n\nReturns THING if it is a string. Otherwise, if nothing is found at point and\nPROMPT is non-nil, prompt for a string (if PROMPT is a string it'll be used as\nthe prompting string). Returns nil if all else fails.\n\nNOTE: Don't use THING for grabbing symbol-at-point. The xref fallback is smarter\nin some cases.\n\n(fn &optional THING PROMPT)") (function-put 'doom-thing-at-point-or-region 'side-effect-free 't) (autoload 'doom/backward-to-bol-or-indent "~/doom-emacs/lisp/lib/text" "Jump between the indentation column (first non-whitespace character) and the\nbeginning of the line. The opposite of\n`doom/forward-to-last-non-comment-or-eol'.\n\n(fn &optional POINT)" t) (autoload 'doom/forward-to-last-non-comment-or-eol "~/doom-emacs/lisp/lib/text" "Jumps between the last non-blank, non-comment character in the line and the\ntrue end of the line. The opposite of `doom/backward-to-bol-or-indent'.\n\n(fn &optional POINT)" t) (autoload 'doom/backward-kill-to-bol-and-indent "~/doom-emacs/lisp/lib/text" "Kill line to the first non-blank character. If invoked again afterwards, kill\nline to beginning of line. Same as `evil-delete-back-to-indentation'." t) (autoload 'doom/delete-backward-word "~/doom-emacs/lisp/lib/text" "Like `backward-kill-word', but doesn't affect the kill-ring.\n\n(fn ARG)" t) (autoload 'doom/dumb-indent "~/doom-emacs/lisp/lib/text" "Inserts a tab character (or spaces x tab-width)." t) (autoload 'doom/dumb-dedent "~/doom-emacs/lisp/lib/text" "Dedents the current line." t) (autoload 'doom/retab "~/doom-emacs/lisp/lib/text" "Converts tabs-to-spaces or spaces-to-tabs within BEG and END (defaults to\nbuffer start and end, to make indentation consistent. Which it does depends on\nthe value of `indent-tab-mode'.\n\nIf ARG (universal argument) is non-nil, retab the current buffer using the\nopposite indentation style.\n\n(fn ARG &optional BEG END)" t) (autoload 'doom/delete-trailing-newlines "~/doom-emacs/lisp/lib/text" "Trim trailing newlines.\n\nRespects `require-final-newline'." t) (autoload 'doom/dos2unix "~/doom-emacs/lisp/lib/text" "Convert the current buffer to a Unix file encoding." t) (autoload 'doom/unix2dos "~/doom-emacs/lisp/lib/text" "Convert the current buffer to a DOS file encoding." t) (autoload 'doom/toggle-indent-style "~/doom-emacs/lisp/lib/text" "Switch between tabs and spaces indentation style in the current buffer." t) (autoload 'doom/set-indent-width "~/doom-emacs/lisp/lib/text" "Change the indentation size to WIDTH of the current buffer.\n\nThe effectiveness of this command is significantly improved if you have\neditorconfig or dtrt-indent installed.\n\n(fn WIDTH)" t) (autoload 'doom-enable-delete-trailing-whitespace-h "~/doom-emacs/lisp/lib/text" "Enables the automatic deletion of trailing whitespaces upon file save.\n\ni.e. enables `ws-butler-mode' in the current buffer.") (autoload 'doom-disable-delete-trailing-whitespace-h "~/doom-emacs/lisp/lib/text" "Disables the automatic deletion of trailing whitespaces upon file save.\n\ni.e. disables `ws-butler-mode' in the current buffer.") (autoload 'doom-enable-show-trailing-whitespace-h "~/doom-emacs/lisp/lib/text" "Enable `show-trailing-whitespace' in the current buffer.") (autoload 'doom-disable-show-trailing-whitespace-h "~/doom-emacs/lisp/lib/text" "Disable `show-trailing-whitespace' in the current buffer.")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/themes.el") (load-true-file-name load-file-name)) (defconst doom-customize-theme-hook nil) (autoload 'doom--run-customize-theme-hook "~/doom-emacs/lisp/lib/themes" "Run FN, but suppress any writes to `custom-file'.\n\n(fn FN)") (autoload 'custom-theme-set-faces! "~/doom-emacs/lisp/lib/themes" "Apply a list of face SPECS as user customizations for THEME.\n\nTHEME can be a single symbol or list thereof. If nil, apply these settings to\nall themes. It will apply to all themes once they are loaded.\n\n(fn THEME &rest SPECS)" nil t) (function-put 'custom-theme-set-faces! 'lisp-indent-function 'defun) (autoload 'custom-set-faces! "~/doom-emacs/lisp/lib/themes" "Apply a list of face SPECS as user customizations.\n\nThis is a convenience macro alternative to `custom-set-face' which allows for a\nsimplified face format, and takes care of load order issues, so you can use\ndoom-themes' API without worry.\n\n(fn &rest SPECS)" nil t) (function-put 'custom-set-faces! 'lisp-indent-function 'defun) (autoload 'doom/reload-theme "~/doom-emacs/lisp/lib/themes" "Reload all currently active themes." t) (autoload 'doom-theme-face-attribute "~/doom-emacs/lisp/lib/themes" "Read a FACE's ATTRIBUTE for a loaded THEME.\n\nThis is different from `face-attribute', which reads the attribute of an active\nface for the current theme, but an active theme can change (or fail to load) in\nnon-interactive or frame-less sessions.\n\n(fn THEME FACE ATTRIBUTE &optional RECURSIVE)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/lisp/lib/ui.el") (load-true-file-name load-file-name)) (autoload 'doom-resize-window "~/doom-emacs/lisp/lib/ui" "Resize a window to NEW-SIZE. If HORIZONTAL, do it width-wise.\nIf FORCE-P is omitted when `window-size-fixed' is non-nil, resizing will fail.\n\n(fn WINDOW NEW-SIZE &optional HORIZONTAL FORCE-P)") (autoload 'doom-quit-p "~/doom-emacs/lisp/lib/ui" "Prompt the user for confirmation when killing Emacs.\n\nReturns t if it is safe to kill this session. Does not prompt if no real buffers\nare open.\n\n(fn &optional PROMPT)") (autoload 'doom-recenter-a "~/doom-emacs/lisp/lib/ui" "Generic advice for recentering window (typically :after other functions).\n\n(fn &rest _)") (autoload 'doom-preserve-window-position-a "~/doom-emacs/lisp/lib/ui" "Generic advice for preserving cursor position on screen after scrolling.\n\n(fn FN &rest ARGS)") (autoload 'doom-shut-up-a "~/doom-emacs/lisp/lib/ui" "Generic advisor for silencing noisy functions.\n\nIn interactive Emacs, this just inhibits messages from appearing in the\nminibuffer. They are still logged to *Messages*.\n\nIn tty Emacs, messages are suppressed completely.\n\n(fn FN &rest ARGS)") (autoload 'doom-apply-ansi-color-to-compilation-buffer-h "~/doom-emacs/lisp/lib/ui" "Applies ansi codes to the compilation buffers. Meant for\n`compilation-filter-hook'.") (autoload 'doom-disable-show-paren-mode-h "~/doom-emacs/lisp/lib/ui" "Turn off `show-paren-mode' buffer-locally.") (autoload 'doom-enable-line-numbers-h "~/doom-emacs/lisp/lib/ui") (autoload 'doom-disable-line-numbers-h "~/doom-emacs/lisp/lib/ui") (autoload 'doom/toggle-line-numbers "~/doom-emacs/lisp/lib/ui" "Toggle line numbers.\n\nCycles through regular, relative and no line numbers. The order depends on what\n`display-line-numbers-type' is set to. If you're using Emacs 26+, and\nvisual-line-mode is on, this skips relative and uses visual instead.\n\nSee `display-line-numbers' for what these values mean." t) (autoload 'doom/delete-frame-with-prompt "~/doom-emacs/lisp/lib/ui" "Delete the current frame, but ask for confirmation if it isn't empty." t) (autoload 'doom/window-maximize-buffer "~/doom-emacs/lisp/lib/ui" "Close other windows to focus on this one.\nUse `winner-undo' to undo this. Alternatively, use `doom/window-enlargen'.\n\n(fn &optional ARG)" t) (autoload 'doom/window-enlargen "~/doom-emacs/lisp/lib/ui" "Enlargen the current window (i.e. shrinks others) so you can focus on it.\nUse `winner-undo' to undo this. Alternatively, use\n`doom/window-maximize-buffer'.\n\n(fn &optional ARG)" t) (autoload 'doom/window-maximize-horizontally "~/doom-emacs/lisp/lib/ui" "Delete all windows to the left and right of the current window." t) (autoload 'doom/window-maximize-vertically "~/doom-emacs/lisp/lib/ui" "Delete all windows above and below the current window." t) (autoload 'doom/set-frame-opacity "~/doom-emacs/lisp/lib/ui" "Interactively change the current frame's opacity.\n\nOPACITY is an integer between 0 to 100, inclusive.\n\n(fn OPACITY)" t) (autoload 'doom/narrow-buffer-indirectly "~/doom-emacs/lisp/lib/ui" "Restrict editing in this buffer to the current region, indirectly.\n\nThis recursively creates indirect clones of the current buffer so that the\nnarrowing doesn't affect other windows displaying the same buffer. Call\n`doom/widen-indirectly-narrowed-buffer' to undo it (incrementally).\n\nInspired from http://demonastery.org/2013/04/emacs-evil-narrow-region/\n\n(fn BEG END)" t) (autoload 'doom/widen-indirectly-narrowed-buffer "~/doom-emacs/lisp/lib/ui" "Widens narrowed buffers.\n\nThis command will incrementally kill indirect buffers (under the assumption they\nwere created by `doom/narrow-buffer-indirectly') and switch to their base\nbuffer.\n\nIf ARG, then kill all indirect buffers, return the base buffer and widen it.\n\nIf the current buffer is not an indirect buffer, it is `widen'ed.\n\n(fn &optional ARG)" t) (autoload 'doom/toggle-narrow-buffer "~/doom-emacs/lisp/lib/ui" "Narrow the buffer to BEG END. If narrowed, widen it.\n\n(fn BEG END)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/app/irc/autoload/settings.el") (load-true-file-name load-file-name)) (defmacro set-irc-server! (server plist) "THIS FUNCTION DOES NOTHING BECAUSE (:app . irc) IS DISABLED\n\nRegisters an irc SERVER for circe.\n\nSERVER can either be a name for the network (in which case you must specify a\n:host), or it may be the hostname itself, in which case it will be used as the\n:host.\n\nSee `circe-network-options' for details." (ignore server plist)) (put 'set-irc-server! 'doom-module '(:app . irc))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/checkers/spell/autoload/+flyspell.el") (load-true-file-name load-file-name)) (put 'flyspell-mode! 'doom-module '(:checkers . spell)) (defalias 'flyspell-mode! #'ignore "THIS FUNCTION DOES NOTHING BECAUSE (:checkers . spell) IS DISABLED\n\nnil") (defmacro set-flyspell-predicate! (modes predicate) "THIS FUNCTION DOES NOTHING BECAUSE (:checkers . spell) IS DISABLED\n\nTODO" (ignore modes predicate)) (put 'set-flyspell-predicate! 'doom-module '(:checkers . spell))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/company/autoload.el") (load-true-file-name load-file-name)) (defmacro set-company-backend! (modes &rest backends) "THIS FUNCTION DOES NOTHING BECAUSE (:completion . company) IS DISABLED\n\nPrepends BACKENDS (in order) to `company-backends' in MODES.\n\nMODES should be one symbol or a list of them, representing major or minor modes.\nThis will overwrite backends for MODES on consecutive uses.\n\nIf the car of BACKENDS is nil, unset the backends for MODES.\n\nExamples:\n\n  (set-company-backend! 'js2-mode\n    'company-tide 'company-yasnippet)\n\n  (set-company-backend! 'sh-mode\n    '(company-shell :with company-yasnippet))\n\n  (set-company-backend! '(c-mode c++-mode)\n    '(:separate company-irony-c-headers company-irony))\n\n  (set-company-backend! 'sh-mode nil)  ; unsets backends for sh-mode" (ignore modes backends)) (put 'set-company-backend! 'doom-module '(:completion . company))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/format/autoload/settings.el") (load-true-file-name load-file-name)) (cl-defmacro set-formatter! (name args &key modes) "THIS FUNCTION DOES NOTHING BECAUSE (:editor . format) IS DISABLED\n\nDefine (or modify) a formatter named NAME.\n\nSupported keywords: :modes\n\nNAME is a symbol that identifies this formatter.\n\nFORMATTER can be a symbol referring to another formatter, a function, string or\nnested list.\n\n  If a function, it should be a formatter function that\n    `apheleia--run-formatter-function' will accept.\n  If a string, it is assumed to be a shell command that the buffer's text will\n    be piped to (through stdin).\n  If a list, it should represent a shell command as a list of arguments. Each\n    element is either a string or list (STRING ARG) where STRING is a format\n    string and ARG is both a predicate and argument for STRING. If ARG is nil,\n    STRING will be omitted from the vector.\n\nIf you're trying to override this, ensure that you wrap the call in `after!' and\nwhichever package sets the initial formatter. See the ':editor format' README\nfor more.\n\nFor more information on how to structure the list to be compatible, see\n`apheleia--run-formatter-function'.\n\nMODES is a major mode, a list thereof, or a list of two-element sublists with\nthe structure: (MAJOR-MODE FORM). FORM is evaluated when the buffer is formatted\nand its return value serves two purposes:\n\n  1. It is a predicate for this formatter. Assuming the MAJOR-MODE matches the\n     current mode, if FORM evaluates to nil, the formatter is skipped.\n  2. It's return value is made available to FORMATTER if it is a function or\n     list of shell arguments via the `mode-result' variable.\n\nBasic examples:\n  (set-formatter! \\='asmfmt \"asmfmt\" :modes \\='(asm-mode nasm-mode))\n  (set-formatter! \\='black \"black -q -\")\n  (set-formatter! \\='html-tidy \"tidy -q -indent\" :modes \\='(html-mode web-mode))\n\nAdvanced examples:\n  (set-formatter!\n    \\='clang-format\n    \\='(\"clang-format\"\n      (\"-assume-filename=%S\" (or buffer-file-name mode-result \"\")))\n    :modes\n    \\='((c-mode \".c\")\n      (c++-mode \".cpp\")\n      (java-mode \".java\")\n      (objc-mode \".m\")\n      (protobuf-mode \".proto\")))\n\n  (set-formatter! \\='html-tidy\n    \\='(\"tidy\" \"-q\" \"-indent\"\n      (\"-xml\" (memq major-mode \\='(nxml-mode xml-mode))))\n    :modes\n    \\='(html-mode\n      (web-mode (and (equal \"none\" web-mode-engine)\n                     (car (member web-mode-content-type \\='(\"xml\" \"html\")))))))\n\n  (set-formatter! \\='html-tidy  ; overwrite predefined html-tidy formatter\n    \\='(\"tidy\" \"-q\" \"-indent\"\n      \"--tidy-mark\" \"no\"\n      \"--drop-empty-elements\" \"no\"\n      \"--show-body-only\" \"auto\"\n      (\"--indent-spaces\" \"%d\" tab-width)\n      (\"--indent-with-tabs\" \"%s\" (if indent-tabs-mode \"yes\" \"no\"))\n      (\"-xml\" (memq major-mode \\='(nxml-mode xml-mode)))))\n\n  (set-formatter! \\='elm-format\n    \"elm-format --yes --stdin\")" (ignore name args modes)) (put 'set-formatter! 'doom-module '(:editor . format))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/rotate-text/autoload.el") (load-true-file-name load-file-name)) (cl-defmacro set-rotate-patterns! (modes &key symbols words patterns) "THIS FUNCTION DOES NOTHING BECAUSE (:editor . rotate-text) IS DISABLED\n\nDeclare :symbols, :words or :patterns (all lists of strings) that\n`rotate-text' will cycle through." (ignore modes symbols words patterns)) (put 'set-rotate-patterns! 'doom-module '(:editor . rotate-text))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/email/mu4e/autoload/email.el") (load-true-file-name load-file-name)) (defmacro set-email-account! (label letvars &optional default-p) "THIS FUNCTION DOES NOTHING BECAUSE (:email . mu4e) IS DISABLED\n\nRegisters an email address for mu4e. The LABEL is a string. LETVARS are a\nlist of cons cells (VARIABLE . VALUE) -- you may want to modify:\n\n + `user-full-name' (used to populate the FROM field when composing mail)\n + `user-mail-address' (required in mu4e < 1.4)\n + `smtpmail-smtp-user' (required for sending mail from Emacs)\n\nOPTIONAL:\n + `mu4e-sent-folder'\n + `mu4e-drafts-folder'\n + `mu4e-trash-folder'\n + `mu4e-refile-folder'\n + `mu4e-compose-signature'\n + `+mu4e-personal-addresses'\n\nDEFAULT-P is a boolean. If non-nil, it marks that email account as the\ndefault/fallback account." (ignore label letvars default-p)) (put 'set-email-account! 'doom-module '(:email . mu4e))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/term/eshell/autoload/settings.el") (load-true-file-name load-file-name)) (defmacro set-eshell-alias! (&rest aliases) "THIS FUNCTION DOES NOTHING BECAUSE (:term . eshell) IS DISABLED\n\nDefine aliases for eshell.\n\nALIASES is a flat list of alias -> command pairs. e.g.\n\n  (set-eshell-alias!\n    \"hi\"  \"echo hello world\"\n    \"bye\" \"echo goodbye world\")" (ignore aliases)) (put 'set-eshell-alias! 'doom-module '(:term . eshell))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/editorconfig/autoload.el") (load-true-file-name load-file-name)) (defmacro set-editorconfig-indent-var! (mode &rest vars) "THIS FUNCTION DOES NOTHING BECAUSE (:tools . editorconfig) IS DISABLED\n\nAdd (MODE VARS...) to `editorconfig-indentation-alist'." (ignore mode vars)) (put 'set-editorconfig-indent-var! 'doom-module '(:tools . editorconfig))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lsp/autoload/common.el") (load-true-file-name load-file-name)) (fset 'lsp! #'ignore)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lsp/autoload/eglot.el") (load-true-file-name load-file-name)) (defmacro set-eglot-client! (mode server-call) "THIS FUNCTION DOES NOTHING BECAUSE (:tools . lsp) IS DISABLED\n\nAdd SERVER-CALL list as a possible lsp server for given major MODE.\n\nExample : (set-eglot-client! 'python-mode `(,(concat doom-data-dir \"lsp/mspyls/Microsoft.Python.LanguageServer\")))" (ignore mode server-call)) (put 'set-eglot-client! 'doom-module '(:tools . lsp))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lsp/autoload/lsp-mode.el") (load-true-file-name load-file-name)) (defmacro set-lsp-priority! (client priority) "THIS FUNCTION DOES NOTHING BECAUSE (:tools . lsp) IS DISABLED\n\nChange the PRIORITY of lsp CLIENT." (ignore client priority)) (put 'set-lsp-priority! 'doom-module '(:tools . lsp))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/tree-sitter/autoload.el") (load-true-file-name load-file-name)) (fset 'tree-sitter! #'ignore) (fset 'set-tree-sitter-lang! #'ignore)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/ligatures/autoload/ligatures.el") (load-true-file-name load-file-name)) (defmacro set-ligatures! (modes &rest plist) "THIS FUNCTION DOES NOTHING BECAUSE (:ui . ligatures) IS DISABLED\n\nAssociates string patterns with icons in certain major-modes.\n\n  MODES is a major mode symbol or a list of them.\n  PLIST is a property list whose keys must match keys in\n`+ligatures-extra-symbols', and whose values are strings representing the text\nto be replaced with that symbol.\n\nIf the car of PLIST is nil, then unset any\npretty symbols and ligatures previously defined for MODES.\n\nFor example, the rule for emacs-lisp-mode is very simple:\n\n  (after! elisp-mode\n    (set-ligatures! \\='emacs-lisp-mode\n      :lambda \"lambda\"))\n\nThis will replace any instances of \"lambda\" in emacs-lisp-mode with the symbol\nassociated with :lambda in `+ligatures-extra-symbols'.\n\nPretty symbols can be unset by passing `nil':\n\n  (after! rustic\n    (set-ligatures! \\='rustic-mode nil))\n\nNote that this will keep all ligatures in `+ligatures-prog-mode-list' active, as\n`emacs-lisp-mode' is derived from `prog-mode'." (ignore modes plist)) (put 'set-ligatures! 'doom-module '(:ui . ligatures)) (defmacro set-font-ligatures! (modes &rest ligatures) "THIS FUNCTION DOES NOTHING BECAUSE (:ui . ligatures) IS DISABLED\n\nAssociates string patterns with ligatures in certain major-modes.\n\n  MODES is a major mode symbol or a list of them.\n  LIGATURES is a list of ligatures that should be handled by the font,\n    like \"==\" or \"-->\". LIGATURES is a list of strings.\n\nFor example, the rule for emacs-lisp-mode is very simple:\n\n  (set-font-ligatures! \\='emacs-lisp-mode \"->\")\n\nThis will ligate \"->\" into the arrow of choice according to your font.\n\nAll font ligatures for emacs-lisp-mode can be unset with:\n\n  (set-font-ligatures! \\='emacs-lisp-mode nil)\n\nHowever, ligatures for any parent modes (like `prog-mode') will still be in\neffect, as `emacs-lisp-mode' is derived from `prog-mode'." (ignore modes ligatures)) (put 'set-font-ligatures! 'doom-module '(:ui . ligatures))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/corfu/autoload.el") (load-true-file-name load-file-name)) (autoload '+corfu-dabbrev-friend-buffer-p "~/doom-emacs/modules/completion/corfu/autoload" "\n\n(fn OTHER-BUFFER)") (autoload '+corfu/move-to-minibuffer "~/doom-emacs/modules/completion/corfu/autoload" "Move list of candidates to your choice of minibuffer completion UI." t) (autoload '+corfu/smart-sep-toggle-escape "~/doom-emacs/modules/completion/corfu/autoload" "Insert `corfu-separator' or toggle escape if it's already there." t) (autoload '+corfu/dabbrev-this-buffer "~/doom-emacs/modules/completion/corfu/autoload" "Like `cape-dabbrev', but only scans current buffer." t) (autoload '+corfu/toggle-auto-complete "~/doom-emacs/modules/completion/corfu/autoload" "Toggle as-you-type completion in Corfu.\n\n(fn &optional INTERACTIVE)" t) (autoload '+corfu/dabbrev-or-next "~/doom-emacs/modules/completion/corfu/autoload" "Trigger corfu popup and select the first candidate.\n\nIntended to mimic `evil-complete-next', unless the popup is already open.\n\n(fn &optional ARG)" t) (autoload '+corfu/dabbrev-or-last "~/doom-emacs/modules/completion/corfu/autoload" "Trigger corfu popup and select the first candidate.\n\nIntended to mimic `evil-complete-previous', unless the popup is already open.\n\n(fn &optional ARG)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/vertico/autoload/evil.el") (load-true-file-name load-file-name)) (autoload '+vertico:project-search "~/doom-emacs/modules/completion/vertico/autoload/evil" nil t) (autoload '+vertico:project-search-from-cwd "~/doom-emacs/modules/completion/vertico/autoload/evil" nil t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/vertico/autoload/magit.el") (load-true-file-name load-file-name)) (autoload '+vertico/embark-magit-status "~/doom-emacs/modules/completion/vertico/autoload/magit" "Run `magit-status` on repo containing the embark target.\n\n(fn FILE)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/vertico/autoload/vertico.el") (load-true-file-name load-file-name)) (defvar embark-quit-after-action) (autoload '+vertico-file-search "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Conduct a file search using ripgrep.\n\n:query STRING\n  Determines the initial input to search for.\n:in PATH\n  Sets what directory to base the search out of. Defaults to the current project's root.\n:recursive BOOL\n  Whether or not to search files recursively from the base directory.\n:args LIST\n  Arguments to be appended to `consult-ripgrep-args'.\n\n(fn &key QUERY IN ALL-FILES (RECURSIVE t) PROMPT ARGS)") (function-put '+vertico-file-search 'lisp-indent-function 'defun) (autoload '+vertico/project-search "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Performs a live project search from the project root using ripgrep.\nIf ARG (universal argument), include all files, even hidden or compressed ones,\nin the search.\n\n(fn &optional ARG INITIAL-QUERY DIRECTORY)" t) (autoload '+vertico/project-search-from-cwd "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Performs a live project search from the current directory.\nIf ARG (universal argument), include all files, even hidden or compressed ones.\n\n(fn &optional ARG INITIAL-QUERY)" t) (autoload '+vertico/search-symbol-at-point "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Performs a search in the current buffer for thing at point." t) (autoload '+vertico-embark-target-package-fn "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Targets Doom's package! statements and returns the package name") (autoload '+vertico/embark-export-write "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Export the current vertico results to a writable buffer if possible.\n\nSupports exporting consult-grep to wgrep, file to wdeired, and consult-location to occur-edit" t) (autoload '+vertico/embark-preview "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Previews candidate in vertico buffer, unless it's a consult command" t) (autoload '+vertico/enter-or-preview "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Enter directory or embark preview on current candidate." t) (autoload '+vertico/jump-list "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Go to an entry in evil's (or better-jumper's) jumplist.\n\n(fn JUMP)" t) (autoload '+vertico-embark-which-key-indicator "~/doom-emacs/modules/completion/vertico/autoload/vertico" "An embark indicator that displays keymaps using which-key.\nThe which-key help message will show the type and value of the\ncurrent target followed by an ellipsis if there are further\ntargets.") (autoload '+vertico/consult-fd-or-find "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Runs consult-fd if fd version > 8.6.0 exists, consult-find otherwise.\nSee minad/consult#770.\n\n(fn &optional DIR INITIAL)" t) (autoload '+vertico-basic-remote-try-completion "~/doom-emacs/modules/completion/vertico/autoload/vertico" "\n\n(fn STRING TABLE PRED POINT)") (autoload '+vertico-basic-remote-all-completions "~/doom-emacs/modules/completion/vertico/autoload/vertico" "\n\n(fn STRING TABLE PRED POINT)") (autoload '+vertico-orderless-dispatch "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Like `orderless-affix-dispatch', but allows affixes to be escaped.\n\n(fn PATTERN INDEX TOTAL)") (autoload '+vertico-orderless-disambiguation-dispatch "~/doom-emacs/modules/completion/vertico/autoload/vertico" "Ensure $ works with Consult commands, which add disambiguation suffixes.\n\n(fn PATTERN INDEX TOTAL)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/vertico/autoload/workspaces.el") (load-true-file-name load-file-name)) (autoload '+vertico/switch-workspace-buffer "~/doom-emacs/modules/completion/vertico/autoload/workspaces" "Switch to another buffer in the same or a specified workspace.\n\nType the workspace's number (starting from 1) followed by a space to display its\nbuffer list. Selecting a buffer in another workspace will switch to that\nworkspace instead. If FORCE-SAME-WORKSPACE (the prefix arg) is non-nil, that\nbuffer will be opened in the current workspace instead.\n\n(fn &optional FORCE-SAME-WORKSPACE)" t) (autoload '+vertico/embark-open-in-new-workspace "~/doom-emacs/modules/completion/vertico/autoload/workspaces" "Open file in a new workspace.\n\n(fn FILE)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/doom-dashboard/autoload.el") (load-true-file-name load-file-name)) (autoload '+doom-dashboard/open "~/doom-emacs/modules/ui/doom-dashboard/autoload" "Switch to the dashboard in the current window, of the current FRAME.\n\n(fn FRAME)" t) (autoload '+doom-dashboard/forward-button "~/doom-emacs/modules/ui/doom-dashboard/autoload" "Like `forward-button', but don't wrap.\n\n(fn N)" t) (autoload '+doom-dashboard/backward-button "~/doom-emacs/modules/ui/doom-dashboard/autoload" "Like `backward-button', but don't wrap.\n\n(fn N)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/modeline/autoload.el") (load-true-file-name load-file-name)) (autoload '+modeline-resize-for-font-h "~/doom-emacs/modules/ui/modeline/autoload" "Adjust the modeline's height when the font size is changed by\n`doom/increase-font-size' or `doom/decrease-font-size'.\n\nMeant for `doom-change-font-size-hook'.") (autoload '+modeline-update-env-in-all-windows-h "~/doom-emacs/modules/ui/modeline/autoload" "Update version strings in all buffers.\n\n(fn &rest _)") (autoload '+modeline-clear-env-in-all-windows-h "~/doom-emacs/modules/ui/modeline/autoload" "Blank out version strings in all buffers.\n\n(fn &rest _)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/popup/autoload/popup.el") (load-true-file-name load-file-name)) (autoload '+popup--init "~/doom-emacs/modules/ui/popup/autoload/popup" "Initializes a popup window. Run any time a popup is opened. It sets the\ndefault window parameters for popup windows, clears leftover transient timers\nand enables `+popup-buffer-mode'.\n\n(fn WINDOW &optional ALIST)") (autoload '+popup-buffer-p "~/doom-emacs/modules/ui/popup/autoload/popup" "Return non-nil if BUFFER is a popup buffer. Defaults to the current buffer.\n\n(fn &optional BUFFER)") (autoload '+popup-window-p "~/doom-emacs/modules/ui/popup/autoload/popup" "Return non-nil if WINDOW is a popup window. Defaults to the current window.\n\n(fn &optional WINDOW)") (autoload '+popup-buffer "~/doom-emacs/modules/ui/popup/autoload/popup" "Open BUFFER in a popup window. ALIST describes its features.\n\n(fn BUFFER &optional ALIST)") (autoload '+popup-parameter "~/doom-emacs/modules/ui/popup/autoload/popup" "Fetch the window PARAMETER (symbol) of WINDOW\n\n(fn PARAMETER &optional WINDOW)") (autoload '+popup-parameter-fn "~/doom-emacs/modules/ui/popup/autoload/popup" "Fetch the window PARAMETER (symbol) of WINDOW. If it is a function, run it\nwith ARGS to get its return value.\n\n(fn PARAMETER &optional WINDOW &rest ARGS)") (autoload '+popup-windows "~/doom-emacs/modules/ui/popup/autoload/popup" "Returns a list of all popup windows.") (autoload '+popup-shrink-to-fit "~/doom-emacs/modules/ui/popup/autoload/popup" "Shrinks WINDOW to fit the buffer contents, if the buffer isn't empty.\n\nUses `shrink-window-if-larger-than-buffer'.\n\n(fn &optional WINDOW)") (autoload '+popup-alist-from-window-state "~/doom-emacs/modules/ui/popup/autoload/popup" "Convert window STATE (from `window-state-get') to a `display-buffer' alist.\n\n(fn STATE)") (autoload '+popup-adjust-fringes-h "~/doom-emacs/modules/ui/popup/autoload/popup" "Hides the fringe in popup windows, restoring them if `+popup-buffer-mode' is\ndisabled.") (autoload '+popup-adjust-margins-h "~/doom-emacs/modules/ui/popup/autoload/popup" "Creates padding for the popup window determined by `+popup-margin-width',\nrestoring it if `+popup-buffer-mode' is disabled.") (autoload '+popup-set-modeline-on-enable-h "~/doom-emacs/modules/ui/popup/autoload/popup" "Don't show modeline in popup windows without a `modeline' window-parameter.\nPossible values for this parameter are:\n\n  t            show the mode-line as normal\n  nil          hide the modeline entirely (the default)\n  a function   `mode-line-format' is set to its return value\n\nAny non-nil value besides the above will be used as the raw value for\n`mode-line-format'.") (autoload '+popup-unset-modeline-on-disable-h "~/doom-emacs/modules/ui/popup/autoload/popup" "Restore the modeline when `+popup-buffer-mode' is deactivated.") (autoload '+popup-close-on-escape-h "~/doom-emacs/modules/ui/popup/autoload/popup" "If called inside a popup, try to close that popup window (see\n`+popup/close'). If called outside, try to close all popup windows (see\n`+popup/close-all').") (autoload '+popup-cleanup-rules-h "~/doom-emacs/modules/ui/popup/autoload/popup" "Cleans up any duplicate popup rules." t) (autoload '+popup-kill-buffer-hook-h "~/doom-emacs/modules/ui/popup/autoload/popup" "TODO") (defalias 'other-popup #'+popup/other) (autoload '+popup/buffer "~/doom-emacs/modules/ui/popup/autoload/popup" "Open this buffer in a popup window." t) (autoload '+popup/other "~/doom-emacs/modules/ui/popup/autoload/popup" "Cycle through popup windows, like `other-window'. Ignores regular windows." t) (autoload '+popup/close "~/doom-emacs/modules/ui/popup/autoload/popup" "Close WINDOW, if it's a popup window.\n\nThis will do nothing if the popup's `quit' window parameter is either nil or\n'other. This window parameter is ignored if FORCE-P is non-nil.\n\n(fn &optional WINDOW FORCE-P)" t) (autoload '+popup/close-all "~/doom-emacs/modules/ui/popup/autoload/popup" "Close all open popup windows.\n\nThis will ignore popups with an `quit' parameter that is either nil or 'current.\nThis window parameter is ignored if FORCE-P is non-nil.\n\n(fn &optional FORCE-P)" t) (autoload '+popup/toggle "~/doom-emacs/modules/ui/popup/autoload/popup" "Toggle any visible popups.\nIf no popups are available, display the *Messages* buffer in a popup window." t) (autoload '+popup/restore "~/doom-emacs/modules/ui/popup/autoload/popup" "Restore the last popups that were closed, if any." t) (autoload '+popup/raise "~/doom-emacs/modules/ui/popup/autoload/popup" "Raise a popup WINDOW into a regular window, then select it.\n\nWhen called interactively, the selected popup window will be raised. If the\nselected window isn't a popup, any sole, visible popup window in the active\nframe will be raised. If there are multiple visible popups, then the user will\nbe prompted to select one.\n\nIf prefix ARG, the popup is raised into `other-window' instead.\n\n(fn WINDOW &optional ARG)" t) (autoload '+popup/diagnose "~/doom-emacs/modules/ui/popup/autoload/popup" "Reveal what popup rule will be used for the current buffer." t) (autoload '+popup-close-a "~/doom-emacs/modules/ui/popup/autoload/popup" "TODO\n\n(fn &rest _)") (autoload '+popup-save-a "~/doom-emacs/modules/ui/popup/autoload/popup" "Sets aside all popups before executing the original function, usually to\nprevent the popup(s) from messing up the UI (or vice versa).\n\n(fn FN &rest ARGS)") (autoload '+popup-display-buffer-fullframe-fn "~/doom-emacs/modules/ui/popup/autoload/popup" "Displays the buffer fullscreen.\n\n(fn BUFFER ALIST)") (autoload '+popup-display-buffer-stacked-side-window-fn "~/doom-emacs/modules/ui/popup/autoload/popup" "A `display-buffer' action that serves as an alternative to\n`display-buffer-in-side-window', but allows for stacking popups with the `vslot'\nalist entry.\n\nAccepts the same arguments as `display-buffer-in-side-window'. You must set\n`window--sides-inhibit-check' to non-nil for this work properly.\n\n(fn BUFFER ALIST)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/popup/autoload/settings.el") (load-true-file-name load-file-name)) (defvar +popup--display-buffer-alist nil) (defvar +popup-defaults (list :side 'bottom :height 0.16 :width 40 :quit t :select #'ignore :ttl 5) "Default properties for popup rules defined with `set-popup-rule!'.") (autoload '+popup-make-rule "~/doom-emacs/modules/ui/popup/autoload/settings" "\n\n(fn PREDICATE PLIST)") (progn (autoload 'set-popup-rule! "~/doom-emacs/modules/ui/popup/autoload/settings.el" "Define a popup rule.\n\nThese rules affect buffers displayed with `pop-to-buffer' and `display-buffer'\n(or their siblings). Buffers displayed with `switch-to-buffer' (and its\nvariants) will not be affected by these rules (as they are unaffected by\n`display-buffer-alist', which powers the popup management system).\n\nPREDICATE accepts anything that the CONDITION argument in `buffer-match-p' takes\n(if you're on Emacs 29 or newer). On Emacs 28 or older, it can either be a) a\nregexp string (matched against the buffer's name) or b) a function that takes\ntwo arguments (a buffer name and the ACTION argument of `display-buffer') and\nreturns a boolean.\n\nPLIST can be made up of any of the following properties:\n\n:ignore BOOL\n  If BOOL is non-nil, popups matching PREDICATE will not be handled by the popup\n  system. Use this for buffers that have their own window management system like\n  magit or helm.\n\n:actions ACTIONS\n  ACTIONS is a list of functions or an alist containing (FUNCTION . ALIST). See\n  `display-buffer''s second argument for more information on its format and what\n  it accepts. If omitted, `+popup-default-display-buffer-actions' is used.\n\n:side 'bottom|'top|'left|'right\n  Which side of the frame to open the popup on. This is only respected if\n  `+popup-display-buffer-stacked-side-window-fn' or `display-buffer-in-side-window'\n  is in :actions or `+popup-default-display-buffer-actions'.\n\n:size/:width/:height FLOAT|INT|FN\n  Determines the size of the popup. If more than one of these size properties are\n  given :size always takes precedence, and is mapped with window-width or\n  window-height depending on what :side the popup is opened. Setting a height\n  for a popup that opens on the left or right is harmless, but comes into play\n  if two popups occupy the same :vslot.\n\n  If a FLOAT (0 < x < 1), the number represents how much of the window will be\n    consumed by the popup (a percentage).\n  If an INT, the number determines the size in lines (height) or units of\n    character width (width).\n  If a function, it takes one argument: the popup window, and can do whatever it\n    wants with it, typically resize it, like `+popup-shrink-to-fit'.\n\n:slot/:vslot INT\n  (This only applies to popups with a :side and only if :actions is blank or\n  contains the `+popup-display-buffer-stacked-side-window-fn' action) These control\n  how multiple popups are laid out. INT can be any integer, positive and\n  negative.\n\n  :slot controls lateral positioning (e.g. the horizontal positioning for\n    top/bottom popups, or vertical positioning for left/right popups).\n  :vslot controls popup stacking (from the edge of the frame toward the center).\n\n  Let's assume popup A and B are opened with :side 'bottom, in that order.\n    If they possess the same :slot and :vslot, popup B will replace popup A.\n    If popup B has a higher :slot, it will open to the right of popup A.\n    If popup B has a lower :slot, it will open to the left of popup A.\n    If popup B has a higher :vslot, it will open above popup A.\n    If popup B has a lower :vslot, it will open below popup A.\n\n:ttl INT|BOOL|FN\n  Stands for time-to-live. It can be t, an integer, nil or a function. This\n  controls how (and if) the popup system will clean up after the popup.\n\n  If any non-zero integer, wait that many seconds before killing the buffer (and\n    any associated processes).\n  If 0, the buffer is immediately killed.\n  If nil, the buffer won't be killed and is left to its own devices.\n  If t, resort to the default :ttl in `+popup-defaults'. If none exists, this is\n    the same as nil.\n  If a function, it takes one argument: the target popup buffer. The popup\n    system does nothing else and ignores the function's return value.\n\n:quit FN|BOOL|'other|'current\n  Can be t, 'other, 'current, nil, or a function. This determines the behavior\n  of the ESC/C-g keys in or outside of popup windows.\n\n  If t, close the popup if ESC/C-g is pressed anywhere.\n  If 'other, close this popup if ESC/C-g is pressed outside of any popup. This\n    is great for popups you may press ESC/C-g a lot in.\n  If 'current, close the current popup if ESC/C-g is pressed from inside of the\n    popup. This makes it harder to accidentally close a popup until you really\n    want to.\n  If nil, pressing ESC/C-g will never close this popup.\n  If a function, it takes one argument: the to-be-closed popup window, and is\n    run when ESC/C-g is pressed while that popup is open. It must return one of\n    the other values to determine the fate of the popup.\n\n:select BOOL|FN\n  Can be a boolean or function. The boolean determines whether to focus the\n  popup window after it opens (non-nil) or focus the origin window (nil).\n\n  If a function, it takes two arguments: the popup window and originating window\n    (where you were before the popup opened). The popup system does nothing else\n    and ignores the function's return value.\n\n:modeline BOOL|FN|LIST\n  Can be t (show the default modeline), nil (show no modeline), a function that\n  returns a modeline format or a valid value for `mode-line-format' to be used\n  verbatim. The function takes no arguments and is run in the context of the\n  popup buffer.\n\n:autosave BOOL|FN\n  This parameter determines what to do with modified buffers when closing popup\n  windows. It accepts t, 'ignore, a function or nil.\n\n  If t, no prompts. Just save them automatically (if they're file-visiting\n    buffers). Same as 'ignore for non-file-visiting buffers.\n  If nil (the default), prompt the user what to do if the buffer is\n    file-visiting and modified.\n  If 'ignore, no prompts, no saving. Just silently kill it.\n  If a function, it is run with one argument: the popup buffer, and must return\n    non-nil to save or nil to do nothing (but no prompts).\n\n:parameters ALIST\n  An alist of custom window parameters. See `(elisp)Window Parameters'.\n\nIf any of these are omitted, defaults derived from `+popup-defaults' will be\nused.\n\n(fn PREDICATE &key IGNORE ACTIONS SIDE SIZE WIDTH HEIGHT SLOT VSLOT TTL QUIT SELECT MODELINE AUTOSAVE PARAMETERS)") (function-put 'set-popup-rule! 'lisp-indent-function 'defun)) (put 'set-popup-rule! 'doom-module '(:ui . popup)) (progn (autoload 'set-popup-rules! "~/doom-emacs/modules/ui/popup/autoload/settings.el" "Defines multiple popup rules.\n\nEvery entry in RULESETS should be a list of alists where the CAR is the\npredicate and CDR is a plist. See `set-popup-rule!' for details on the predicate\nand plist.\n\nExample:\n\n  (set-popup-rules!\n    '((\"^ \\*\" :slot 1 :vslot -1 :size #'+popup-shrink-to-fit)\n      (\"^\\*\"  :slot 1 :vslot -1 :select t))\n    '((\"^\\*Completions\" :slot -1 :vslot -2 :ttl 0)\n      (\"^\\*Compil\\(?:ation\\|e-Log\\)\" :size 0.3 :ttl 0 :quit t)))\n\n(fn &rest RULESETS)") (function-put 'set-popup-rules! 'lisp-indent-function 0)) (put 'set-popup-rules! 'doom-module '(:ui . popup))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/vc-gutter/autoload/diff-hl.el") (load-true-file-name load-file-name)) (defalias '+vc-gutter/stage-hunk #'diff-hl-stage-current-hunk) (defalias '+vc-gutter/next-hunk #'diff-hl-next-hunk) (defalias '+vc-gutter/previous-hunk #'diff-hl-previous-hunk) (autoload '+vc-gutter/revert-hunk "~/doom-emacs/modules/ui/vc-gutter/autoload/diff-hl" "Invoke `diff-hl-revert-hunk'.\n\n(fn &optional NO-PROMPT)" t) (autoload '+vc-gutter/save-and-revert-hunk "~/doom-emacs/modules/ui/vc-gutter/autoload/diff-hl" "Invoke `diff-hl-revert-hunk' with `vc-suppress-confirm' set." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/vi-tilde-fringe/autoload.el") (load-true-file-name load-file-name)) (add-hook! '(prog-mode-hook text-mode-hook conf-mode-hook) #'vi-tilde-fringe-mode)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/workspaces/autoload/evil.el") (load-true-file-name load-file-name)) (autoload '+workspace:save "~/doom-emacs/modules/ui/workspaces/autoload/evil" nil t) (autoload '+workspace:load "~/doom-emacs/modules/ui/workspaces/autoload/evil" nil t) (autoload '+workspace:new "~/doom-emacs/modules/ui/workspaces/autoload/evil" nil t) (autoload '+workspace:rename "~/doom-emacs/modules/ui/workspaces/autoload/evil" nil t) (autoload '+workspace:delete "~/doom-emacs/modules/ui/workspaces/autoload/evil" nil t) (autoload '+workspace:switch-next "~/doom-emacs/modules/ui/workspaces/autoload/evil" nil t) (autoload '+workspace:switch-previous "~/doom-emacs/modules/ui/workspaces/autoload/evil" nil t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/workspaces/autoload/workspaces.el") (load-true-file-name load-file-name)) (defface +workspace-tab-selected-face '((t (:inherit highlight))) "The face for selected tabs displayed by `+workspace/display'" :group 'persp-mode) (defface +workspace-tab-face '((t (:inherit default))) "The face for selected tabs displayed by `+workspace/display'" :group 'persp-mode) (defalias #'+workspace-p #'perspective-p "Return t if OBJ is a perspective hash table.") (autoload '+workspace-exists-p "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Returns t if NAME is the name of an existing workspace.\n\n(fn NAME)") (defalias #'+workspace-contains-buffer-p #'persp-contain-buffer-p "Return non-nil if BUFFER is in WORKSPACE (defaults to current workspace).") (defalias #'+workspace-current #'get-current-persp "Return the currently active workspace.") (autoload '+workspace-get "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Return a workspace named NAME. Unless NOERROR is non-nil, this throws an\nerror if NAME doesn't exist.\n\n(fn NAME &optional NOERROR)") (autoload '+workspace-current-name "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Get the name of the current workspace.") (autoload '+workspace-list-names "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Return the list of names of open workspaces.") (autoload '+workspace-list "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Return a list of workspace structs (satisifes `+workspace-p').") (autoload '+workspace-buffer-list "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Return a list of buffers in PERSP.\n\nPERSP can be a string (name of a workspace) or a workspace (satisfies\n`+workspace-p'). If nil or omitted, it defaults to the current workspace.\n\n(fn &optional PERSP)") (autoload '+workspace-orphaned-buffer-list "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Return a list of buffers that aren't associated with any perspective.") (autoload '+workspace-load "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Loads a single workspace (named NAME) into the current session. Can only\nretrieve perspectives that were explicitly saved with `+workspace-save'.\n\nReturns t if successful, nil otherwise.\n\n(fn NAME)") (autoload '+workspace-save "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Saves a single workspace (NAME) from the current session. Can be loaded again\nwith `+workspace-load'. NAME can be the string name of a workspace or its\nperspective hash table.\n\nReturns t on success, nil otherwise.\n\n(fn NAME)") (autoload '+workspace-delete "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Delete WORKSPACE from the saved workspaces in `persp-save-dir'.\n\nReturn t if WORKSPACE was successfully deleted. Throws error if WORKSPACE is not\nfound or wasn't saved with `+workspace-save'.\n\n(fn WORKSPACE)") (autoload '+workspace-new "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Create a new workspace named NAME. If one already exists, return nil.\nOtherwise return t on success, nil otherwise.\n\n(fn NAME)") (autoload '+workspace-rename "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Rename the current workspace named NAME to NEW-NAME. Returns old name on\nsuccess, nil otherwise.\n\n(fn NAME NEW-NAME)") (autoload '+workspace-kill "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Kill the workspace denoted by WORKSPACE, which can be the name of a\nperspective or its hash table. If INHIBIT-KILL-P is non-nil, don't kill this\nworkspace's buffers.\n\n(fn WORKSPACE &optional INHIBIT-KILL-P)") (autoload '+workspace-switch "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Switch to another workspace named NAME (a string).\n\nIf AUTO-CREATE-P is non-nil, create the workspace if it doesn't exist, otherwise\nthrows an error.\n\n(fn NAME &optional AUTO-CREATE-P)") (defalias '+workspace/restore-last-session #'doom/quickload-session) (autoload '+workspace/load "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Load a workspace and switch to it. If called with C-u, try to reload the\ncurrent workspace (by name) from session files.\n\n(fn NAME)" t) (autoload '+workspace/save "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Save the current workspace. If called with C-u, autosave the current\nworkspace.\n\n(fn NAME)" t) (autoload '+workspace/rename "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Rename the current workspace.\n\n(fn NEW-NAME)" t) (autoload '+workspace/kill "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Delete this workspace. If called with C-u, prompts you for the name of the\nworkspace to delete.\n\n(fn NAME)" t) (autoload '+workspace/delete "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Delete a saved workspace in `persp-save-dir'.\n\nCan only selete workspaces saved with `+workspace/save' or `+workspace-save'.\n\n(fn NAME)" t) (autoload '+workspace/kill-session "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Delete the current session, all workspaces, windows and their buffers.\n\n(fn &optional INTERACTIVE)" t) (autoload '+workspace/kill-session-and-quit "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Kill emacs without saving anything." t) (autoload '+workspace/new "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Create a new workspace named NAME. If CLONE-P is non-nil, clone the current\nworkspace, otherwise the new workspace is blank.\n\n(fn &optional NAME CLONE-P)" t) (autoload '+workspace/new-named "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Create a new workspace with a given NAME.\n\n(fn NAME)" t) (autoload '+workspace/switch-to "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Switch to a workspace at a given INDEX. A negative number will start from the\nend of the workspace list.\n\n(fn INDEX)" t) (dotimes (i 9) (defalias (intern (format "+workspace/switch-to-%d" i)) (lambda nil (interactive) (+workspace/switch-to i)) (format "Switch to workspace #%d" (1+ i)))) (autoload '+workspace/switch-to-final "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Switch to the final workspace in open workspaces." t) (autoload '+workspace/other "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Switch to the last activated workspace." t) (autoload '+workspace/cycle "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Cycle n workspaces to the right (default) or left.\n\n(fn N)" t) (autoload '+workspace/switch-left "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "\n\n(fn &optional N)" t) (autoload '+workspace/switch-right "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "\n\n(fn &optional N)" t) (autoload '+workspace/close-window-or-workspace "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Close the selected window. If it's the last window in the workspace, either\nclose the workspace (as well as its associated frame, if one exists) and move to\nthe next." t) (autoload '+workspace/swap-left "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Swap the current workspace with the COUNTth workspace on its left.\n\n(fn &optional COUNT)" t) (autoload '+workspace/swap-right "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Swap the current workspace with the COUNTth workspace on its right.\n\n(fn &optional COUNT)" t) (autoload '+workspace-message "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Show an 'elegant' message in the echo area next to a listing of workspaces.\n\n(fn MESSAGE &optional TYPE)") (autoload '+workspace-error "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Show an 'elegant' error in the echo area next to a listing of workspaces.\n\n(fn MESSAGE &optional NOERROR)") (autoload '+workspace/display "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Display a list of workspaces (like tabs) in the echo area." t) (autoload '+workspaces-delete-associated-workspace-h "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Delete workspace associated with current frame.\nA workspace gets associated with a frame when a new frame is interactively\ncreated.\n\n(fn &optional FRAME)") (autoload '+workspaces-associate-frame-fn "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Create a blank, new perspective and associate it with FRAME.\n\n(fn FRAME &optional NEW-FRAME-P)") (autoload '+workspaces-switch-to-project-h "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Creates a workspace dedicated to a new project. If one already exists, switch\nto it. If in the main workspace and it's empty, recycle that workspace, without\nrenaming it.\n\nAfterwords, runs `+workspaces-switch-project-function'. By default, this prompts\nthe user to open a file in the new project.\n\nThis be hooked to `projectile-after-switch-project-hook'.\n\n(fn &optional DIR)") (autoload '+workspaces-save-tab-bar-data-h "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Save the current workspace's tab bar data.\n\n(fn _)") (autoload '+workspaces-save-tab-bar-data-to-file-h "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Save the current workspace's tab bar data to file.\n\n(fn &rest _)") (autoload '+workspaces-load-tab-bar-data-h "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Restores the tab bar data of the workspace we have just switched to.\n\n(fn _)") (autoload '+workspaces-load-tab-bar-data-from-file-h "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Restores the tab bar data from file.\n\n(fn &rest _)") (autoload '+workspaces-autosave-real-buffers-a "~/doom-emacs/modules/ui/workspaces/autoload/workspaces" "Don't autosave if no real buffers are open.\n\n(fn FN &rest ARGS)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/evil/autoload/advice.el") (load-true-file-name load-file-name)) (autoload '+evil-escape-a "~/doom-emacs/modules/editor/evil/autoload/advice" "Call `doom/escape' if `evil-force-normal-state' is called interactively.\n\n(fn &rest _)") (autoload '+evil-replace-filename-modifiers-a "~/doom-emacs/modules/editor/evil/autoload/advice" "Take a path and resolve any vim-like filename modifiers in it. This adds\nsupport for most vim file modifiers, as well as:\n\n  %:P   Resolves to `doom-project-root'.\n\nSee http://vimdoc.sourceforge.net/htmldoc/cmdline.html#filename-modifiers for\nmore information on modifiers.\n\n(fn FILE-NAME)") (autoload '+evil--insert-newline-below-and-respect-comments-a "~/doom-emacs/modules/editor/evil/autoload/advice" "\n\n(fn FN COUNT)") (autoload '+evil--insert-newline-above-and-respect-comments-a "~/doom-emacs/modules/editor/evil/autoload/advice" "\n\n(fn FN COUNT)") (autoload '+evil-window-split-a "~/doom-emacs/modules/editor/evil/autoload/advice" nil t) (autoload '+evil-window-vsplit-a "~/doom-emacs/modules/editor/evil/autoload/advice" nil t) (autoload '+evil-join-a "~/doom-emacs/modules/editor/evil/autoload/advice" nil nil) (autoload '+evil--fix-dabbrev-in-minibuffer-h "~/doom-emacs/modules/editor/evil/autoload/advice" "Make `try-expand-dabbrev' from `hippie-expand' work in minibuffer. See\n`he-dabbrev-beg', so we need to redefine syntax for '/'.")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/evil/autoload/embrace.el") (load-true-file-name load-file-name)) (autoload '+evil--embrace-get-pair "~/doom-emacs/modules/editor/evil/autoload/embrace" "\n\n(fn CHAR)") (autoload '+evil--embrace-escaped "~/doom-emacs/modules/editor/evil/autoload/embrace" "Backslash-escaped surround character support for embrace.") (autoload '+evil--embrace-latex "~/doom-emacs/modules/editor/evil/autoload/embrace" "LaTeX command support for embrace.") (autoload '+evil--embrace-elisp-fn "~/doom-emacs/modules/editor/evil/autoload/embrace" "Elisp function support for embrace.") (autoload '+evil--embrace-angle-brackets "~/doom-emacs/modules/editor/evil/autoload/embrace" "Type/generic angle brackets.")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/evil/autoload/evil.el") (load-true-file-name load-file-name)) (autoload '+evil/shift-right "~/doom-emacs/modules/editor/evil/autoload/evil" "vnoremap < <gv" t) (autoload '+evil/shift-left "~/doom-emacs/modules/editor/evil/autoload/evil" "vnoremap > >gv" t) (autoload '+evil/alt-paste "~/doom-emacs/modules/editor/evil/autoload/evil" "Call `evil-paste-after' but invert `evil-kill-on-visual-paste'.\nBy default, this replaces the selection with what's in the clipboard without\nreplacing its contents." t) (autoload '+evil/window-move-left "~/doom-emacs/modules/editor/evil/autoload/evil" "Swap windows to the left.\n\n(fn &optional ARG)" t) (autoload '+evil/window-move-right "~/doom-emacs/modules/editor/evil/autoload/evil" "Swap windows to the right\n\n(fn &optional ARG)" t) (autoload '+evil/window-move-up "~/doom-emacs/modules/editor/evil/autoload/evil" "Swap windows upward.\n\n(fn &optional ARG)" t) (autoload '+evil/window-move-down "~/doom-emacs/modules/editor/evil/autoload/evil" "Swap windows downward.\n\n(fn &optional ARG)" t) (autoload '+evil/window-split-and-follow "~/doom-emacs/modules/editor/evil/autoload/evil" "Split current window horizontally, then focus new window.\nIf `evil-split-window-below' is non-nil, the new window isn't focused." t) (autoload '+evil/window-vsplit-and-follow "~/doom-emacs/modules/editor/evil/autoload/evil" "Split current window vertically, then focus new window.\nIf `evil-vsplit-window-right' is non-nil, the new window isn't focused." t) (autoload '+evil:apply-macro "~/doom-emacs/modules/editor/evil/autoload/evil" nil t) (autoload '+evil:retab "~/doom-emacs/modules/editor/evil/autoload/evil" nil t) (autoload '+evil:narrow-buffer "~/doom-emacs/modules/editor/evil/autoload/evil" nil t) (autoload '+evil:yank-unindented "~/doom-emacs/modules/editor/evil/autoload/evil" nil t) (autoload '+evil-delete "~/doom-emacs/modules/editor/evil/autoload/evil" nil t) (progn (autoload 'set-evil-initial-state! "~/doom-emacs/modules/editor/evil/autoload/evil.el" "Set the initialize STATE of MODES using `evil-set-initial-state'.\n\n(fn MODES STATE)") (function-put 'set-evil-initial-state! 'lisp-indent-function 'defun)) (put 'set-evil-initial-state! 'doom-module '(:editor . evil))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/evil/autoload/ex.el") (load-true-file-name load-file-name)) (autoload '+evil-ex-regexp-match "~/doom-emacs/modules/editor/evil/autoload/ex" "\n\n(fn FLAG &optional ARG INVERT)") (autoload '+evil:align "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:align-right "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:open-scratch-buffer "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:pwd "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:make "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:compile "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:reverse-lines "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:cd "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:kill-all-buffers "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:kill-matching-buffers "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:help "~/doom-emacs/modules/editor/evil/autoload/ex" nil t) (autoload '+evil:read "~/doom-emacs/modules/editor/evil/autoload/ex" nil t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/evil/autoload/files.el") (load-true-file-name load-file-name)) (autoload '+evil:delete-this-file "~/doom-emacs/modules/editor/evil/autoload/files" nil t) (autoload '+evil:move-this-file "~/doom-emacs/modules/editor/evil/autoload/files" nil t) (autoload '+evil:copy-this-file "~/doom-emacs/modules/editor/evil/autoload/files" nil t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/evil/autoload/textobjects.el") (load-true-file-name load-file-name)) (autoload '+evil:whole-buffer-txtobj "~/doom-emacs/modules/editor/evil/autoload/textobjects" nil nil) (autoload '+evil:defun-txtobj "~/doom-emacs/modules/editor/evil/autoload/textobjects" nil nil) (autoload '+evil:inner-url-txtobj "~/doom-emacs/modules/editor/evil/autoload/textobjects" nil nil) (autoload '+evil:outer-url-txtobj "~/doom-emacs/modules/editor/evil/autoload/textobjects" nil nil) (autoload '+evil:inner-any-quote "~/doom-emacs/modules/editor/evil/autoload/textobjects" nil nil) (autoload '+evil:outer-any-quote "~/doom-emacs/modules/editor/evil/autoload/textobjects" nil nil)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/evil/autoload/unimpaired.el") (load-true-file-name load-file-name)) (autoload '+evil/next-beginning-of-method "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Jump to the beginning of the COUNT-th method/function after point.\n\n(fn COUNT)" t) (autoload '+evil/previous-beginning-of-method "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Jump to the beginning of the COUNT-th method/function before point.\n\n(fn COUNT)" t) (defalias #'+evil/next-end-of-method #'end-of-defun "Jump to the end of the COUNT-th method/function after point.") (autoload '+evil/previous-end-of-method "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Jump to the end of the COUNT-th method/function before point.\n\n(fn COUNT)" t) (autoload '+evil/next-preproc-directive "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Jump to the COUNT-th preprocessor directive after point.\n\nBy default, this only recognizes C preproc directives. To change this see\n`+evil-preprocessor-regexp'.\n\n(fn COUNT)" t) (autoload '+evil/previous-preproc-directive "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Jump to the COUNT-th preprocessor directive before point.\n\nSee `+evil/next-preproc-directive' for details.\n\n(fn COUNT)" t) (autoload '+evil/next-comment "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Jump to the beginning of the COUNT-th commented region after point.\n\n(fn COUNT)" t) (autoload '+evil/previous-comment "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Jump to the beginning of the COUNT-th commented region before point.\n\n(fn COUNT)" t) (autoload '+evil/insert-newline-below "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Insert COUNT blank line(s) below current line. Does not change modes.\n\n(fn COUNT)" t) (autoload '+evil/insert-newline-above "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Insert COUNT blank line(s) above current line. Does not change modes.\n\n(fn COUNT)" t) (autoload '+evil/next-frame "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Focus next frame.\n\n(fn COUNT)" t) (autoload '+evil/previous-frame "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Focus previous frame.\n\n(fn COUNT)" t) (autoload '+evil/next-file "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Open file following this one, alphabetically, in the same directory.\n\n(fn COUNT)" t) (autoload '+evil/previous-file "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Open file preceding this one, alphabetically, in the same directory.\n\n(fn COUNT)" t) (autoload '+evil:url-encode "~/doom-emacs/modules/editor/evil/autoload/unimpaired" nil t) (autoload '+evil:url-decode "~/doom-emacs/modules/editor/evil/autoload/unimpaired" nil t) (autoload '+evil:c-string-encode "~/doom-emacs/modules/editor/evil/autoload/unimpaired" nil t) (autoload '+evil:c-string-decode "~/doom-emacs/modules/editor/evil/autoload/unimpaired" nil t) (autoload '+evil/reselect-paste "~/doom-emacs/modules/editor/evil/autoload/unimpaired" "Return to visual mode and reselect the last pasted region." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/file-templates/autoload.el") (load-true-file-name load-file-name)) (autoload '+file-templates--expand "~/doom-emacs/modules/editor/file-templates/autoload" "Auto insert a yasnippet snippet into current file and enter insert mode (if\nevil is loaded and enabled).\n\n(fn PRED &key PROJECT MODE TRIGGER IGNORE WHEN)") (autoload '+file-templates-get-short-path "~/doom-emacs/modules/editor/file-templates/autoload" "Fetches a short file path for the header in Doom module templates.") (autoload '+file-templates-module-for-path "~/doom-emacs/modules/editor/file-templates/autoload" "Generate a title for a doom module's readme at PATH.\n\n(fn &optional PATH)") (autoload '+file-templates/insert-license "~/doom-emacs/modules/editor/file-templates/autoload" "Insert a license file template into the current file." t) (autoload '+file-templates/debug "~/doom-emacs/modules/editor/file-templates/autoload" "Tests the current buffer and outputs the file template rule most appropriate\nfor it. This is used for testing." t) (progn (autoload 'set-file-template! "~/doom-emacs/modules/editor/file-templates/autoload.el" "Register a file template.\n\nPRED can either be a regexp string or a major mode symbol. PLIST may contain\nthese properties:\n\n  :when FUNCTION\n    Provides a secondary predicate. This function takes the filename as an\n    argument and is executed from within the target buffer. If it returns nil,\n    this rule will be skipped over.\n  :trigger STRING|FUNCTION\n    If a string, this is the yasnippet trigger keyword used to trigger the\n      target snippet.\n    If a function, this function will be run in the context of the buffer to\n      insert a file template into. It is given no arguments and must insert text\n      into the current buffer manually.\n    If omitted, `+file-templates-default-trigger' is used.\n  :mode SYMBOL\n    What mode to get the yasnippet snippet from. If omitted, either PRED (if\n    it's a major-mode symbol) or the mode of the buffer is used.\n  :project BOOL\n    If non-nil, ignore this template if this buffer isn't in a project.\n  :ignore BOOL\n    If non-nil, don't expand any template for this file and don't test any other\n    file template rule against this buffer.\n\n(fn PRED &key WHEN TRIGGER MODE PROJECT IGNORE)") (function-put 'set-file-template! 'lisp-indent-function 'defun)) (put 'set-file-template! 'doom-module '(:editor . file-templates)) (autoload 'set-file-templates! "~/doom-emacs/modules/editor/file-templates/autoload.el" "Like `set-file-template!', but can register multiple file templates at once.\n\n(fn &rest (PRED &key WHEN TRIGGER MODE PROJECT IGNORE))") (put 'set-file-templates! 'doom-module '(:editor . file-templates))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/fold/autoload/fold.el") (load-true-file-name load-file-name)) (autoload '+fold--ensure-hideshow-mode "~/doom-emacs/modules/editor/fold/autoload/fold" "Enable `hs-minor-mode' if not already enabled.\n\nReturn non-nil if successful in doing so.") (autoload '+fold/toggle "~/doom-emacs/modules/editor/fold/autoload/fold" "Toggle the fold at point.\n\nTargets `vimmish-fold', `hideshow', `ts-fold' and `outline' folds." t) (autoload '+fold/open-rec "~/doom-emacs/modules/editor/fold/autoload/fold" "Recursively open the folded region at point.\n\nTargets `vimmish-fold', `hideshow', `ts-fold' and `outline' folds." t) (autoload '+fold/open "~/doom-emacs/modules/editor/fold/autoload/fold" "Open the folded region at point.\n\nTargets `vimmish-fold', `hideshow', `ts-fold' and `outline' folds." t) (autoload '+fold/close "~/doom-emacs/modules/editor/fold/autoload/fold" "Close the folded region at point.\n\nTargets `vimmish-fold', `hideshow', `ts-fold' and `outline' folds." t) (autoload '+fold/open-all "~/doom-emacs/modules/editor/fold/autoload/fold" "Open folds at LEVEL (or all folds if LEVEL is nil).\n\n(fn &optional LEVEL)" t) (autoload '+fold/close-all "~/doom-emacs/modules/editor/fold/autoload/fold" "Close folds at LEVEL (or all folds if LEVEL is nil).\n\n(fn &optional LEVEL)" t) (autoload '+fold/next "~/doom-emacs/modules/editor/fold/autoload/fold" "Jump to the next vimish fold, folded outline heading or folded\nregion.\n\n(fn COUNT)" t) (autoload '+fold/previous "~/doom-emacs/modules/editor/fold/autoload/fold" "Jump to the previous vimish fold, outline heading or folded region.\n\n(fn COUNT)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/fold/autoload/hideshow.el") (load-true-file-name load-file-name)) (autoload '+fold-hideshow-haml-forward-sexp-fn "~/doom-emacs/modules/editor/fold/autoload/hideshow" "\n\n(fn ARG)") (autoload '+fold-hideshow-forward-block-by-indent-fn "~/doom-emacs/modules/editor/fold/autoload/hideshow" "\n\n(fn ARG)") (autoload '+fold-hideshow-set-up-overlay-fn "~/doom-emacs/modules/editor/fold/autoload/hideshow" "\n\n(fn OV)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/snippets/autoload/settings.el") (load-true-file-name load-file-name)) (autoload 'set-yas-minor-mode! "~/doom-emacs/modules/editor/snippets/autoload/settings.el" "Register minor MODES (one mode symbol or a list of them) with yasnippet so it\ncan have its own snippets category, if the folder exists.\n\n(fn MODES)") (put 'set-yas-minor-mode! 'doom-module '(:editor . snippets))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/snippets/autoload/snippets.el") (load-true-file-name load-file-name)) (autoload '+snippets-prompt-private "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Prioritize private snippets over built-in ones if there are multiple\nchoices.\n\nThere are two groups of snippets in Doom Emacs. The built in ones (under\n`doom-emacs-dir'; provided by Doom or its plugins) or your private snippets\n(outside of `doom-eamcs-dir').\n\nIf there are multiple snippets with the same key in either camp (but not both),\nyou will be prompted to select one.\n\nIf there are conflicting keys across the two camps, the built-in ones are\nignored. This makes it easy to override built-in snippets with private ones.\n\n(fn PROMPT CHOICES &optional DISPLAY-FN)") (autoload '+snippets/goto-start-of-field "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Go to the beginning of the current field." t) (autoload '+snippets/goto-end-of-field "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Go to the end of the current field." t) (autoload '+snippets/delete-backward-char "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Prevents Yas from interfering with backspace deletion.\n\n(fn &optional FIELD)" t) (autoload '+snippets/delete-forward-char-or-field "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Delete forward, or skip the current field if it's empty. This is to prevent\nbuggy behavior when <delete> is pressed in an empty field.\n\n(fn &optional FIELD)" t) (autoload '+snippets/delete-to-start-of-field "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Delete to start-of-field.\n\n(fn &optional FIELD)" t) (autoload '+snippets/find "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Open a snippet file (in all of `yas-snippet-dirs')." t) (autoload '+snippets/find-private "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Open a private snippet file in `+snippets-dir'." t) (autoload '+snippets/find-for-current-mode "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Open a snippet for this mode.\n\n(fn TEMPLATE-UUID)" t) (autoload '+snippets/new "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Create a new snippet in `+snippets-dir'.\n\nIf there are extra yasnippet modes active, or if ALL-MODES is non-nil, you will\nbe prompted for the mode for which to create the snippet.\n\n(fn &optional ALL-MODES)" t) (autoload '+snippets/new-alias "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Create an alias for a snippet with uuid TEMPLATE-UUID.\n\nYou will be prompted for a snippet to alias.\n\n(fn TEMPLATE-UUID)" t) (autoload '+snippets/edit "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Edit a snippet with uuid TEMPLATE-UUID.\n\nIf the snippet isn't in `+snippets-dir', it will be copied there (where it will\nshadow the default snippet).\n\n(fn TEMPLATE-UUID)" t) (autoload '+snippets-show-hints-in-header-line-h "~/doom-emacs/modules/editor/snippets/autoload/snippets") (autoload '+snippets-enable-project-modes-h "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Automatically enable snippet libraries for project minor modes defined with\n`def-project-mode!'.\n\n(fn MODE &rest _)") (autoload '+snippets-read-only-maybe-h "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Enable `read-only-mode' if snippet is built-in.") (autoload '+snippets-expand-on-region-a "~/doom-emacs/modules/editor/snippets/autoload/snippets" "Fix off-by-one when expanding snippets on an evil visual region.\n\nAlso strips whitespace out of selection. Also switches to insert mode. If\n`evil-local-mode' isn't enabled, or we're not in visual mode, run FN as is.\n\n(fn FN &optional NO-CONDITION)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/dired/autoload.el") (load-true-file-name load-file-name)) (autoload '+dired/quit-all "~/doom-emacs/modules/emacs/dired/autoload" "Kill all `dired-mode' buffers." t) (autoload '+dired-enable-git-info-h "~/doom-emacs/modules/emacs/dired/autoload" "Enable `dired-git-info-mode' in git repos.") (autoload '+dired/dirvish-side-and-follow "~/doom-emacs/modules/emacs/dired/autoload" "Open `dirvish-side' then find the currently focused file.\n\nIf dirvish is already open, remotely jump to the file in Dirvish.\nIf given the prefix ARG, then prompt for a directory (replaces existing Dirvish\nsidebars).\n\n(fn &optional ARG)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/electric/autoload.el") (load-true-file-name load-file-name)) (progn (autoload 'set-electric! "~/doom-emacs/modules/emacs/electric/autoload.el" "Declare that WORDS (list of strings) or CHARS (lists of chars) should trigger\nelectric indentation.\n\nEnables `electric-indent-local-mode' in MODES.\n\n(fn MODES &key WORDS CHARS)") (function-put 'set-electric! 'lisp-indent-function 'defun)) (put 'set-electric! 'doom-module '(:emacs . electric))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/vc/autoload/vc.el") (load-true-file-name load-file-name)) (autoload 'browse-at-remote--format-region-url-as-codeberg "~/doom-emacs/modules/emacs/vc/autoload/vc" "URL formatted for codeberg.\n\n(fn REPO-URL LOCATION FILENAME &optional LINESTART LINEEND)") (autoload 'browse-at-remote--format-commit-url-as-codeberg "~/doom-emacs/modules/emacs/vc/autoload/vc" "Commit URL formatted for codeberg\n\n(fn REPO-URL COMMITHASH)") (autoload '+vc/browse-at-remote "~/doom-emacs/modules/emacs/vc/autoload/vc" "Open URL to current file (and line if selection is active) in browser.\nIf prefix ARG, negate the default value of `browse-at-remote-prefer-symbolic'.\n\n(fn &optional ARG)" t) (autoload '+vc/browse-at-remote-kill "~/doom-emacs/modules/emacs/vc/autoload/vc" "Copy URL to current file (and line if selection is active) to clipboard.\nIf prefix ARG, negate the default value of `browse-at-remote-prefer-symbolic'.\n\n(fn &optional ARG INTERACTIVE?)" t) (autoload '+vc/browse-at-remote-homepage "~/doom-emacs/modules/emacs/vc/autoload/vc" "Open homepage for current project in browser." t) (autoload '+vc/browse-at-remote-kill-homepage "~/doom-emacs/modules/emacs/vc/autoload/vc" "Copy homepage URL of current project to clipboard." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/checkers/syntax/autoload.el") (load-true-file-name load-file-name)) (autoload '+syntax-init-popups-h "~/doom-emacs/modules/checkers/syntax/autoload" "Activate `flycheck-posframe-mode' if available and in GUI Emacs.\nActivate `flycheck-popup-tip-mode' otherwise.\nDo nothing if `lsp-ui-mode' is active and `lsp-ui-sideline-enable' is non-nil.") (autoload 'set-next-checker! "~/doom-emacs/modules/checkers/syntax/autoload.el" "TODO\n\n(fn MODE CHECKER NEXT &optional APPEND)") (put 'set-next-checker! 'doom-module '(:checkers . syntax))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/eval/autoload/eval.el") (load-true-file-name load-file-name)) (autoload '+eval-display-results-in-popup "~/doom-emacs/modules/tools/eval/autoload/eval" "Display OUTPUT in a popup buffer.\n\n(fn OUTPUT &optional SOURCE-BUFFER)") (autoload '+eval-display-results-in-overlay "~/doom-emacs/modules/tools/eval/autoload/eval" "Display OUTPUT in a floating overlay next to the cursor.\n\n(fn OUTPUT &optional SOURCE-BUFFER)") (autoload '+eval-display-results "~/doom-emacs/modules/tools/eval/autoload/eval" "Display OUTPUT in an overlay or a popup buffer.\n\n(fn OUTPUT &optional SOURCE-BUFFER)") (autoload '+eval-region-as-major-mode "~/doom-emacs/modules/tools/eval/autoload/eval" "Evaluate a region between BEG and END and display the output.\n\nEvaluate as in RUNNER-MAJOR-MODE. If RUNNER-MAJOR-MODE is nil, use major-mode\nof the buffer instead.\n\n(fn BEG END &optional RUNNER-MAJOR-MODE)") (autoload '+eval/buffer "~/doom-emacs/modules/tools/eval/autoload/eval" "Evaluate the whole buffer." t) (autoload '+eval/region "~/doom-emacs/modules/tools/eval/autoload/eval" "Evaluate a region between BEG and END and display the output.\n\n(fn BEG END)" t) (autoload '+eval/line-or-region "~/doom-emacs/modules/tools/eval/autoload/eval" "Evaluate the current line or selected region." t) (autoload '+eval/buffer-or-region "~/doom-emacs/modules/tools/eval/autoload/eval" "Evaluate the region if it's active, otherwise evaluate the whole buffer.\n\nIf a REPL is open the code will be evaluated in it, otherwise a quickrun\nrunner will be used." t) (autoload '+eval/region-and-replace "~/doom-emacs/modules/tools/eval/autoload/eval" "Evaluation a region between BEG and END, and replace it with the result.\n\n(fn BEG END)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/eval/autoload/evil.el") (load-true-file-name load-file-name)) (autoload '+eval:region "~/doom-emacs/modules/tools/eval/autoload/evil" nil t) (autoload '+eval:replace-region "~/doom-emacs/modules/tools/eval/autoload/evil" nil t) (autoload '+eval:repl "~/doom-emacs/modules/tools/eval/autoload/evil" nil t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/eval/autoload/repl.el") (load-true-file-name load-file-name)) (autoload '+eval/open-repl-same-window "~/doom-emacs/modules/tools/eval/autoload/repl" "Opens (or reopens) the REPL associated with the current major-mode and place\nthe cursor at the prompt.\n\nIf ARG (universal argument), prompt for a specific REPL to open.\n\n(fn &optional ARG)" t) (autoload '+eval/open-repl-other-window "~/doom-emacs/modules/tools/eval/autoload/repl" "Does `+eval/open-repl', but in a popup window.\n\nIf ARG (universal argument), prompt for a specific REPL to open.\n\n(fn &optional ARG)" t) (autoload '+eval/send-region-to-repl "~/doom-emacs/modules/tools/eval/autoload/repl" "Execute the selected region in the REPL.\nOpens a REPL if one isn't already open. If AUTO-EXECUTE-P, then execute it\nimmediately after.\n\n(fn BEG END &optional INHIBIT-AUTO-EXECUTE-P)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/eval/autoload/settings.el") (load-true-file-name load-file-name)) (defvar +eval-runners nil "Alist mapping major modes to interactive runner functions.") (progn (autoload 'set-repl-handler! "~/doom-emacs/modules/tools/eval/autoload/settings.el" "Defines a REPL for MODES.\n\nMODES is either a single major mode symbol or a list of them. COMMAND is a\nfunction that creates and returns the REPL buffer.\n\nCOMMAND can either be a function that takes no arguments, or an interactive\ncommand that will be called interactively. COMMANDS must return either the repl\nbuffer or a function that takes no arguments and returns the repl buffer.\n\nPLIST is a property list that map special attributes to this repl. These are\nrecognized:\n\n  :persist BOOL\n    If non-nil, this REPL won't be killed when its window is closed.\n  :send-region FUNC\n    A function that accepts a BEG and END, and sends the contents of the region\n    to the REPL. Defaults to `+eval/send-region-to-repl'.\n  :send-buffer FUNC\n    A function of no arguments that sends the contents of the buffer to the REPL.\n    Defaults to `+eval/region', which will run the :send-region specified function\n    or `+eval/send-region-to-repl'.\n\n(fn MODES COMMAND &rest PLIST)") (function-put 'set-repl-handler! 'lisp-indent-function 'defun)) (put 'set-repl-handler! 'doom-module '(:tools . eval)) (progn (autoload 'set-eval-handler! "~/doom-emacs/modules/tools/eval/autoload/settings.el" "Define a code evaluator for major mode MODES with `quickrun'.\n\nMODES can be list of major mode symbols, or a single one.\n\n1. If MODE is a string and COMMAND is the string, MODE is a file regexp and\n   COMMAND is a string key for an entry in `quickrun-file-alist'.\n2. If MODE is not a string and COMMAND is a string, MODE is a major-mode symbol\n   and COMMAND is a key (for `quickrun--language-alist'), and will be registered\n   in `quickrun--major-mode-alist'.\n3. If MODE is not a string and COMMAND is an alist, see `quickrun-add-command':\n   (quickrun-add-command MODE COMMAND :mode MODE).\n4. If MODE is not a string and COMMANd is a symbol, add it to\n   `+eval-runners', which is used by `+eval/region'.\n\n(fn MODES COMMAND)") (function-put 'set-eval-handler! 'lisp-indent-function 'defun)) (put 'set-eval-handler! 'doom-module '(:tools . eval))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lookup/autoload/docsets.el") (load-true-file-name load-file-name)) (defmacro set-docsets! (modes &rest docsets) "THIS FUNCTION DOES NOTHING BECAUSE (:tools . lookup) IS DISABLED\n\nRegisters a list of DOCSETS for MODES.\n\nMODES can be one major mode, or a list thereof.\n\nDOCSETS can be strings, each representing a dash docset, or a vector with the\nstructure [DOCSET FORM]. If FORM evaluates to nil, the DOCSET is omitted. If it\nis non-nil, (format DOCSET FORM) is used as the docset.\n\nThe first element in DOCSETS can be :add or :remove, making it easy for users to\nadd to or remove default docsets from modes.\n\nDOCSETS can also contain sublists, which will be flattened.\n\nExample:\n\n  (set-docsets! '(js2-mode rjsx-mode) \"JavaScript\"\n    [\"React\" (eq major-mode 'rjsx-mode)]\n    [\"TypeScript\" (bound-and-true-p tide-mode)])\n\nUsed by `+lookup/in-docsets' and `+lookup/documentation'." (ignore modes docsets)) (put 'set-docsets! 'doom-module '(:tools . lookup))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lookup/autoload/evil.el") (load-true-file-name load-file-name)) (autoload '+lookup:online "~/doom-emacs/modules/tools/lookup/autoload/evil" nil t) (autoload '+lookup:dash "~/doom-emacs/modules/tools/lookup/autoload/evil" nil t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lookup/autoload/lookup.el") (load-true-file-name load-file-name)) (autoload '+lookup/definition "~/doom-emacs/modules/tools/lookup/autoload/lookup" "Jump to the definition of IDENTIFIER (defaults to the symbol at point).\n\nEach function in `+lookup-definition-functions' is tried until one changes the\npoint or current buffer. Falls back to dumb-jump, naive\nripgrep/the_silver_searcher text search, then `evil-goto-definition' if\nevil-mode is active.\n\n(fn IDENTIFIER &optional ARG)" t) (autoload '+lookup/implementations "~/doom-emacs/modules/tools/lookup/autoload/lookup" "Jump to the implementations of IDENTIFIER (defaults to the symbol at point).\n\nEach function in `+lookup-implementations-functions' is tried until one changes\nthe point or current buffer.\n\n(fn IDENTIFIER &optional ARG)" t) (autoload '+lookup/type-definition "~/doom-emacs/modules/tools/lookup/autoload/lookup" "Jump to the type definition of IDENTIFIER (defaults to the symbol at point).\n\nEach function in `+lookup-type-definition-functions' is tried until one changes\nthe point or current buffer.\n\n(fn IDENTIFIER &optional ARG)" t) (autoload '+lookup/references "~/doom-emacs/modules/tools/lookup/autoload/lookup" "Show a list of usages of IDENTIFIER (defaults to the symbol at point)\n\nTries each function in `+lookup-references-functions' until one changes the\npoint and/or current buffer. Falls back to a naive ripgrep/the_silver_searcher\nsearch otherwise.\n\n(fn IDENTIFIER &optional ARG)" t) (autoload '+lookup/documentation "~/doom-emacs/modules/tools/lookup/autoload/lookup" "Show documentation for IDENTIFIER (defaults to symbol at point or selection.\n\nFirst attempts the :documentation handler specified with `set-lookup-handlers!'\nfor the current mode/buffer (if any), then falls back to the backends in\n`+lookup-documentation-functions'.\n\n(fn IDENTIFIER &optional ARG)" t) (autoload '+lookup/file "~/doom-emacs/modules/tools/lookup/autoload/lookup" "Figure out PATH from whatever is at point and open it.\n\nEach function in `+lookup-file-functions' is tried until one changes the point\nor the current buffer.\n\nOtherwise, falls back on `find-file-at-point'.\n\n(fn &optional PATH)" t) (autoload '+lookup/dictionary-definition "~/doom-emacs/modules/tools/lookup/autoload/lookup" "Look up the definition of the word at point (or selection).\n\n(fn IDENTIFIER &optional ARG)" t) (autoload '+lookup/synonyms "~/doom-emacs/modules/tools/lookup/autoload/lookup" "Look up and insert a synonym for the word at point (or selection).\n\n(fn IDENTIFIER &optional ARG)" t) (progn (autoload 'set-lookup-handlers! "~/doom-emacs/modules/tools/lookup/autoload/lookup.el" "Define jump handlers for major or minor MODES.\n\nA handler is either an interactive command that changes the current buffer\nand/or location of the cursor, or a function that takes one argument: the\nidentifier being looked up, and returns either nil (failed to find it), t\n(succeeded at changing the buffer/moving the cursor), or 'deferred (assume this\nhandler has succeeded, but expect changes not to be visible yet).\n\nThere are several kinds of handlers, which can be defined with the following\nproperties:\n\n:definition FN\n  Run when jumping to a symbol's definition. Used by `+lookup/definition'.\n:implementations FN\n  Run when looking for implementations of a symbol in the current project. Used\n  by `+lookup/implementations'.\n:type-definition FN\n  Run when jumping to a symbol's type definition. Used by\n  `+lookup/type-definition'.\n:references FN\n  Run when looking for usage references of a symbol in the current project. Used\n  by `+lookup/references'.\n:documentation FN\n  Run when looking up documentation for a symbol. Used by\n  `+lookup/documentation'.\n:file FN\n  Run when looking up the file for a symbol/string. Typically a file path. Used\n  by `+lookup/file'.\n:xref-backend FN\n  Defines an xref backend for a major-mode. A :definition and :references\n  handler isn't necessary with a :xref-backend, but will have higher precedence\n  if they exist.\n:async BOOL\n  Indicates that *all* supplied FNs are asynchronous. Note: lookups will not try\n  any handlers after async ones, due to their nature. To get around this, you\n  must write a specialized wrapper to await the async response, or use a\n  different heuristic to determine, ahead of time, whether the async call will\n  succeed or not.\n\n  If you only want to specify one FN is async, declare it inline instead:\n\n    (set-lookup-handlers! 'rust-mode\n      :definition '(racer-find-definition :async t))\n\nHandlers can either be interactive or non-interactive. Non-interactive handlers\nmust take one argument: the identifier being looked up. This function must\nchange the current buffer or window or return non-nil when it succeeds.\n\nIf it doesn't change the current buffer, or it returns nil, the lookup module\nwill fall back to the next handler in `+lookup-definition-functions',\n`+lookup-implementations-functions', `+lookup-type-definition-functions',\n`+lookup-references-functions', `+lookup-file-functions' or\n`+lookup-documentation-functions'.\n\nConsecutive `set-lookup-handlers!' calls will overwrite previously defined\nhandlers for MODES. If used on minor modes, they are stacked onto handlers\ndefined for other minor modes or the major mode it's activated in.\n\nThis can be passed nil as its second argument to unset handlers for MODES. e.g.\n\n  (set-lookup-handlers! 'python-mode nil)\n\n(fn MODES &key DEFINITION IMPLEMENTATIONS TYPE-DEFINITION REFERENCES DOCUMENTATION FILE XREF-BACKEND ASYNC)") (function-put 'set-lookup-handlers! 'lisp-indent-function 'defun)) (put 'set-lookup-handlers! 'doom-module '(:tools . lookup))) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lookup/autoload/online.el") (load-true-file-name load-file-name)) (autoload '+lookup-online-backend-fn "~/doom-emacs/modules/tools/lookup/autoload/online" "Open the browser and search for IDENTIFIER online.\nWhen called for the first time, or with a non-nil prefix argument, prompt for\nthe search engine to use.\n\n(fn IDENTIFIER)") (autoload '+lookup/online "~/doom-emacs/modules/tools/lookup/autoload/online" "Look up QUERY in the browser using PROVIDER.\nWhen called interactively, prompt for a query and, when called for the first\ntime, the provider from `+lookup-provider-url-alist'. In subsequent calls, reuse\nthe previous provider. With a non-nil prefix argument, always prompt for the\nprovider.\n\nQUERY must be a string, and PROVIDER must be a key of\n`+lookup-provider-url-alist'.\n\n(fn QUERY PROVIDER)" t) (autoload '+lookup/online-select "~/doom-emacs/modules/tools/lookup/autoload/online" "Run `+lookup/online', but always prompt for the provider to use." t) (autoload '+lookup--online-backend-google "~/doom-emacs/modules/tools/lookup/autoload/online" "Search Google, starting with QUERY, with live autocompletion.\n\n(fn QUERY)") (autoload '+lookup--online-backend-duckduckgo "~/doom-emacs/modules/tools/lookup/autoload/online" "Search DuckDuckGo, starting with QUERY, with live autocompletion.\n\n(fn QUERY)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lookup/autoload/xwidget.el") (load-true-file-name load-file-name)) (autoload '+lookup-xwidget-webkit-open-url-fn "~/doom-emacs/modules/tools/lookup/autoload/xwidget" "\n\n(fn URL &optional NEW-SESSION)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/magit/autoload.el") (load-true-file-name load-file-name)) (defadvice! +magit--ignore-version-a (fn &rest args) :around #'magit-version (let ((inhibit-message (not (called-interactively-p 'any)))) (apply fn args))) (autoload '+magit-display-buffer-fn "~/doom-emacs/modules/tools/magit/autoload" "Same as `magit-display-buffer-traditional', except...\n\n- If opened from a commit window, it will open below it.\n- Magit process windows are always opened in small windows below the current.\n- Everything else will reuse the same window.\n\n(fn BUFFER)") (autoload '+magit-mark-stale-buffers-h "~/doom-emacs/modules/tools/magit/autoload" "Revert all visible buffers and mark buried buffers as stale.\n\nStale buffers are reverted when they are switched to, assuming they haven't been\nmodified.") (autoload '+magit-revert-buffer-maybe-h "~/doom-emacs/modules/tools/magit/autoload" "Update `vc' and `diff-hl' if out of date.") (autoload '+magit/quit "~/doom-emacs/modules/tools/magit/autoload" "Bury the current magit buffer.\n\nIf KILL-BUFFER, kill this buffer instead of burying it.\nIf the buried/killed magit buffer was the last magit buffer open for this repo,\nkill all magit buffers for this repo.\n\n(fn &optional KILL-BUFFER)" t) (autoload '+magit/quit-all "~/doom-emacs/modules/tools/magit/autoload" "Kill all magit buffers for the current repository." t) (autoload '+magit/start-code-review "~/doom-emacs/modules/tools/magit/autoload" "\n\n(fn ARG)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp.el") (load-true-file-name load-file-name)) (autoload '+emacs-lisp-eval "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Evaluate a region and print it to the echo area (if one line long), otherwise\nto a pop up buffer.\n\nMeant as an eval handler for Doom's :tools eval module.\n\n(fn BEG END)") (autoload '+emacs-lisp-outline-level "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Return outline level for comment at point.\nIntended to replace `lisp-outline-level'.") (autoload '+emacs-lisp-lookup-definition "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Lookup definition of THING.\n\n(fn THING)") (autoload '+emacs-lisp-lookup-documentation "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Lookup THING with `helpful-variable' if it's a variable, `helpful-callable'\nif it's callable, `apropos' otherwise.\n\n(fn THING)") (autoload '+emacs-lisp/change-working-buffer "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Change what buffer to run `+emacs-lisp-eval' in.\n\nIf given the prefix arg (CLEAR?), clears the current working buffer.\n\n(fn BUFFER &optional CLEAR?)" t) (autoload '+emacs-lisp/open-repl "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Open the Emacs Lisp REPL (`ielm').\n\nIf the repl isn't already open, sets ielm's working buffer to the buffer\nselected before this command was invoked." t) (autoload '+emacs-lisp/buttercup-run-file "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Run all buttercup tests in the focused buffer." t) (autoload '+emacs-lisp/buttercup-run-project "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Run all buttercup tests in the project." t) (autoload '+emacs-lisp/edebug-instrument-defun-on "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Toggle on instrumentalisation for the function under `defun'." t) (autoload '+emacs-lisp/edebug-instrument-defun-off "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Toggle off instrumentalisation for the function under `defun'." t) (autoload '+emacs-lisp-init-straight-maybe-h "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Make sure straight sees modifications to installed packages.") (autoload '+emacs-lisp-extend-imenu-h "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Improve imenu support in `emacs-lisp-mode' for Doom's APIs.") (autoload '+emacs-lisp-non-package-mode "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Reduce flycheck/flymake verbosity where it is appropriate.\n\nEssentially, this means in any elisp file that either:\n- Is not a theme in `custom-theme-load-path',\n- Lacks a `provide' statement,\n- Lives in a project with a .doommodule file,\n- Is a dotfile (like .dir-locals.el or .doomrc).\n\nThis generally applies to your private config (`doom-user-dir') or Doom's source\n(`doom-emacs-dir').\n\nThis is a minor mode.  If called interactively, toggle the\n`+Emacs-Lisp-Non-Package mode' mode.  If the prefix argument is\npositive, enable the mode, and if it is zero or negative, disable the\nmode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\nif ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate the variable `+emacs-lisp-non-package-mode'.\n\nThe mode's hook is called both when the mode is enabled and when it is\ndisabled.\n\n(fn &optional ARG)" t) (autoload '+emacs-lisp-highlight-vars-and-faces "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Match defined variables and functions.\n\nFunctions are differentiated into special forms, built-in functions and\nlibrary/userland functions\n\n(fn END)") (put 'map! 'indent-plists-as-data t) (autoload '+emacs-lisp--calculate-lisp-indent-a "~/doom-emacs/modules/lang/emacs-lisp/autoload/emacs-lisp" "Add better indentation for quoted and backquoted lists.\n\nIntended as :override advice for `calculate-lisp-indent'.\n\nAdapted from URL `https://www.reddit.com/r/emacs/comments/d7x7x8/finally_fixing_indentation_of_quoted_lists/'.\n\n(fn &optional PARSE-START)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/emacs-lisp/autoload/helpful.el") (load-true-file-name load-file-name)) (autoload '+emacs-lisp-record-new-buffers-a "~/doom-emacs/modules/lang/emacs-lisp/autoload/helpful" "Update the buffer ring according to the current buffer and HELP-BUF.\n\n(fn BUF)") (autoload '+emacs-lisp/helpful-next "~/doom-emacs/modules/lang/emacs-lisp/autoload/helpful" "Go to the next Helpful buffer." t) (autoload '+emacs-lisp/helpful-previous "~/doom-emacs/modules/lang/emacs-lisp/autoload/helpful" "Go to the previous Helpful buffer." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/markdown/autoload.el") (load-true-file-name load-file-name)) (autoload '+markdown-flyspell-word-p "~/doom-emacs/modules/lang/markdown/autoload" "Return t if `flyspell' should check word before point.\n\nUsed for `flyspell-generic-check-word-predicate'. Like\n`markdown-flyspell-check-word-p', but also:\n\na) Performs spell check in code comments and\nb) Inhibits spell check in html markup") (autoload '+markdown-compile "~/doom-emacs/modules/lang/markdown/autoload" "Compile markdown into html.\n\nRuns `+markdown-compile-functions' until the first function to return non-nil,\notherwise throws an error.\n\n(fn BEG END OUTPUT-BUFFER)") (autoload '+markdown-compile-marked "~/doom-emacs/modules/lang/markdown/autoload" "Compiles markdown with the marked program, if available.\nReturns its exit code.\n\n(fn BEG END OUTPUT-BUFFER)") (autoload '+markdown-compile-pandoc "~/doom-emacs/modules/lang/markdown/autoload" "Compiles markdown with the pandoc program, if available.\nReturns its exit code.\n\n(fn BEG END OUTPUT-BUFFER)") (autoload '+markdown-compile-multimarkdown "~/doom-emacs/modules/lang/markdown/autoload" "Compiles markdown with the multimarkdown program, if available. Returns its\nexit code.\n\n(fn BEG END OUTPUT-BUFFER)") (autoload '+markdown-compile-markdown "~/doom-emacs/modules/lang/markdown/autoload" "Compiles markdown using the Markdown.pl script (or markdown executable), if\navailable. Returns its exit code.\n\n(fn BEG END OUTPUT-BUFFER)") (autoload '+markdown/insert-del "~/doom-emacs/modules/lang/markdown/autoload" "Surround region in github strike-through delimiters." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org/autoload/org-attach.el") (load-true-file-name load-file-name)) (autoload '+org-attach-icon-for "~/doom-emacs/modules/lang/org/autoload/org-attach" "\n\n(fn PATH)") (autoload '+org/open-gallery-from-attachments "~/doom-emacs/modules/lang/org/autoload/org-attach" "TODO" t) (autoload '+org/find-file-in-attachments "~/doom-emacs/modules/lang/org/autoload/org-attach" "Open a file from `org-attach-id-dir'." t) (autoload '+org/attach-file-and-insert-link "~/doom-emacs/modules/lang/org/autoload/org-attach" "Downloads the file at PATH and insert an org link at point.\nPATH (a string) can be an url, a local file path, or a base64 encoded datauri.\n\n(fn PATH)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org/autoload/org-avy.el") (load-true-file-name load-file-name)) (autoload '+org-headline-avy "~/doom-emacs/modules/lang/org/autoload/org-avy" "TODO") (autoload '+org/goto-visible "~/doom-emacs/modules/lang/org/autoload/org-avy" "TODO" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org/autoload/org-babel.el") (load-true-file-name load-file-name)) (autoload '+org-eval-handler "~/doom-emacs/modules/lang/org/autoload/org-babel" "TODO\n\n(fn BEG END)") (autoload '+org-lookup-definition-handler "~/doom-emacs/modules/lang/org/autoload/org-babel" "TODO\n\n(fn IDENTIFIER)") (autoload '+org-lookup-references-handler "~/doom-emacs/modules/lang/org/autoload/org-babel" "TODO\n\n(fn IDENTIFIER)") (autoload '+org-lookup-documentation-handler "~/doom-emacs/modules/lang/org/autoload/org-babel" "TODO\n\n(fn IDENTIFIER)") (autoload '+org/remove-result-blocks "~/doom-emacs/modules/lang/org/autoload/org-babel" "Remove all result blocks located after current point.\n\n(fn REMOVE-ALL)" t) (autoload '+org-clear-babel-results-h "~/doom-emacs/modules/lang/org/autoload/org-babel" "Remove the results block for the org babel block at point.")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org/autoload/org-capture.el") (load-true-file-name load-file-name)) (defvar +org-capture-frame-parameters `((name . "doom-capture") (width . 70) (height . 25) (transient . t) ,@(when (featurep :system 'linux) `((window-system \, (if (boundp 'pgtk-initialized) 'pgtk 'x)) (display \, (or (getenv "WAYLAND_DISPLAY") (getenv "DISPLAY") ":0")))) ,(if (featurep :system 'macos) '(menu-bar-lines . 1))) "TODO") (autoload '+org-capture-cleanup-frame-h "~/doom-emacs/modules/lang/org/autoload/org-capture" "Closes the org-capture frame once done adding an entry.") (autoload '+org-capture-frame-p "~/doom-emacs/modules/lang/org/autoload/org-capture" "Return t if the current frame is an org-capture frame opened by\n`+org-capture/open-frame'.\n\n(fn &rest _)") (autoload '+org-capture/open-frame "~/doom-emacs/modules/lang/org/autoload/org-capture" "Opens the org-capture window in a floating frame that cleans itself up once\nyou're done. This can be called from an external shell script.\n\n(fn &optional INITIAL-INPUT KEY)" t) (autoload '+org-capture-available-keys "~/doom-emacs/modules/lang/org/autoload/org-capture" "TODO") (autoload '+org-capture-todo-file "~/doom-emacs/modules/lang/org/autoload/org-capture" "Expand `+org-capture-todo-file' from `org-directory'.\nIf it is an absolute path return `+org-capture-todo-file' verbatim.") (autoload '+org-capture-notes-file "~/doom-emacs/modules/lang/org/autoload/org-capture" "Expand `+org-capture-notes-file' from `org-directory'.\nIf it is an absolute path return `+org-capture-notes-file' verbatim.") (autoload '+org-capture-project-todo-file "~/doom-emacs/modules/lang/org/autoload/org-capture" "Find the nearest `+org-capture-todo-file' in a parent directory, otherwise,\nopens a blank one at the project root. Throws an error if not in a project.") (autoload '+org-capture-project-notes-file "~/doom-emacs/modules/lang/org/autoload/org-capture" "Find the nearest `+org-capture-notes-file' in a parent directory, otherwise,\nopens a blank one at the project root. Throws an error if not in a project.") (autoload '+org-capture-project-changelog-file "~/doom-emacs/modules/lang/org/autoload/org-capture" "Find the nearest `+org-capture-changelog-file' in a parent directory,\notherwise, opens a blank one at the project root. Throws an error if not in a\nproject.") (autoload '+org-capture-central-project-todo-file "~/doom-emacs/modules/lang/org/autoload/org-capture" "TODO") (autoload '+org-capture-central-project-notes-file "~/doom-emacs/modules/lang/org/autoload/org-capture" "TODO") (autoload '+org-capture-central-project-changelog-file "~/doom-emacs/modules/lang/org/autoload/org-capture" "TODO")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org/autoload/org-export.el") (load-true-file-name load-file-name)) (autoload '+org/export-to-clipboard "~/doom-emacs/modules/lang/org/autoload/org-export" "Exports the current buffer/selection to the clipboard.\n\nPrompts for what BACKEND to use. See `org-export-backends' for options.\n\n(fn BACKEND)" t) (autoload '+org/export-to-clipboard-as-rich-text "~/doom-emacs/modules/lang/org/autoload/org-export" "Export the current buffer to HTML then copies it to clipboard as rich text.\n\nSupports org-mode, markdown-mode, and gfm-mode buffers. In any other mode,\nhtmlize is used (takes what you see in Emacs and converts it to html, text\nproperties and font-locking et all).\n\n(fn BEG END)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org/autoload/org-link.el") (load-true-file-name load-file-name)) (autoload '+org-define-basic-link "~/doom-emacs/modules/lang/org/autoload/org-link" "Define a link with some basic completion & fontification.\n\nKEY is the name of the link type. DIR-VAR is the directory variable to resolve\nlinks relative to. PLIST is passed to `org-link-set-parameters' verbatim.\n\nLinks defined with this will be rendered in the `error' face if the file doesn't\nexist, and `org-link' otherwise.\n\n(fn KEY DIR-VAR &rest PLIST)") (function-put '+org-define-basic-link 'lisp-indent-function 2) (autoload '+org-link-read-desc-at-point "~/doom-emacs/modules/lang/org/autoload/org-link" "TODO\n\n(fn &optional DEFAULT CONTEXT)") (autoload '+org-link-read-kbd-at-point "~/doom-emacs/modules/lang/org/autoload/org-link" "TODO\n\n(fn &optional DEFAULT CONTEXT)") (autoload '+org-link--var-link-activate-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "\n\n(fn START END VAR BRACKETED-P)") (autoload '+org-link--fn-link-activate-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "\n\n(fn START END FN BRACKETED-P)") (autoload '+org-link--face-link-activate-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "\n\n(fn START END FACE BRACKETED-P)") (autoload '+org-link--command-link-activate-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "\n\n(fn START END COMMAND BRACKETED-P)") (autoload '+org-link--doom-module-link-follow-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "\n\n(fn MODULE-PATH ARG)") (autoload '+org-link--doom-module-link-activate-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "\n\n(fn START END MODULE-PATH BRACKETED-P)") (autoload '+org-link--doom-package-link-activate-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "\n\n(fn START END PACKAGE BRACKETED-P)") (autoload '+org-link--doom-package-link-follow-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "TODO\n\n(fn PKG PREFIXARG)") (autoload '+org-link--doom-executable-link-activate-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "\n\n(fn START END EXECUTABLE BRACKETED-P)") (autoload '+org-image-file-data-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "Intepret LINK as an image file path and return its data.\n\n(fn PROTOCOL LINK DESCRIPTION)") (autoload '+org-inline-image-data-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "Interpret LINK as base64-encoded image data.\n\n(fn PROTOCOL LINK DESCRIPTION)") (autoload '+org-http-image-data-fn "~/doom-emacs/modules/lang/org/autoload/org-link" "Interpret LINK as an URL to an image file.\n\n(fn PROTOCOL LINK DESCRIPTION)") (autoload '+org-play-gif-at-point-h "~/doom-emacs/modules/lang/org/autoload/org-link" "Play the gif at point, while the cursor remains there (looping).") (autoload '+org-play-all-gifs-h "~/doom-emacs/modules/lang/org/autoload/org-link" "Continuously play all gifs in the visible buffer.") (autoload '+org/remove-link "~/doom-emacs/modules/lang/org/autoload/org-link" "Unlink the text at point." t) (autoload '+org/yank-link "~/doom-emacs/modules/lang/org/autoload/org-link" "Copy the url at point to the clipboard.\nIf on top of an Org link, will only copy the link component." t) (autoload '+org/play-gif-at-point "~/doom-emacs/modules/lang/org/autoload/org-link" "TODO" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org/autoload/org-refile.el") (load-true-file-name load-file-name)) (autoload '+org/refile-to-current-file "~/doom-emacs/modules/lang/org/autoload/org-refile" "Refile current heading to elsewhere in the current buffer.\nIf prefix ARG, copy instead of move.\n\n(fn ARG &optional FILE)" t) (autoload '+org/refile-to-file "~/doom-emacs/modules/lang/org/autoload/org-refile" "Refile current heading to a particular org file.\nIf prefix ARG, copy instead of move.\n\n(fn ARG FILE)" t) (autoload '+org/refile-to-other-window "~/doom-emacs/modules/lang/org/autoload/org-refile" "Refile current heading to an org buffer visible in another window.\nIf prefix ARG, copy instead of move.\n\n(fn ARG)" t) (autoload '+org/refile-to-other-buffer "~/doom-emacs/modules/lang/org/autoload/org-refile" "Refile current heading to another, living org buffer.\nIf prefix ARG, copy instead of move.\n\n(fn ARG)" t) (autoload '+org/refile-to-running-clock "~/doom-emacs/modules/lang/org/autoload/org-refile" "Refile current heading to the currently clocked in task.\nIf prefix ARG, copy instead of move.\n\n(fn ARG)" t) (autoload '+org/refile-to-last-location "~/doom-emacs/modules/lang/org/autoload/org-refile" "Refile current heading to the last node you refiled to.\nIf prefix ARG, copy instead of move.\n\n(fn ARG)" t) (autoload '+org/refile-to-visible "~/doom-emacs/modules/lang/org/autoload/org-refile" "Refile current heading as first child of visible heading selected with Avy." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org/autoload/org-tables.el") (load-true-file-name load-file-name)) (autoload '+org/table-previous-row "~/doom-emacs/modules/lang/org/autoload/org-tables" "Go to the previous row (same column) in the current table. Before doing so,\nre-align the table if necessary. (Necessary because org-mode has a\n`org-table-next-row', but not `org-table-previous-row')" t) (autoload '+org/table-insert-column-left "~/doom-emacs/modules/lang/org/autoload/org-tables" "Insert a new column left of the current column." t) (autoload '+org/table-insert-row-below "~/doom-emacs/modules/lang/org/autoload/org-tables" "Insert a new row below the current row." t) (autoload '+org-realign-table-maybe-h "~/doom-emacs/modules/lang/org/autoload/org-tables" "Auto-align table under cursor.") (autoload '+org-delete-backward-char-and-realign-table-maybe-h "~/doom-emacs/modules/lang/org/autoload/org-tables" "Ensure deleting characters with backspace doesn't deform the table cell.") (autoload '+org-realign-table-maybe-a "~/doom-emacs/modules/lang/org/autoload/org-tables" "Auto-align table under cursor and re-calculate formulas.\n\n(fn &rest _)")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org/autoload/org.el") (load-true-file-name load-file-name)) (autoload '+org-get-todo-keywords-for "~/doom-emacs/modules/lang/org/autoload/org" "Returns the list of todo keywords that KEYWORD belongs to.\n\n(fn &optional KEYWORD)") (autoload '+org-pretty-mode "~/doom-emacs/modules/lang/org/autoload/org" "Hides emphasis markers and toggles pretty entities.\n\nThis is a minor mode.  If called interactively, toggle the `+Org-Pretty\nmode' mode.  If the prefix argument is positive, enable the mode, and if\nit is zero or negative, disable the mode.\n\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\nif ARG is a negative number.\n\nTo check whether the minor mode is enabled in the current buffer,\nevaluate the variable `+org-pretty-mode'.\n\nThe mode's hook is called both when the mode is enabled and when it is\ndisabled.\n\n(fn &optional ARG)" t) (autoload '+org/return "~/doom-emacs/modules/lang/org/autoload/org" "Call `org-return' then indent (if `electric-indent-mode' is on)." t) (autoload '+org/dwim-at-point "~/doom-emacs/modules/lang/org/autoload/org" "Do-what-I-mean at point.\n\nIf on a:\n- checkbox list item or todo heading: toggle it.\n- citation: follow it\n- headline: cycle ARCHIVE subtrees, toggle latex fragments and inline images in\n  subtree; update statistics cookies/checkboxes and ToCs.\n- clock: update its time.\n- footnote reference: jump to the footnote's definition\n- footnote definition: jump to the first reference of this footnote\n- timestamp: open an agenda view for the time-stamp date/range at point.\n- table-row or a TBLFM: recalculate the table's formulas\n- table-cell: clear it and go into insert mode. If this is a formula cell,\n  recaluclate it instead.\n- babel-call: execute the source block\n- statistics-cookie: update it.\n- src block: execute it\n- latex fragment: toggle it.\n- link: follow it\n- otherwise, refresh all inline images in current tree.\n\n(fn &optional ARG)" t) (autoload '+org/shift-return "~/doom-emacs/modules/lang/org/autoload/org" "Insert a literal newline, or dwim in tables.\nExecutes `org-table-copy-down' if in table.\n\n(fn &optional ARG)" t) (autoload '+org/insert-item-below "~/doom-emacs/modules/lang/org/autoload/org" "Inserts a new heading, table cell or item below the current one.\n\n(fn COUNT)" t) (autoload '+org/insert-item-above "~/doom-emacs/modules/lang/org/autoload/org" "Inserts a new heading, table cell or item above the current one.\n\n(fn COUNT)" t) (autoload '+org/toggle-last-clock "~/doom-emacs/modules/lang/org/autoload/org" "Toggles last clocked item.\n\nClock out if an active clock is running (or cancel it if prefix ARG is non-nil).\n\nIf no clock is active, then clock into the last item. See `org-clock-in-last' to\nsee how ARG affects this command.\n\n(fn ARG)" t) (autoload '+org/reformat-at-point "~/doom-emacs/modules/lang/org/autoload/org" "Reformat the element at point.\n\nIf in an org src block, invokes `+format/org-block' if the ':editor format'\n  module is enabled.\nIf in an org table, realign the cells with `org-table-align'.\nOtherwise, falls back to `org-fill-paragraph' to reflow paragraphs." t) (defalias #'+org/toggle-fold #'+org-cycle-only-current-subtree-h) (autoload '+org/open-fold "~/doom-emacs/modules/lang/org/autoload/org" "Open the current fold (not but its children)." t) (defalias #'+org/close-fold #'outline-hide-subtree) (autoload '+org/close-all-folds "~/doom-emacs/modules/lang/org/autoload/org" "Close all folds in the buffer (or below LEVEL).\n\n(fn &optional LEVEL)" t) (autoload '+org/open-all-folds "~/doom-emacs/modules/lang/org/autoload/org" "Open all folds in the buffer (or up to LEVEL).\n\n(fn &optional LEVEL)" t) (autoload '+org/show-next-fold-level "~/doom-emacs/modules/lang/org/autoload/org" "Decrease the fold-level of the visible area of the buffer. This unfolds\nanother level of headings on each invocation.\n\n(fn &optional COUNT)" t) (autoload '+org/hide-next-fold-level "~/doom-emacs/modules/lang/org/autoload/org" "Increase the global fold-level of the visible area of the buffer. This folds\nanother level of headings on each invocation.\n\n(fn &optional COUNT)" t) (autoload '+org-indent-maybe-h "~/doom-emacs/modules/lang/org/autoload/org" "Indent the current item (header or item), if possible.\nMade for `org-tab-first-hook' in evil-mode." t) (autoload '+org-yas-expand-maybe-h "~/doom-emacs/modules/lang/org/autoload/org" "Expand a yasnippet snippet, if trigger exists at point or region is active.\nMade for `org-tab-first-hook'.") (autoload '+org-cycle-only-current-subtree-h "~/doom-emacs/modules/lang/org/autoload/org" "Toggle the local fold at the point, and no deeper.\n`org-cycle's standard behavior is to cycle between three levels: collapsed,\nsubtree and whole document. This is slow, especially in larger org buffer. Most\nof the time I just want to peek into the current subtree -- at most, expand\n*only* the current subtree.\n\nAll my (performant) foldings needs are met between this and `org-show-subtree'\n(on zO for evil users), and `org-cycle' on shift-TAB if I need it.\n\n(fn &optional ARG)" t) (autoload '+org-make-last-point-visible-h "~/doom-emacs/modules/lang/org/autoload/org" "Unfold subtree around point if saveplace places us in a folded region.") (autoload '+org-remove-occur-highlights-h "~/doom-emacs/modules/lang/org/autoload/org" "Remove org occur highlights on ESC in normal mode.")) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/sh/autoload.el") (load-true-file-name load-file-name)) (autoload '+sh--match-variables-in-quotes "~/doom-emacs/modules/lang/sh/autoload" "Search for variables in double-quoted strings bounded by LIMIT.\n\n(fn LIMIT)") (autoload '+sh--match-command-subst-in-quotes "~/doom-emacs/modules/lang/sh/autoload" "Search for variables in double-quoted strings bounded by LIMIT.\n\n(fn LIMIT)") (autoload '+sh/open-repl "~/doom-emacs/modules/lang/sh/autoload" "Open a shell REPL." t) (autoload '+sh-lookup-documentation-handler "~/doom-emacs/modules/lang/sh/autoload" "Look up documentation in `man' or `woman'." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/config/default/autoload/default.el") (load-true-file-name load-file-name)) (autoload '+default/compile "~/doom-emacs/modules/config/default/autoload/default" "Runs `compile' from the root of the current project.\n\nIf a compilation window is already open, recompile that instead.\n\nIf ARG (universal argument), runs `compile' from the current directory.\n\n(fn ARG)" t) (autoload '+default/man-or-woman "~/doom-emacs/modules/config/default/autoload/default" "Invoke `man' if man is installed and the platform is not MacOS, otherwise use `woman'.\n\n`man -k \"^\"` is very slow on MacOS, which is what `Man-completion-table' uses to\ngenerate `completing-read' candidates." t) (autoload '+default/new-buffer "~/doom-emacs/modules/config/default/autoload/default" "TODO" t) (autoload '+default/restart-server "~/doom-emacs/modules/config/default/autoload/default" "Restart the Emacs server." t) (autoload '+default/diagnostics "~/doom-emacs/modules/config/default/autoload/default" "List diagnostics for the current buffer/project.\nIf the vertico and lsp modules are active, list lsp diagnostics for the\ncurrent project. Otherwise list them for the current buffer\n\n(fn &rest ARG)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/config/default/autoload/deferred.el") (load-true-file-name load-file-name)) (autoload '+default/lsp-command-map "~/doom-emacs/modules/config/default/autoload/deferred" "Lazily invoke `lsp-command-map'." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/config/default/autoload/files.el") (load-true-file-name load-file-name)) (autoload '+default/browse-project "~/doom-emacs/modules/config/default/autoload/files" "Browse files from the current project's root." t) (autoload '+default/browse-templates "~/doom-emacs/modules/config/default/autoload/files" "Browse files from `+file-templates-dir'." t) (autoload '+default/find-in-templates "~/doom-emacs/modules/config/default/autoload/files" "Find a file under `+file-templates-dir', recursively." t) (autoload '+default/browse-notes "~/doom-emacs/modules/config/default/autoload/files" "Browse files from `org-directory'." t) (autoload '+default/find-in-notes "~/doom-emacs/modules/config/default/autoload/files" "Find a file under `org-directory', recursively." t) (autoload '+default/find-file-under-here "~/doom-emacs/modules/config/default/autoload/files" "Perform a recursive file search from the current directory." t) (autoload '+default/discover-projects "~/doom-emacs/modules/config/default/autoload/files" "Discover projects in `projectile-project-search-path'.\nIf prefix ARG is non-nil, prompt for the search path.\n\n(fn ARG)" t) (autoload '+default/dired "~/doom-emacs/modules/config/default/autoload/files" "Open a directory in dired.\nIf prefix ARG is non-nil, prompt for a known project to open in dired.\n\n(fn ARG)" t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/config/default/autoload/search.el") (load-true-file-name load-file-name)) (autoload '+default/search-cwd "~/doom-emacs/modules/config/default/autoload/search" "Conduct a text search in files under the current folder.\nIf prefix ARG is set, prompt for a directory to search from.\n\n(fn &optional ARG)" t) (autoload '+default/search-other-cwd "~/doom-emacs/modules/config/default/autoload/search" "Conduct a text search in another directory." t) (autoload '+default/search-emacsd "~/doom-emacs/modules/config/default/autoload/search" "Conduct a text search in files under `doom-emacs-dir'." t) (autoload '+default/search-buffer "~/doom-emacs/modules/config/default/autoload/search" "Conduct a text search on the current buffer.\n\nIf a selection is active and multi-line, perform a search restricted to that\nregion.\n\nIf a selection is active and not multi-line, use the selection as the initial\ninput and search the whole buffer for it." t) (autoload '+default/search-project "~/doom-emacs/modules/config/default/autoload/search" "Conduct a text search in the current project root.\nIf prefix ARG is set, include ignored/hidden files.\n\n(fn &optional ARG)" t) (autoload '+default/search-other-project "~/doom-emacs/modules/config/default/autoload/search" "Conduct a text search in a known project." t) (autoload '+default/search-project-for-symbol-at-point "~/doom-emacs/modules/config/default/autoload/search" "Search current project for symbol at point.\nIf prefix ARG is set, prompt for a known project to search from.\n\n(fn SYMBOL DIR)" t) (autoload '+default/search-notes-for-symbol-at-point "~/doom-emacs/modules/config/default/autoload/search" "Conduct a text search in the current project for symbol at point. If prefix\nARG is set, prompt for a known project to search from.\n\n(fn SYMBOL)" t) (autoload '+default/org-notes-search "~/doom-emacs/modules/config/default/autoload/search" "Perform a text search on `org-directory'.\n\n(fn QUERY)" t) (autoload '+default/org-notes-headlines "~/doom-emacs/modules/config/default/autoload/search" "Jump to an Org headline in `org-agenda-files'." t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/modules/config/default/autoload/text.el") (load-true-file-name load-file-name)) (defalias '+default/newline #'electric-indent-just-newline) (autoload '+default/newline-above "~/doom-emacs/modules/config/default/autoload/text" "Insert an indented new line before the current one." t) (autoload '+default/newline-below "~/doom-emacs/modules/config/default/autoload/text" "Insert an indented new line after the current one." t) (autoload '+default/yank-pop "~/doom-emacs/modules/config/default/autoload/text" "Interactively select what text to insert from the kill ring." t) (autoload '+default/yank-buffer-contents "~/doom-emacs/modules/config/default/autoload/text" "Copy entire buffer into kill ring." t) (autoload '+default/yank-buffer-path "~/doom-emacs/modules/config/default/autoload/text" "Copy the current buffer's path to the kill ring.\n\n(fn &optional ROOT)" t) (autoload '+default/yank-buffer-path-relative-to-project "~/doom-emacs/modules/config/default/autoload/text" "Copy the current buffer's path to the kill ring.\nWith non-nil prefix INCLUDE-ROOT, also include the project's root.\n\n(fn &optional INCLUDE-ROOT)" t) (autoload '+default/insert-file-path "~/doom-emacs/modules/config/default/autoload/text" "Insert the file name (absolute path if prefix ARG).\nIf `buffer-file-name' isn't set, uses `default-directory'.\n\n(fn ARG)" t) (autoload 'doom/backward-delete-whitespace-to-column "~/doom-emacs/modules/config/default/autoload/text" "Delete back to the previous column of whitespace, or as much whitespace as\npossible, or just one char if that's not possible." t) (autoload '+default--delete-backward-char-a "~/doom-emacs/modules/config/default/autoload/text" "Same as `delete-backward-char', but preforms these additional checks:\n\n+ If point is surrounded by (balanced) whitespace and a brace delimiter ({} []\n  ()), delete a space on either side of the cursor.\n+ If point is at BOL and surrounded by braces on adjacent lines, collapse\n  newlines:\n  {\n  |\n  } => {|}\n+ Otherwise, resort to `doom/backward-delete-whitespace-to-column'.\n+ Resorts to `delete-char' if n > 1\n\n(fn N &optional KILLFLAG)" t))))(defun doom--startup-loaddefs-packages nil (let ((load-in-progress t)) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/avy/avy-autoloads.el") (load-true-file-name load-file-name)) (autoload 'avy-process "avy" "\15\nSelect one of CANDIDATES using `avy-read'.\15\nUse OVERLAY-FN to visualize the decision overlay.\15\nCLEANUP-FN should take no arguments and remove the effects of\15\nmultiple OVERLAY-FN invocations.\15\n\15\n(fn CANDIDATES &optional OVERLAY-FN CLEANUP-FN)") (autoload 'avy-goto-char "avy" "\15\nJump to the currently visible CHAR.\15\nThe window scope is determined by `avy-all-windows' (ARG negates it).\15\n\15\n(fn CHAR &optional ARG)" t) (autoload 'avy-goto-char-in-line "avy" "\15\nJump to the currently visible CHAR in the current line.\15\n\15\n(fn CHAR)" t) (autoload 'avy-goto-char-2 "avy" "\15\nJump to the currently visible CHAR1 followed by CHAR2.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\nBEG and END narrow the scope where candidates are searched.\15\n\15\n(fn CHAR1 CHAR2 &optional ARG BEG END)" t) (autoload 'avy-goto-char-2-above "avy" "\15\nJump to the currently visible CHAR1 followed by CHAR2.\15\nThis is a scoped version of `avy-goto-char-2', where the scope is\15\nthe visible part of the current buffer up to point.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\n\15\n(fn CHAR1 CHAR2 &optional ARG)" t) (autoload 'avy-goto-char-2-below "avy" "\15\nJump to the currently visible CHAR1 followed by CHAR2.\15\nThis is a scoped version of `avy-goto-char-2', where the scope is\15\nthe visible part of the current buffer following point.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\n\15\n(fn CHAR1 CHAR2 &optional ARG)" t) (autoload 'avy-isearch "avy" "\15\nJump to one of the current isearch candidates." t) (autoload 'avy-goto-word-0 "avy" "\15\nJump to a word start.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\nBEG and END narrow the scope where candidates are searched.\15\n\15\n(fn ARG &optional BEG END)" t) (autoload 'avy-goto-whitespace-end "avy" "\15\nJump to the end of a whitespace sequence.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\nBEG and END narrow the scope where candidates are searched.\15\n\15\n(fn ARG &optional BEG END)" t) (autoload 'avy-goto-word-1 "avy" "\15\nJump to the currently visible CHAR at a word start.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\nBEG and END narrow the scope where candidates are searched.\15\nWhen SYMBOL is non-nil, jump to symbol start instead of word start.\15\n\15\n(fn CHAR &optional ARG BEG END SYMBOL)" t) (autoload 'avy-goto-word-1-above "avy" "\15\nJump to the currently visible CHAR at a word start.\15\nThis is a scoped version of `avy-goto-word-1', where the scope is\15\nthe visible part of the current buffer up to point.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\n\15\n(fn CHAR &optional ARG)" t) (autoload 'avy-goto-word-1-below "avy" "\15\nJump to the currently visible CHAR at a word start.\15\nThis is a scoped version of `avy-goto-word-1', where the scope is\15\nthe visible part of the current buffer following point.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\n\15\n(fn CHAR &optional ARG)" t) (autoload 'avy-goto-symbol-1 "avy" "\15\nJump to the currently visible CHAR at a symbol start.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\n\15\n(fn CHAR &optional ARG)" t) (autoload 'avy-goto-symbol-1-above "avy" "\15\nJump to the currently visible CHAR at a symbol start.\15\nThis is a scoped version of `avy-goto-symbol-1', where the scope is\15\nthe visible part of the current buffer up to point.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\n\15\n(fn CHAR &optional ARG)" t) (autoload 'avy-goto-symbol-1-below "avy" "\15\nJump to the currently visible CHAR at a symbol start.\15\nThis is a scoped version of `avy-goto-symbol-1', where the scope is\15\nthe visible part of the current buffer following point.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\n\15\n(fn CHAR &optional ARG)" t) (autoload 'avy-goto-subword-0 "avy" "\15\nJump to a word or subword start.\15\nThe window scope is determined by `avy-all-windows' (ARG negates it).\15\n\15\nWhen PREDICATE is non-nil it's a function of zero parameters that\15\nshould return true.\15\n\15\nBEG and END narrow the scope where candidates are searched.\15\n\15\n(fn &optional ARG PREDICATE BEG END)" t) (autoload 'avy-goto-subword-1 "avy" "\15\nJump to the currently visible CHAR at a subword start.\15\nThe window scope is determined by `avy-all-windows' (ARG negates it).\15\nThe case of CHAR is ignored.\15\n\15\n(fn CHAR &optional ARG)" t) (autoload 'avy-goto-word-or-subword-1 "avy" "\15\nForward to `avy-goto-subword-1' or `avy-goto-word-1'.\15\nWhich one depends on variable `subword-mode'." t) (autoload 'avy-goto-line "avy" "\15\nJump to a line start in current buffer.\15\n\15\nWhen ARG is 1, jump to lines currently visible, with the option\15\nto cancel to `goto-line' by entering a number.\15\n\15\nWhen ARG is 4, negate the window scope determined by\15\n`avy-all-windows'.\15\n\15\nOtherwise, forward to `goto-line' with ARG.\15\n\15\n(fn &optional ARG)" t) (autoload 'avy-goto-line-above "avy" "\15\nGoto visible line above the cursor.\15\nOFFSET changes the distance between the closest key to the cursor and\15\nthe cursor\15\nWhen BOTTOM-UP is non-nil, display avy candidates from top to bottom\15\n\15\n(fn &optional OFFSET BOTTOM-UP)" t) (autoload 'avy-goto-line-below "avy" "\15\nGoto visible line below the cursor.\15\nOFFSET changes the distance between the closest key to the cursor and\15\nthe cursor\15\nWhen BOTTOM-UP is non-nil, display avy candidates from top to bottom\15\n\15\n(fn &optional OFFSET BOTTOM-UP)" t) (autoload 'avy-goto-end-of-line "avy" "\15\nCall `avy-goto-line' and move to the end of the line.\15\n\15\n(fn &optional ARG)" t) (autoload 'avy-copy-line "avy" "\15\nCopy a selected line above the current line.\15\nARG lines can be used.\15\n\15\n(fn ARG)" t) (autoload 'avy-move-line "avy" "\15\nMove a selected line above the current line.\15\nARG lines can be used.\15\n\15\n(fn ARG)" t) (autoload 'avy-copy-region "avy" "\15\nSelect two lines and copy the text between them to point.\15\n\15\nThe window scope is determined by `avy-all-windows' or\15\n`avy-all-windows-alt' when ARG is non-nil.\15\n\15\n(fn ARG)" t) (autoload 'avy-move-region "avy" "\15\nSelect two lines and move the text between them above the current line." t) (autoload 'avy-kill-region "avy" "\15\nSelect two lines and kill the region between them.\15\n\15\nThe window scope is determined by `avy-all-windows' or\15\n`avy-all-windows-alt' when ARG is non-nil.\15\n\15\n(fn ARG)" t) (autoload 'avy-kill-ring-save-region "avy" "\15\nSelect two lines and save the region between them to the kill ring.\15\nThe window scope is determined by `avy-all-windows'.\15\nWhen ARG is non-nil, do the opposite of `avy-all-windows'.\15\n\15\n(fn ARG)" t) (autoload 'avy-kill-whole-line "avy" "\15\nSelect line and kill the whole selected line.\15\n\15\nWith a numerical prefix ARG, kill ARG line(s) starting from the\15\nselected line.  If ARG is negative, kill backward.\15\n\15\nIf ARG is zero, kill the selected line but exclude the trailing\15\nnewline.\15\n\15\n\\[universal-argument] 3 \\[avy-kil-whole-line] kill three lines\15\nstarting from the selected line.  \\[universal-argument] -3\15\n\15\n\\[avy-kill-whole-line] kill three lines backward including the\15\nselected line.\15\n\15\n(fn ARG)" t) (autoload 'avy-kill-ring-save-whole-line "avy" "\15\nSelect line and save the whole selected line as if killed, but don\x2019t kill it.\15\n\15\nThis command is similar to `avy-kill-whole-line', except that it\15\nsaves the line(s) as if killed, but does not kill it(them).\15\n\15\nWith a numerical prefix ARG, kill ARG line(s) starting from the\15\nselected line.  If ARG is negative, kill backward.\15\n\15\nIf ARG is zero, kill the selected line but exclude the trailing\15\nnewline.\15\n\15\n(fn ARG)" t) (autoload 'avy-setup-default "avy" "\15\nSetup the default shortcuts.") (autoload 'avy-goto-char-timer "avy" "\15\nRead one or many consecutive chars and jump to the first one.\15\nThe window scope is determined by `avy-all-windows' (ARG negates it).\15\n\15\n(fn &optional ARG)" t) (autoload 'avy-transpose-lines-in-region "avy" "\15\nTranspose lines in the active region." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/link-hint/link-hint-autoloads.el") (load-true-file-name load-file-name)) (autoload 'link-hint-define-type "link-hint" "\15\nAdd a new type of link called NAME to link-hint.el.\15\nPROPERTIES should be property value pairs to add to the symbol plist of\15\nlink-hint-NAME.\15\n\15\n(fn NAME &rest PROPERTIES)") (function-put 'link-hint-define-type 'lisp-indent-function 'defun) (autoload 'link-hint-open-link "link-hint" "\15\nUse avy to open a visible link." t) (autoload 'link-hint-copy-link "link-hint" "\15\nCopy a visible link of a supported type to the kill ring with avy.\15\n`select-enable-clipboard' and `select-enable-primary' can be set to non-nil\15\nvalues to copy the link to the clipboard and/or primary as well." t) (autoload 'link-hint-open-multiple-links "link-hint" "\15\nUse avy to open multiple visible links at once." t) (autoload 'link-hint-copy-multiple-links "link-hint" "\15\nUse avy to copy multiple visible links at once to the kill ring." t) (autoload 'link-hint-open-all-links "link-hint" "\15\nOpen all visible links." t) (autoload 'link-hint-copy-all-links "link-hint" "\15\nCopy all visible links." t) (autoload 'link-hint-open-link-at-point "link-hint" "\15\nOpen the link with the highest priority at the point." t) (autoload 'link-hint-copy-link-at-point "link-hint" "\15\nCopy the link with the highest priority at the point." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/bash-completion/bash-completion-autoloads.el") (load-true-file-name load-file-name)) (defun bash-completion-setup nil "\15\nRegister bash completion for the shell buffer and shell command line.\15\n\15\nThis function adds `bash-completion-dynamic-complete' to the completion\15\nfunction list of shell mode, `shell-dynamic-complete-functions'." (add-hook 'shell-dynamic-complete-functions #'bash-completion-dynamic-complete)) (autoload 'bash-completion-dynamic-complete "bash-completion" "\15\nReturn the completion table for bash command at point.\15\n\15\nThis function is meant to be added into\15\n`shell-dynamic-complete-functions'.  It uses `comint' to figure\15\nout what the current command is and returns a completion table or\15\nnil if no completions available.\15\n\15\nWhen doing completion outside of a comint buffer, call\15\n`bash-completion-dynamic-complete-nocomint' instead.") (autoload 'bash-completion-capf-nonexclusive "bash-completion" "\15\nBash completion function for `completion-at-point-functions'.\15\n\15\nReturns the same list as the one returned by\15\n`bash-completion-dynamic-complete-nocomint' appended with\15\n(:exclusive no) so that other completion functions are tried\15\nwhen bash-completion fails to match the text at point.") (autoload 'bash-completion-dynamic-complete-nocomint "bash-completion" "\15\nReturn completion information for bash command at an arbitrary position.\15\n\15\nThe bash command to be completed begins at COMP-START in the\15\ncurrent buffer.  This must specify where the current command\15\nstarts, usually right after the prompt.\15\n\15\nCOMP-POS is the point where completion should happen, usually\15\njust (point).  Note that a bash command can span across multiple\15\nline, so COMP-START is not necessarily on the same line as\15\nCOMP-POS.\15\n\15\nThis function does not assume that the current buffer is a shell\15\nor even comint buffer.  It can safely be called from any buffer\15\nwhere a bash command appears, including `completion-at-point'.\15\n\15\nIf DYNAMIC-TABLE is passed a non-nil value, the resulting\15\ncollection will be a function that fetches the result lazily,\15\nwhen it's called.\15\n\15\nWhen calling from `completion-at-point', make sure to pass a\15\nnon-nil value to DYNAMIC-TABLE.  This isn't just an optimization:\15\nreturning a function instead of a list tells Emacs it should\15\navoids post-filtering the results and possibly discarding useful\15\ncompletion from bash.\15\n\15\nWhen calling from another completion engine, make sure to treat\15\nthe returned completion as reliable and not post-process them\15\nfurther.\15\n\15\nReturns (list stub-start stub-end completions) with\15\n - stub-start, the position at which the completed region starts\15\n - stub-end, the position at which the completed region ends\15\n - completions, a possibly empty list of completion candidates\15\n   or a function, if DYNAMIC-TABLE is non-nil, a lambda such as the one\15\n   returned by `completion-table-dynamic'\15\n\15\n(fn COMP-START &optional COMP-POS DYNAMIC-TABLE)") (autoload 'bash-completion-refresh "bash-completion" "\15\nDoes nothing.\15\n\15\nThis command is obsolete and doesn't do anything useful anymore.\15\nIt used to refresh the copy of the completion table kept in\15\nmemory, but bash-completion.el now uses the completion table of\15\nthe Bash process directly." t) (autoload 'bash-completion-reset "bash-completion" "\15\nForce the next completion command to start with a fresh BASH process.\15\n\15\nThis function kills any existing BASH completion process.  This\15\nway, the next time BASH completion is requested, a new process\15\nwill be created with the latest configuration.  The BASH\15\ncompletion process that will be killed depends on the\15\n`default-directory' of the buffer where the command is executed.\15\n\15\nCall this method if you have updated your .bashrc or any bash init scripts\15\nand would like bash completion in Emacs to take these changes into account." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/dash/dash-autoloads.el") (load-true-file-name load-file-name)) (autoload 'dash-fontify-mode "dash" "\15\nToggle fontification of Dash special variables.\15\n\15\nDash-Fontify mode is a buffer-local minor mode intended for Emacs\15\nLisp buffers.  Enabling it causes the special variables bound in\15\nanaphoric Dash macros to be fontified.  These anaphoras include\15\n`it', `it-index', `acc', and `other'.  In older Emacs versions\15\nwhich do not dynamically detect macros, Dash-Fontify mode\15\nadditionally fontifies Dash macro calls.\15\n\15\nSee also `dash-fontify-mode-lighter' and\15\n`global-dash-fontify-mode'.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Dash-Fontify\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `dash-fontify-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-dash-fontify-mode 'globalized-minor-mode t) (defvar global-dash-fontify-mode nil "\15\nNon-nil if Global Dash-Fontify mode is enabled.\15\nSee the `global-dash-fontify-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-dash-fontify-mode'.") (autoload 'global-dash-fontify-mode "dash" "\15\nToggle Dash-Fontify mode in all buffers.\15\nWith prefix ARG, enable Global Dash-Fontify mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nDash-Fontify mode is enabled in all buffers where\15\n`dash--turn-on-fontify-mode' would do it.\15\n\15\nSee `dash-fontify-mode' for more information on Dash-Fontify mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'dash-register-info-lookup "dash" "\15\nRegister the Dash Info manual with `info-lookup-symbol'.\15\nThis allows Dash symbols to be looked up with \\[info-lookup-symbol]." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/org/org-autoloads.el") (load-true-file-name load-file-name)) (autoload 'org-cite-insert "oc" "\15\nInsert a citation at point.\15\nInsertion is done according to the processor set in `org-cite-insert-processor'.\15\nARG is the prefix argument received when calling interactively the function.\15\n\15\n(fn ARG)" t) (autoload 'org-babel-do-load-languages "org" "\15\nLoad the languages defined in `org-babel-load-languages'.\15\n\15\n(fn SYM VALUE)") (autoload 'org-babel-load-file "org" "\15\nLoad Emacs Lisp source code blocks in the Org FILE.\15\nThis function exports the source code using `org-babel-tangle'\15\nand then loads the resulting file using `load-file'.  With\15\noptional prefix argument COMPILE, the tangled Emacs Lisp file is\15\nbyte-compiled before it is loaded.\15\n\15\n(fn FILE &optional COMPILE)" t) (autoload 'org-version "org" "\15\nShow the Org version.\15\nInteractively, or when MESSAGE is non-nil, show it in echo area.\15\nWith prefix argument, or when HERE is non-nil, insert it at point.\15\nIn non-interactive uses, a reduced version string is output unless\15\nFULL is given.\15\n\15\n(fn &optional HERE FULL MESSAGE)" t) (autoload 'org-load-modules-maybe "org" "\15\nLoad all extensions listed in `org-modules'.\15\n\15\n(fn &optional FORCE)") (autoload 'org-clock-persistence-insinuate "org" "\15\nSet up hooks for clock persistence.") (autoload 'org-mode "org" "\15\nOutline-based notes management and organizer, alias\15\n\"Carsten's outline-mode for keeping track of everything.\"\15\n\15\nOrg mode develops organizational tasks around a NOTES file which\15\ncontains information about projects as plain text.  Org mode is\15\nimplemented on top of Outline mode, which is ideal to keep the content\15\nof large files well structured.  It supports ToDo items, deadlines and\15\ntime stamps, which magically appear in the diary listing of the Emacs\15\ncalendar.  Tables are easily created with a built-in table editor.\15\nPlain text URL-like links connect to websites, emails (VM), Usenet\15\nmessages (Gnus), BBDB entries, and any files related to the project.\15\nFor printing and sharing of notes, an Org file (or a part of it)\15\ncan be exported as a structured ASCII or HTML file.\15\n\15\nThe following commands are available:\15\n\15\n\\{org-mode-map}\15\n\15\n(fn)" t) (autoload 'org-run-like-in-org-mode "org" "\15\nRun a command, pretending that the current buffer is in Org mode.\15\nThis will temporarily bind local variables that are typically bound in\15\nOrg mode to the values they have in Org mode, and then interactively\15\ncall CMD.\15\n\15\n(fn CMD)") (autoload 'org-open-file "org" "\15\nOpen the file at PATH.\15\nFirst, this expands any special file name abbreviations.  Then the\15\nconfiguration variable `org-file-apps' is checked if it contains an\15\nentry for this file type, and if yes, the corresponding command is launched.\15\n\15\nIf no application is found, Emacs simply visits the file.\15\n\15\nWith optional prefix argument IN-EMACS, Emacs will visit the file.\15\nWith a double \\[universal-argument] \\[universal-argument] prefix arg, Org tries to avoid opening in Emacs\15\nand to use an external application to visit the file.\15\n\15\nOptional LINE specifies a line to go to, optional SEARCH a string\15\nto search for.  If LINE or SEARCH is given, the file will be\15\nopened in Emacs, unless an entry from `org-file-apps' that makes\15\nuse of groups in a regexp matches.\15\n\15\nIf you want to change the way frames are used when following a\15\nlink, please customize `org-link-frame-setup'.\15\n\15\nIf the file does not exist, throw an error.\15\n\15\n(fn PATH &optional IN-EMACS LINE SEARCH)") (autoload 'org-open-at-point-global "org" "\15\nFollow a link or a timestamp like Org mode does.\15\nAlso follow links and emails as seen by `thing-at-point'.\15\nThis command can be called in any mode to follow an external\15\nlink or a timestamp that has Org mode syntax.  Its behavior\15\nis undefined when called on internal links like fuzzy links.\15\nRaise a user error when there is nothing to follow." t) (autoload 'org-offer-links-in-entry "org" "\15\nOffer links in the current entry and return the selected link.\15\nIf there is only one link, return it.\15\nIf NTH is an integer, return the NTH link found.\15\nIf ZERO is a string, check also this string for a link, and if\15\nthere is one, return it.\15\n\15\n(fn BUFFER MARKER &optional NTH ZERO)") (autoload 'org-switchb "org" "\15\nSwitch between Org buffers.\15\n\15\nWith `\\[universal-argument]' prefix, restrict available buffers to files.\15\n\15\nWith `\\[universal-argument] \\[universal-argument]' prefix, restrict available buffers to agenda files.\15\n\15\n(fn &optional ARG)" t) (autoload 'org-cycle-agenda-files "org" "\15\nCycle through the files in `org-agenda-files'.\15\nIf the current buffer visits an agenda file, find the next one in the list.\15\nIf the current buffer does not, find the first agenda file." t) (autoload 'org-submit-bug-report "org" "\15\nSubmit a bug report on Org via mail.\15\n\15\nDon't hesitate to report any problems or inaccurate documentation.\15\n\15\nIf you don't have setup sending mail from (X)Emacs, please copy the\15\noutput buffer into your mail program, as it gives us important\15\ninformation about your Org version and configuration." t) (autoload 'org-reload "org" "\15\nReload all Org Lisp files.\15\nWith prefix arg UNCOMPILED, load the uncompiled versions.\15\n\15\n(fn &optional UNCOMPILED)" t) (autoload 'org-customize "org" "\15\nCall the customize function with org as argument." t) (autoload 'org-toggle-sticky-agenda "org-agenda" "\15\nToggle `org-agenda-sticky'.\15\n\15\n(fn &optional ARG)" t) (autoload 'org-agenda "org-agenda" "\15\nDispatch agenda commands to collect entries to the agenda buffer.\15\nPrompts for a command to execute.  Any prefix arg will be passed\15\non to the selected command.  The default selections are:\15\n\15\na     Call `org-agenda-list' to display the agenda for current day or week.\15\nt     Call `org-todo-list' to display the global todo list.\15\nT     Call `org-todo-list' to display the global todo list, select only\15\n      entries with a specific TODO keyword (the user gets a prompt).\15\nm     Call `org-tags-view' to display headlines with tags matching\15\n      a condition  (the user is prompted for the condition).\15\nM     Like `m', but select only TODO entries, no ordinary headlines.\15\ne     Export views to associated files.\15\ns     Search entries for keywords.\15\nS     Search entries for keywords, only with TODO keywords.\15\n/     Multi occur across all agenda files and also files listed\15\n      in `org-agenda-text-search-extra-files'.\15\n<     Restrict agenda commands to buffer, subtree, or region.\15\n      Press several times to get the desired effect.\15\n>     Remove a previous restriction.\15\n#     List \"stuck\" projects.\15\n!     Configure what \"stuck\" means.\15\nC     Configure custom agenda commands.\15\n\15\nMore commands can be added by configuring the variable\15\n`org-agenda-custom-commands'.  In particular, specific tags and TODO keyword\15\nsearches can be pre-defined in this way.\15\n\15\nIf the current buffer is in Org mode and visiting a file, you can also\15\nfirst press `<' once to indicate that the agenda should be temporarily\15\n(until the next use of `\\[org-agenda]') restricted to the current file.\15\nPressing `<' twice means to restrict to the current subtree or region\15\n(if active).\15\n\15\n(fn &optional ARG KEYS RESTRICTION)" t) (autoload 'org-batch-agenda "org-agenda" "\15\nRun an agenda command in batch mode and send the result to STDOUT.\15\nIf CMD-KEY is a string of length 1, it is used as a key in\15\n`org-agenda-custom-commands' and triggers this command.  If it is a\15\nlonger string it is used as a tags/todo match string.\15\nParameters are alternating variable names and values that will be bound\15\nbefore running the agenda command.\15\n\15\n(fn CMD-KEY &rest PARAMETERS)" nil t) (autoload 'org-batch-agenda-csv "org-agenda" "\15\nRun an agenda command in batch mode and send the result to STDOUT.\15\nIf CMD-KEY is a string of length 1, it is used as a key in\15\n`org-agenda-custom-commands' and triggers this command.  If it is a\15\nlonger string it is used as a tags/todo match string.\15\nParameters are alternating variable names and values that will be bound\15\nbefore running the agenda command.\15\n\15\nThe output gives a line for each selected agenda item.  Each\15\nitem is a list of comma-separated values, like this:\15\n\15\ncategory,head,type,todo,tags,date,time,extra,priority-l,priority-n\15\n\15\ncategory     The category of the item\15\nhead         The headline, without TODO kwd, TAGS and PRIORITY\15\ntype         The type of the agenda entry, can be\15\n                todo               selected in TODO match\15\n                tagsmatch          selected in tags match\15\n                diary              imported from diary\15\n                deadline           a deadline on given date\15\n                scheduled          scheduled on given date\15\n                timestamp          entry has timestamp on given date\15\n                closed             entry was closed on given date\15\n                upcoming-deadline  warning about deadline\15\n                past-scheduled     forwarded scheduled item\15\n                block              entry has date block including g. date\15\ntodo         The todo keyword, if any\15\ntags         All tags including inherited ones, separated by colons\15\ndate         The relevant date, like 2007-2-14\15\ntime         The time, like 15:00-16:50\15\nextra        String with extra planning info\15\npriority-l   The priority letter if any was given\15\npriority-n   The computed numerical priority\15\nagenda-day   The day in the agenda where this is listed\15\n\15\n(fn CMD-KEY &rest PARAMETERS)" nil t) (autoload 'org-store-agenda-views "org-agenda" "\15\nStore agenda views.\15\n\15\n(fn &rest PARAMETERS)" t) (autoload 'org-batch-store-agenda-views "org-agenda" "\15\nRun all custom agenda commands that have a file argument.\15\n\15\n(fn &rest PARAMETERS)" nil t) (autoload 'org-agenda-list "org-agenda" "\15\nProduce a daily/weekly view from all files in variable `org-agenda-files'.\15\nThe view will be for the current day or week, but from the overview buffer\15\nyou will be able to go to other days/weeks.\15\n\15\nWith a numeric prefix argument in an interactive call, the agenda will\15\nspan ARG days.  Lisp programs should instead specify SPAN to change\15\nthe number of days.  SPAN defaults to `org-agenda-span'.\15\n\15\nSTART-DAY defaults to TODAY, or to the most recent match for the weekday\15\ngiven in `org-agenda-start-on-weekday'.\15\n\15\nWhen WITH-HOUR is non-nil, only include scheduled and deadline\15\nitems if they have an hour specification like [h]h:mm.\15\n\15\n(fn &optional ARG START-DAY SPAN WITH-HOUR)" t) (autoload 'org-search-view "org-agenda" "\15\nShow all entries that contain a phrase or words or regular expressions.\15\n\15\nWith optional prefix argument TODO-ONLY, only consider entries that are\15\nTODO entries.  The argument STRING can be used to pass a default search\15\nstring into this function.  If EDIT-AT is non-nil, it means that the\15\nuser should get a chance to edit this string, with cursor at position\15\nEDIT-AT.\15\n\15\nThe search string can be viewed either as a phrase that should be found as\15\nis, or it can be broken into a number of snippets, each of which must match\15\nin a Boolean way to select an entry.  The default depends on the variable\15\n`org-agenda-search-view-always-boolean'.\15\nEven if this is turned off (the default) you can always switch to\15\nBoolean search dynamically by preceding the first word with  \"+\" or \"-\".\15\n\15\nThe default is a direct search of the whole phrase, where each space in\15\nthe search string can expand to an arbitrary amount of whitespace,\15\nincluding newlines.\15\n\15\nIf using a Boolean search, the search string is split on whitespace and\15\neach snippet is searched separately, with logical AND to select an entry.\15\nWords prefixed with a minus must *not* occur in the entry.  Words without\15\na prefix or prefixed with a plus must occur in the entry.  Matching is\15\ncase-insensitive.  Words are enclosed by word delimiters (i.e. they must\15\nmatch whole words, not parts of a word) if\15\n`org-agenda-search-view-force-full-words' is set (default is nil).\15\n\15\nBoolean search snippets enclosed by curly braces are interpreted as\15\nregular expressions that must or (when preceded with \"-\") must not\15\nmatch in the entry.  Snippets enclosed into double quotes will be taken\15\nas a whole, to include whitespace.\15\n\15\n- If the search string starts with an asterisk, search only in headlines.\15\n- If (possibly after the leading star) the search string starts with an\15\n  exclamation mark, this also means to look at TODO entries only, an effect\15\n  that can also be achieved with a prefix argument.\15\n- If (possibly after star and exclamation mark) the search string starts\15\n  with a colon, this will mean that the (non-regexp) snippets of the\15\n  Boolean search must match as full words.\15\n\15\nThis command searches the agenda files, and in addition the files\15\nlisted in `org-agenda-text-search-extra-files' unless a restriction lock\15\nis active.\15\n\15\n(fn &optional TODO-ONLY STRING EDIT-AT)" t) (autoload 'org-todo-list "org-agenda" "\15\nShow all (not done) TODO entries from all agenda files in a single list.\15\nThe prefix arg can be used to select a specific TODO keyword and limit\15\nthe list to these.  When using `\\[universal-argument]', you will be prompted\15\nfor a keyword.  A numeric prefix directly selects the Nth keyword in\15\n`org-todo-keywords-1'.\15\n\15\n(fn &optional ARG)" t) (autoload 'org-tags-view "org-agenda" "\15\nShow all headlines for all `org-agenda-files' matching a TAGS criterion.\15\nThe prefix arg TODO-ONLY limits the search to TODO entries.\15\n\15\n(fn &optional TODO-ONLY MATCH)" t) (autoload 'org-agenda-list-stuck-projects "org-agenda" "\15\nCreate agenda view for projects that are stuck.\15\nStuck projects are project that have no next actions.  For the definitions\15\nof what a project is and how to check if it stuck, customize the variable\15\n`org-stuck-projects'.\15\n\15\n(fn &rest IGNORE)" t) (autoload 'org-diary "org-agenda" "\15\nReturn diary information from org files.\15\nThis function can be used in a \"sexp\" diary entry in the Emacs calendar.\15\nIt accesses org files and extracts information from those files to be\15\nlisted in the diary.  The function accepts arguments specifying what\15\nitems should be listed.  For a list of arguments allowed here, see the\15\nvariable `org-agenda-entry-types'.\15\n\15\nThe call in the diary file should look like this:\15\n\15\n   &%%(org-diary) ~/path/to/some/orgfile.org\15\n\15\nUse a separate line for each org file to check.  Or, if you omit the file name,\15\nall files listed in `org-agenda-files' will be checked automatically:\15\n\15\n   &%%(org-diary)\15\n\15\nIf you don't give any arguments (as in the example above), the default value\15\nof `org-agenda-entry-types' is used: (:deadline :scheduled :timestamp :sexp).\15\nSo the example above may also be written as\15\n\15\n   &%%(org-diary :deadline :timestamp :sexp :scheduled)\15\n\15\nThe function expects the lisp variables `entry' and `date' to be provided\15\nby the caller, because this is how the calendar works.  Don't use this\15\nfunction from a program - use `org-agenda-get-day-entries' instead.\15\n\15\n(fn &rest ARGS)") (autoload 'org-agenda-check-for-timestamp-as-reason-to-ignore-todo-item "org-agenda" "\15\nDo we have a reason to ignore this TODO entry because it has a time stamp?\15\n\15\n(fn &optional END)") (autoload 'org-agenda-set-restriction-lock "org-agenda" "\15\nSet restriction lock for agenda to current subtree or file.\15\nWhen in a restricted subtree, remove it.\15\n\15\nThe restriction will span over the entire file if TYPE is `file',\15\nor if TYPE is (4), or if the cursor is before the first headline\15\nin the file.  Otherwise, only apply the restriction to the current\15\nsubtree.\15\n\15\n(fn &optional TYPE)" t) (autoload 'org-calendar-goto-agenda "org-agenda" "\15\nCompute the Org agenda for the calendar date displayed at the cursor.\15\nThis is a command that has to be installed in `calendar-mode-map'." t) (autoload 'org-agenda-to-appt "org-agenda" "\15\nActivate appointments found in `org-agenda-files'.\15\n\15\nWith a `\\[universal-argument]' prefix, refresh the list of appointments.\15\n\15\nIf FILTER is t, interactively prompt the user for a regular\15\nexpression, and filter out entries that don't match it.\15\n\15\nIf FILTER is a string, use this string as a regular expression\15\nfor filtering entries out.\15\n\15\nIf FILTER is a function, filter out entries against which\15\ncalling the function returns nil.  This function takes one\15\nargument: an entry from `org-agenda-get-day-entries'.\15\n\15\nFILTER can also be an alist with the car of each cell being\15\neither `headline' or `category'.  For example:\15\n\15\n   ((headline \"IMPORTANT\")\15\n    (category \"Work\"))\15\n\15\nwill only add headlines containing IMPORTANT or headlines\15\nbelonging to the \"Work\" category.\15\n\15\nARGS are symbols indicating what kind of entries to consider.\15\nBy default `org-agenda-to-appt' will use :deadline*, :scheduled*\15\n(i.e., deadlines and scheduled items with a hh:mm specification)\15\nand :timestamp entries.  See the docstring of `org-diary' for\15\ndetails and examples.\15\n\15\nIf an entry has a APPT_WARNTIME property, its value will be used\15\nto override `appt-message-warning-time'.\15\n\15\n(fn &optional REFRESH FILTER &rest ARGS)" t) (autoload 'org-capture-string "org-capture" "\15\nCapture STRING with the template selected by KEYS.\15\n\15\n(fn STRING &optional KEYS)" t) (autoload 'org-capture "org-capture" "\15\nCapture something.\15\n\\<org-capture-mode-map>\15\nThis will let you select a template from `org-capture-templates', and\15\nthen file the newly captured information.  The text is immediately\15\ninserted at the target location, and an indirect buffer is shown where\15\nyou can edit it.  Pressing `\\[org-capture-finalize]' brings you back to the previous\15\nstate of Emacs, so that you can continue your work.\15\n\15\nWhen called interactively with a `\\[universal-argument]' prefix argument GOTO, don't\15\ncapture anything, just go to the file/headline where the selected\15\ntemplate stores its notes.\15\n\15\nWith a `\\[universal-argument] \\[universal-argument]' prefix argument, go to the last note stored.\15\n\15\nWhen called with a `C-0' (zero) prefix, insert a template at point.\15\n\15\nWhen called with a `C-1' (one) prefix, force prompting for a date when\15\na datetree entry is made.\15\n\15\nElisp programs can set KEYS to a string associated with a template\15\nin `org-capture-templates'.  In this case, interactive selection\15\nwill be bypassed.\15\n\15\nIf `org-capture-use-agenda-date' is non-nil, capturing from the\15\nagenda will use the date at point as the default date.  Then, a\15\n`C-1' prefix will tell the capture process to use the HH:MM time\15\nof the day at point (if any) or the current HH:MM time.\15\n\15\n(fn &optional GOTO KEYS)" t) (autoload 'org-capture-import-remember-templates "org-capture" "\15\nSet `org-capture-templates' to be similar to `org-remember-templates'." t) (autoload 'org-encrypt-entry "org-crypt" "\15\nEncrypt the content of the current headline." t) (autoload 'org-decrypt-entry "org-crypt" "\15\nDecrypt the content of the current headline." t) (autoload 'org-encrypt-entries "org-crypt" "\15\nEncrypt all top-level entries in the current buffer." t) (autoload 'org-decrypt-entries "org-crypt" "\15\nDecrypt all entries in the current buffer." t) (autoload 'org-crypt-use-before-save-magic "org-crypt" "\15\nAdd a hook to automatically encrypt entries before a file is saved to disk.") (autoload 'org-cycle "org-cycle" "\15\nTAB-action and visibility cycling for Org mode.\15\n\15\nThis is the command invoked in Org mode by the `TAB' key.  Its main\15\npurpose is outline visibility cycling, but it also invokes other actions\15\nin special contexts.\15\n\15\nWhen this function is called with a `\\[universal-argument]' prefix, rotate the entire\15\nbuffer through 3 states (global cycling)\15\n  1. OVERVIEW: Show only top-level headlines.\15\n  2. CONTENTS: Show all headlines of all levels, but no body text.\15\n  3. SHOW ALL: Show everything.\15\n\15\nWith a `\\[universal-argument] \\[universal-argument]' prefix argument, switch to the startup visibility,\15\ndetermined by the variable `org-startup-folded', and by any VISIBILITY\15\nproperties in the buffer.\15\n\15\nWith a `\\[universal-argument] \\[universal-argument] \\[universal-argument]' prefix argument, show the entire buffer, including\15\nany drawers.\15\n\15\nWhen inside a table, re-align the table and move to the next field.\15\n\15\nWhen point is at the beginning of a headline, rotate the subtree started\15\nby this line through 3 different states (local cycling)\15\n  1. FOLDED:   Only the main headline is shown.\15\n  2. CHILDREN: The main headline and the direct children are shown.\15\n               From this state, you can move to one of the children\15\n               and zoom in further.\15\n  3. SUBTREE:  Show the entire subtree, including body text.\15\nIf there is no subtree, switch directly from CHILDREN to FOLDED.\15\n\15\nWhen point is at the beginning of an empty headline and the variable\15\n`org-cycle-level-after-item/entry-creation' is set, cycle the level\15\nof the headline by demoting and promoting it to likely levels.  This\15\nspeeds up creation document structure by pressing `TAB' once or several\15\ntimes right after creating a new headline.\15\n\15\nWhen there is a numeric prefix, go up to a heading with level ARG, do\15\na `show-subtree' and return to the previous cursor position.  If ARG\15\nis negative, go up that many levels.\15\n\15\nWhen point is not at the beginning of a headline, execute the global\15\nbinding for `TAB', which is re-indenting the line.  See the option\15\n`org-cycle-emulate-tab' for details.\15\n\15\nAs a special case, if point is at the very beginning of the buffer, if\15\nthere is no headline there, and if the variable `org-cycle-global-at-bob'\15\nis non-nil, this function acts as if called with prefix argument (`\\[universal-argument] TAB',\15\nsame as `S-TAB') also when called without prefix argument.\15\n\15\n(fn &optional ARG)" t) (autoload 'org-cycle-global "org-cycle" "\15\nCycle the global visibility.  For details see `org-cycle'.\15\nWith `\\[universal-argument]' prefix ARG, switch to startup visibility.\15\nWith a numeric prefix, show all headlines up to that level.\15\n\15\n(fn &optional ARG)" t) (autoload 'org-koma-letter-export-as-latex "ox-koma-letter" "\15\nExport current buffer as a KOMA Scrlttr2 letter.\15\n\15\nIf narrowing is active in the current buffer, only export its\15\nnarrowed part.\15\n\15\nIf a region is active, export that region.\15\n\15\nA non-nil optional argument ASYNC means the process should happen\15\nasynchronously.  The resulting buffer should be accessible\15\nthrough the `org-export-stack' interface.\15\n\15\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\15\nat point, extracting information from the headline properties\15\nfirst.\15\n\15\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\15\ncontents of hidden elements.\15\n\15\nWhen optional argument BODY-ONLY is non-nil, only write code\15\nbetween \"\\begin{letter}\" and \"\\end{letter}\".\15\n\15\nEXT-PLIST, when provided, is a property list with external\15\nparameters overriding Org default settings, but still inferior to\15\nfile-local settings.\15\n\15\nExport is done in a buffer named \"*Org KOMA-LETTER Export*\".  It\15\nwill be displayed if `org-export-show-temporary-export-buffer' is\15\nnon-nil.\15\n\15\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t) (autoload 'org-koma-letter-export-to-latex "ox-koma-letter" "\15\nExport current buffer as a KOMA Scrlttr2 letter (tex).\15\n\15\nIf narrowing is active in the current buffer, only export its\15\nnarrowed part.\15\n\15\nIf a region is active, export that region.\15\n\15\nA non-nil optional argument ASYNC means the process should happen\15\nasynchronously.  The resulting file should be accessible through\15\nthe `org-export-stack' interface.\15\n\15\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\15\nat point, extracting information from the headline properties\15\nfirst.\15\n\15\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\15\ncontents of hidden elements.\15\n\15\nWhen optional argument BODY-ONLY is non-nil, only write code\15\nbetween \"\\begin{letter}\" and \"\\end{letter}\".\15\n\15\nEXT-PLIST, when provided, is a property list with external\15\nparameters overriding Org default settings, but still inferior to\15\nfile-local settings.\15\n\15\nWhen optional argument PUB-DIR is set, use it as the publishing\15\ndirectory.\15\n\15\nReturn output file's name.\15\n\15\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t) (autoload 'org-koma-letter-export-to-pdf "ox-koma-letter" "\15\nExport current buffer as a KOMA Scrlttr2 letter (pdf).\15\n\15\nIf narrowing is active in the current buffer, only export its\15\nnarrowed part.\15\n\15\nIf a region is active, export that region.\15\n\15\nA non-nil optional argument ASYNC means the process should happen\15\nasynchronously.  The resulting file should be accessible through\15\nthe `org-export-stack' interface.\15\n\15\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\15\nat point, extracting information from the headline properties\15\nfirst.\15\n\15\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\15\ncontents of hidden elements.\15\n\15\nWhen optional argument BODY-ONLY is non-nil, only write code\15\nbetween \"\\begin{letter}\" and \"\\end{letter}\".\15\n\15\nEXT-PLIST, when provided, is a property list with external\15\nparameters overriding Org default settings, but still inferior to\15\nfile-local settings.\15\n\15\nReturn PDF file's name.\15\n\15\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/async/async-autoloads.el") (load-true-file-name load-file-name)) (autoload 'async-start-process "async" "\15\nStart the executable PROGRAM asynchronously named NAME.  See `async-start'.\15\nPROGRAM is passed PROGRAM-ARGS, calling FINISH-FUNC with the\15\nprocess object when done.  If FINISH-FUNC is nil, the future\15\nobject will return the process object when the program is\15\nfinished.  Set DEFAULT-DIRECTORY to change PROGRAM's current\15\nworking directory.\15\n\15\n(fn NAME PROGRAM FINISH-FUNC &rest PROGRAM-ARGS)") (autoload 'async-start "async" "\15\nExecute START-FUNC (often a lambda) in a subordinate Emacs process.\15\nWhen done, the return value is passed to FINISH-FUNC.  Example:\15\n\15\n    (async-start\15\n       ;; What to do in the child process\15\n       (lambda ()\15\n         (message \"This is a test\")\15\n         (sleep-for 3)\15\n         222)\15\n\15\n       ;; What to do when it finishes\15\n       (lambda (result)\15\n         (message \"Async process done, result should be 222: %s\"\15\n                  result)))\15\n\15\nIf you call `async-send' from a child process, the message will\15\nbe also passed to the FINISH-FUNC.  You can test RESULT to see if\15\nit is a message by using `async-message-p'.  If nil, it means\15\nthis is the final result.  Example of the FINISH-FUNC:\15\n\15\n    (lambda (result)\15\n      (if (async-message-p result)\15\n          (message \"Received a message from child process: %s\" result)\15\n        (message \"Async process done, result: %s\" result)))\15\n\15\nIf FINISH-FUNC is nil or missing, a future is returned that can\15\nbe inspected using `async-get', blocking until the value is\15\nready.  Example:\15\n\15\n    (let ((proc (async-start\15\n                   ;; What to do in the child process\15\n                   (lambda ()\15\n                     (message \"This is a test\")\15\n                     (sleep-for 3)\15\n                     222))))\15\n\15\n        (message \"I'm going to do some work here\") ;; ....\15\n\15\n        (message \"Waiting on async process, result should be 222: %s\"\15\n                 (async-get proc)))\15\n\15\nIf you don't want to use a callback, and you don't care about any\15\nreturn value from the child process, pass the `ignore' symbol as\15\nthe second argument (if you don't, and never call `async-get', it\15\nwill leave *emacs* process buffers hanging around):\15\n\15\n    (async-start\15\n     (lambda ()\15\n       (delete-file \"a remote file on a slow link\" nil))\15\n     \\='ignore)\15\n\15\nSpecial case:\15\nIf the output of START-FUNC is a string with properties\15\ne.g. (buffer-string) RESULT will be transformed in a list where the\15\ncar is the string itself (without props) and the cdr the rest of\15\nproperties, this allows using in FINISH-FUNC the string without\15\nproperties and then apply the properties in cdr to this string (if\15\nneeded).\15\nProperties handling special objects like markers are returned as\15\nlist to allow restoring them later.\15\nSee <https://github.com/jwiegley/emacs-async/issues/145> for more infos.\15\n\15\nNote: Even when FINISH-FUNC is present, a future is still\15\nreturned except that it yields no value (since the value is\15\npassed to FINISH-FUNC).  Call `async-get' on such a future always\15\nreturns nil.  It can still be useful, however, as an argument to\15\n`async-ready' or `async-wait'.\15\n\15\n(fn START-FUNC &optional FINISH-FUNC)") (autoload 'async-byte-recompile-directory "async-bytecomp" "\15\nCompile all *.el files in DIRECTORY asynchronously.\15\nAll *.elc files are systematically deleted before proceeding.\15\n\15\n(fn DIRECTORY &optional QUIET)") (defvar async-bytecomp-package-mode nil "\15\nNon-nil if Async-Bytecomp-Package mode is enabled.\15\nSee the `async-bytecomp-package-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `async-bytecomp-package-mode'.") (autoload 'async-bytecomp-package-mode "async-bytecomp" "\15\nByte compile asynchronously packages installed with package.el.\15\n\15\nAsync compilation of packages can be controlled by\15\n`async-bytecomp-allowed-packages'.\15\nNOTE: Use this mode only if you install/upgrade etc... your packages\15\nsynchronously, if you use a package manager like helm-package.el which\15\nby default is async you don't need this.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Async-Bytecomp-Package mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='async-bytecomp-package-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'async-byte-compile-file "async-bytecomp" "\15\nByte compile Lisp code FILE asynchronously.\15\n\15\nSame as `byte-compile-file' but asynchronous.\15\n\15\n(fn FILE)" t) (defvar dired-async-mode nil "\15\nNon-nil if Dired-Async mode is enabled.\15\nSee the `dired-async-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `dired-async-mode'.") (autoload 'dired-async-mode "dired-async" "\15\nDo dired actions asynchronously.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Dired-Async mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='dired-async-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'dired-async-do-copy "dired-async" "\15\nRun \x2018\ dired-do-copy\x2019 asynchronously.\15\n\15\n(fn &optional ARG)" t) (autoload 'dired-async-do-symlink "dired-async" "\15\nRun \x2018\ dired-do-symlink\x2019 asynchronously.\15\n\15\n(fn &optional ARG)" t) (autoload 'dired-async-do-hardlink "dired-async" "\15\nRun \x2018\ dired-do-hardlink\x2019 asynchronously.\15\n\15\n(fn &optional ARG)" t) (autoload 'dired-async-do-rename "dired-async" "\15\nRun \x2018\ dired-do-rename\x2019 asynchronously.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/ob-async/ob-async-autoloads.el") (load-true-file-name load-file-name)) (defalias 'org-babel-execute-src-block:async 'ob-async-org-babel-execute-src-block) (autoload 'ob-async-org-babel-execute-src-block "ob-async" "\15\nLike org-babel-execute-src-block, but run asynchronously.\15\n\15\nOriginal docstring for org-babel-execute-src-block:\15\n\15\nExecute the current source code block.  Insert the results of\15\nexecution into the buffer.  Source code execution and the\15\ncollection and formatting of results can be controlled through a\15\nvariety of header arguments.\15\n\15\nWith prefix argument ARG, force re-execution even if an existing\15\nresult cached in the buffer would otherwise have been returned.\15\n\15\nOptionally supply a value for INFO in the form returned by\15\n`org-babel-get-src-block-info'.\15\n\15\nOptionally supply a value for PARAMS which will be merged with\15\nthe header arguments specified at the front of the source code\15\nblock.\15\n\15\n(fn &optional ORIG-FUN ARG INFO PARAMS)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/seq/seq-autoloads.el") (load-true-file-name load-file-name)) (autoload 'seq-subseq "seq-25" "\15\nReturn the sequence of elements of SEQUENCE from START to END.\15\nEND is exclusive.\15\n\15\nIf END is omitted, it defaults to the length of the sequence.  If\15\nSTART or END is negative, it counts from the end.  Signal an\15\nerror if START or END are outside of the sequence (i.e too large\15\nif positive or too small if negative).\15\n\15\n(fn SEQUENCE START &optional END)") (autoload 'seq-take "seq-25" "\15\nReturn the sequence made of the first N elements of SEQUENCE.\15\nThe result is a sequence of the same type as SEQUENCE.\15\n\15\nIf N is a negative integer or zero, an empty sequence is\15\nreturned.\15\n\15\n(fn SEQUENCE N)") (autoload 'seq-sort-by "seq-25" "\15\nSort SEQUENCE transformed by FUNCTION using PRED as the comparison function.\15\nElements of SEQUENCE are transformed by FUNCTION before being\15\nsorted.  FUNCTION must be a function of one argument.\15\n\15\n(fn FUNCTION PRED SEQUENCE)") (autoload 'seq-filter "seq-25" "\15\nReturn a list of all the elements in SEQUENCE for which PRED returns non-nil.\15\n\15\n(fn PRED SEQUENCE)") (autoload 'seq-remove "seq-25" "\15\nReturn a list of all the elements in SEQUENCE for which PRED returns nil.\15\n\15\n(fn PRED SEQUENCE)") (autoload 'seq-remove-at-position "seq-25" "\15\nReturn a copy of SEQUENCE with the element at index N removed.\15\n\15\nN is the (zero-based) index of the element that should not be in\15\nthe result.\15\n\15\nThe result is a sequence of the same type as SEQUENCE.\15\n\15\n(fn SEQUENCE N)") (autoload 'seq-reduce "seq-25" "\15\nReduce the function FUNCTION across SEQUENCE, starting with INITIAL-VALUE.\15\n\15\nReturn the result of calling FUNCTION with INITIAL-VALUE and the\15\nfirst element of SEQUENCE, then calling FUNCTION with that result\15\nand the second element of SEQUENCE, then with that result and the\15\nthird element of SEQUENCE, etc.  FUNCTION will be called with\15\nINITIAL-VALUE (and then the accumulated value) as the first\15\nargument, and the elements from SEQUENCE as the second argument.\15\n\15\nIf SEQUENCE is empty, return INITIAL-VALUE and FUNCTION is not called.\15\n\15\n(fn FUNCTION SEQUENCE INITIAL-VALUE)") (autoload 'seq-every-p "seq-25" "\15\nReturn non-nil if PRED returns non-nil for all the elements of SEQUENCE.\15\n\15\n(fn PRED SEQUENCE)") (autoload 'seq-some "seq-25" "\15\nReturn non-nil if PRED returns non-nil for at least one element of SEQUENCE.\15\nIf the value is non-nil, it is the first non-nil value returned by PRED.\15\n\15\n(fn PRED SEQUENCE)") (autoload 'seq-find "seq-25" "\15\nReturn the first element in SEQUENCE for which PRED returns non-nil.\15\nIf no such element is found, return DEFAULT.\15\n\15\nNote that `seq-find' has an ambiguity if the found element is\15\nidentical to DEFAULT, as in that case it is impossible to know\15\nwhether an element was found or not.\15\n\15\n(fn PRED SEQUENCE &optional DEFAULT)") (autoload 'seq-position "seq-25" "\15\nReturn the (zero-based) index of the first element in SEQUENCE \"equal\" to ELT.\15\n\"Equality\" is defined by the function TESTFN, which defaults to `equal'.\15\n\15\n(fn SEQUENCE ELT &optional TESTFN)") (autoload 'seq-positions "seq-25" "\15\nReturn list of indices of SEQUENCE elements for which TESTFN returns non-nil.\15\n\15\nTESTFN is a two-argument function which is called with each element of\15\nSEQUENCE as the first argument and ELT as the second.\15\nTESTFN defaults to `equal'.\15\n\15\nThe result is a list of (zero-based) indices.\15\n\15\n(fn SEQUENCE ELT &optional TESTFN)") (autoload 'seq-uniq "seq-25" "\15\nReturn a list of the elements of SEQUENCE with duplicates removed.\15\nTESTFN is used to compare elements, and defaults to `equal'.\15\n\15\n(fn SEQUENCE &optional TESTFN)") (autoload 'seq-union "seq-25" "\15\nReturn a list of all the elements that appear in either SEQUENCE1 or SEQUENCE2.\15\n\"Equality\" of elements is defined by the function TESTFN, which\15\ndefaults to `equal'.\15\n\15\n(fn SEQUENCE1 SEQUENCE2 &optional TESTFN)") (autoload 'seq-intersection "seq-25" "\15\nReturn a list of all the elements that appear in both SEQUENCE1 and SEQUENCE2.\15\n\"Equality\" of elements is defined by the function TESTFN, which\15\ndefaults to `equal'.\15\n\15\n(fn SEQUENCE1 SEQUENCE2 &optional TESTFN)") (autoload 'seq-group-by "seq-25" "\15\nApply FUNCTION to each element of SEQUENCE.\15\nSeparate the elements of SEQUENCE into an alist using the results as\15\nkeys.  Keys are compared using `equal'.\15\n\15\n(fn FUNCTION SEQUENCE)") (autoload 'seq-max "seq-25" "\15\nReturn the largest element of SEQUENCE.\15\nSEQUENCE must be a sequence of numbers or markers.\15\n\15\n(fn SEQUENCE)") (autoload 'seq-random-elt "seq-25" "\15\nReturn a randomly chosen element from SEQUENCE.\15\nSignal an error if SEQUENCE is empty.\15\n\15\n(fn SEQUENCE)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/with-editor/with-editor-autoloads.el") (load-true-file-name load-file-name)) (autoload 'with-editor-export-editor "with-editor" "\15\nTeach subsequent commands to use current Emacs instance as editor.\15\n\15\nSet and export the environment variable ENVVAR, by default\15\n\"EDITOR\".  The value is automatically generated to teach\15\ncommands to use the current Emacs instance as \"the editor\".\15\n\15\nThis works in `shell-mode', `term-mode', `eshell-mode' and\15\n`vterm'.\15\n\15\n(fn &optional (ENVVAR \"EDITOR\"))" t) (autoload 'with-editor-export-git-editor "with-editor" "\15\nLike `with-editor-export-editor' but always set `$GIT_EDITOR'." t) (autoload 'with-editor-export-hg-editor "with-editor" "\15\nLike `with-editor-export-editor' but always set `$HG_EDITOR'." t) (defvar shell-command-with-editor-mode nil "\15\nNon-nil if Shell-Command-With-Editor mode is enabled.\15\nSee the `shell-command-with-editor-mode' command\15\nfor a description of this minor mode.") (autoload 'shell-command-with-editor-mode "with-editor" "\15\nTeach `shell-command' to use current Emacs instance as editor.\15\n\15\nTeach `shell-command', and all commands that ultimately call that\15\ncommand, to use the current Emacs instance as editor by executing\15\n\"EDITOR=CLIENT COMMAND&\" instead of just \"COMMAND&\".\15\n\15\nCLIENT is automatically generated; EDITOR=CLIENT instructs\15\nCOMMAND to use to the current Emacs instance as \"the editor\",\15\nassuming no other variable overrides the effect of \"$EDITOR\".\15\nCLIENT may be the path to an appropriate emacsclient executable\15\nwith arguments, or a script which also works over Tramp.\15\n\15\nAlternatively you can use the `with-editor-async-shell-command',\15\nwhich also allows the use of another variable instead of\15\n\"EDITOR\".\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Shell-Command-With-Editor mode' mode.  If the prefix argument is\15\npositive, enable the mode, and if it is zero or negative, disable the\15\nmode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='shell-command-with-editor-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'with-editor-async-shell-command "with-editor" "\15\nLike `async-shell-command' but with `$EDITOR' set.\15\n\15\nExecute string \"ENVVAR=CLIENT COMMAND\" in an inferior shell;\15\ndisplay output, if any.  With a prefix argument prompt for an\15\nenvironment variable, otherwise the default \"EDITOR\" variable\15\nis used.  With a negative prefix argument additionally insert\15\nthe COMMAND's output at point.\15\n\15\nCLIENT is automatically generated; ENVVAR=CLIENT instructs\15\nCOMMAND to use to the current Emacs instance as \"the editor\",\15\nassuming it respects ENVVAR as an \"EDITOR\"-like variable.\15\nCLIENT may be the path to an appropriate emacsclient executable\15\nwith arguments, or a script which also works over Tramp.\15\n\15\nAlso see `async-shell-command' and `shell-command'.\15\n\15\n(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t) (autoload 'with-editor-shell-command "with-editor" "\15\nLike `shell-command' or `with-editor-async-shell-command'.\15\nIf COMMAND ends with \"&\" behave like the latter,\15\nelse like the former.\15\n\15\n(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER ENVVAR)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/transient/transient-autoloads.el") (load-true-file-name load-file-name)) (autoload 'transient-insert-suffix "transient" "\15\nInsert a SUFFIX into PREFIX before LOC.\15\nPREFIX is a prefix command, a symbol.\15\nSUFFIX is a suffix command or a group specification (of\15\n  the same forms as expected by `transient-define-prefix').\15\nLOC is a command, a key vector, a key description (a string\15\n  as returned by `key-description'), or a coordination list\15\n  (whose last element may also be a command or key).\15\nRemove a conflicting binding unless optional KEEP-OTHER is\15\n  non-nil.  When the conflict appears to be a false-positive,\15\n  non-nil KEEP-OTHER may be ignored, which can be prevented\15\n  by using `always'.\15\nSee info node `(transient)Modifying Existing Transients'.\15\n\15\n(fn PREFIX LOC SUFFIX &optional KEEP-OTHER)") (function-put 'transient-insert-suffix 'lisp-indent-function 'defun) (autoload 'transient-append-suffix "transient" "\15\nInsert a SUFFIX into PREFIX after LOC.\15\nPREFIX is a prefix command, a symbol.\15\nSUFFIX is a suffix command or a group specification (of\15\n  the same forms as expected by `transient-define-prefix').\15\nLOC is a command, a key vector, a key description (a string\15\n  as returned by `key-description'), or a coordination list\15\n  (whose last element may also be a command or key).\15\nRemove a conflicting binding unless optional KEEP-OTHER is\15\n  non-nil.  When the conflict appears to be a false-positive,\15\n  non-nil KEEP-OTHER may be ignored, which can be prevented\15\n  by using `always'.\15\nSee info node `(transient)Modifying Existing Transients'.\15\n\15\n(fn PREFIX LOC SUFFIX &optional KEEP-OTHER)") (function-put 'transient-append-suffix 'lisp-indent-function 'defun) (autoload 'transient-replace-suffix "transient" "\15\nReplace the suffix at LOC in PREFIX with SUFFIX.\15\nPREFIX is a prefix command, a symbol.\15\nSUFFIX is a suffix command or a group specification (of\15\n  the same forms as expected by `transient-define-prefix').\15\nLOC is a command, a key vector, a key description (a string\15\n  as returned by `key-description'), or a coordination list\15\n  (whose last element may also be a command or key).\15\nSee info node `(transient)Modifying Existing Transients'.\15\n\15\n(fn PREFIX LOC SUFFIX)") (function-put 'transient-replace-suffix 'lisp-indent-function 'defun) (autoload 'transient-inline-group "transient" "\15\nInline the included GROUP into PREFIX.\15\nReplace the symbol GROUP with its expanded layout in the\15\nlayout of PREFIX.\15\n\15\n(fn PREFIX GROUP)") (function-put 'transient-inline-group 'lisp-indent-function 'defun) (autoload 'transient-remove-suffix "transient" "\15\nRemove the suffix or group at LOC in PREFIX.\15\nPREFIX is a prefix command, a symbol.\15\nLOC is a command, a key vector, a key description (a string\15\n  as returned by `key-description'), or a coordination list\15\n  (whose last element may also be a command or key).\15\nSee info node `(transient)Modifying Existing Transients'.\15\n\15\n(fn PREFIX LOC)") (function-put 'transient-remove-suffix 'lisp-indent-function 'defun) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/llama/llama-autoloads.el") (load-true-file-name load-file-name)) (autoload 'llama "llama" "\15\nExpand to a `lambda' expression that wraps around FN and BODY.\15\n\15\nThis macro provides a compact way to write short `lambda' expressions.\15\nIt expands to a `lambda' expression, which calls the function FN with\15\narguments BODY and returns its value.  The arguments of the `lambda'\15\nexpression are derived from symbols found in BODY.\15\n\15\nEach symbol from `%1' through `%9', which appears in an unquoted part\15\nof BODY, specifies a mandatory argument.  Each symbol from `&1' through\15\n`&9', which appears in an unquoted part of BODY, specifies an optional\15\nargument.  The symbol `&*' specifies extra (`&rest') arguments.\15\n\15\nThe shorter symbol `%' can be used instead of `%1', but using both in\15\nthe same expression is not allowed.  Likewise `&' can be used instead\15\nof `&1'.  These shorthands are not recognized in function position.\15\n\15\nTo support binding forms that use a vector as VARLIST (such as `-let'\15\nfrom the `dash' package), argument symbols are also detected inside of\15\nvectors.\15\n\15\nThe space between `##' and FN can be omitted because `##' is read-syntax\15\nfor the symbol whose name is the empty string.  If you prefer you can\15\nplace a space there anyway, and if you prefer to not use this somewhat\15\nmagical symbol at all, you can instead use the alternative name `llama'.\15\n\15\nInstead of:\15\n\15\n  (lambda (a &optional _ c &rest d)\15\n    (foo a (bar c) d))\15\n\15\nyou can use this macro and write:\15\n\15\n  (##foo %1 (bar &3) &*)\15\n\15\nwhich expands to:\15\n\15\n  (lambda (%1 &optional _&2 &3 &rest &*)\15\n    (foo %1 (bar &3) &*))\15\n\15\nUnused trailing arguments and mandatory unused arguments at the border\15\nbetween mandatory and optional arguments are also supported:\15\n\15\n  (##list %1 _%3 &5 _&6)\15\n\15\nbecomes:\15\n\15\n  (lambda (%1 _%2 _%3 &optional _&4 &5 _&6)\15\n    (list %1 &5))\15\n\15\nNote how `_%3' and `_&6' are removed from the body, because their names\15\nbegin with an underscore.  Also note that `_&4' is optional, unlike the\15\nexplicitly specified `_%3'.\15\n\15\nConsider enabling `llama-fontify-mode' to highlight `##' and its\15\nspecial arguments.\15\n\15\n(fn FN &rest BODY)" nil t) (defvar llama-fontify-mode nil "\15\nNon-nil if Llama-Fontify mode is enabled.\15\nSee the `llama-fontify-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `llama-fontify-mode'.") (autoload 'llama-fontify-mode "llama" "\15\nIn Emacs Lisp mode, highlight the `##' macro and its special arguments.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Llama-Fontify mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='llama-fontify-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/magit-section/magit-section-autoloads.el") (load-true-file-name load-file-name)) (autoload 'magit-add-section-hook "magit-section" "\15\nAdd to the value of section hook HOOK the function FUNCTION.\15\n\15\nAdd FUNCTION at the beginning of the hook list unless optional\15\nAPPEND is non-nil, in which case FUNCTION is added at the end.\15\nIf FUNCTION already is a member, then move it to the new location.\15\n\15\nIf optional AT is non-nil and a member of the hook list, then\15\nadd FUNCTION next to that instead.  Add before or after AT, or\15\nreplace AT with FUNCTION depending on APPEND.  If APPEND is the\15\nsymbol `replace', then replace AT with FUNCTION.  For any other\15\nnon-nil value place FUNCTION right after AT.  If nil, then place\15\nFUNCTION right before AT.  If FUNCTION already is a member of the\15\nlist but AT is not, then leave FUNCTION where ever it already is.\15\n\15\nIf optional LOCAL is non-nil, then modify the hook's buffer-local\15\nvalue rather than its global value.  This makes the hook local by\15\ncopying the default value.  That copy is then modified.\15\n\15\nHOOK should be a symbol.  If HOOK is void, it is first set to nil.\15\nHOOK's value must not be a single hook function.  FUNCTION should\15\nbe a function that takes no arguments and inserts one or multiple\15\nsections at point, moving point forward.  FUNCTION may choose not\15\nto insert its section(s), when doing so would not make sense.  It\15\nshould not be abused for other side-effects.  To remove FUNCTION\15\nagain use `remove-hook'.\15\n\15\n(fn HOOK FUNCTION &optional AT APPEND LOCAL)") (autoload 'magit--handle-bookmark "magit-section" "\15\nOpen a bookmark created by `magit--make-bookmark'.\15\n\15\nCall the generic function `magit-bookmark-get-buffer-create' to get\15\nthe appropriate buffer without displaying it.\15\n\15\nThen call the `magit-*-setup-buffer' function of the the major-mode\15\nwith the variables' values as arguments, which were recorded by\15\n`magit--make-bookmark'.\15\n\15\n(fn BOOKMARK)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/magit/magit-autoloads.el") (load-true-file-name load-file-name)) (put 'git-commit-major-mode 'safe-local-variable (lambda (val) (memq val '(text-mode markdown-mode org-mode fundamental-mode log-edit-mode git-commit-elisp-text-mode)))) (autoload 'git-rebase-current-line "git-rebase" "\15\nParse current line into a `git-rebase-action' instance.\15\nIf the current line isn't recognized as a rebase line, an\15\ninstance with all nil values is returned, unless optional\15\nBATCH is non-nil, in which case nil is returned.  Non-nil\15\nBATCH also ignores commented lines.\15\n\15\n(fn &optional BATCH)") (autoload 'git-rebase-mode "git-rebase" "\15\nMajor mode for editing of a Git rebase file.\15\n\15\nRebase files are generated when you run \"git rebase -i\" or run\15\n`magit-interactive-rebase'.  They describe how Git should perform\15\nthe rebase.  See the documentation for git-rebase (e.g., by\15\nrunning \"man git-rebase\" at the command line) for details.\15\n\15\n(fn)" t) (defconst git-rebase-filename-regexp "/git-rebase-todo\\'") (defvar magit-define-global-key-bindings 'default "\15\nWhich set of key bindings to add to the global keymap, if any.\15\n\15\nThis option controls which set of Magit key bindings, if any, may\15\nbe added to the global keymap, even before Magit is first used in\15\nthe current Emacs session.\15\n\15\nIf the value is nil, no bindings are added.\15\n\15\nIf \\+`default', maybe add:\15\n\15\n    \\`C-x' \\`g'     `magit-status'\15\n    \\`C-x' \\`M-g'   `magit-dispatch'\15\n    \\`C-c' \\`M-g'   `magit-file-dispatch'\15\n\15\nIf `recommended', maybe add:\15\n\15\n    \\`C-x' \\`g'     `magit-status'\15\n    \\`C-c' \\`g'     `magit-dispatch'\15\n    \\`C-c' \\`f'     `magit-file-dispatch'\15\n\15\n    These bindings are strongly recommended, but we cannot use\15\n    them by default, because the \\`C-c <LETTER>' namespace is\15\n    strictly reserved for bindings added by the user.\15\n\15\nThe bindings in the chosen set may be added when\15\n`after-init-hook' is run.  Each binding is added if, and only\15\nif, at that time no other key is bound to the same command,\15\nand no other command is bound to the same key.  In other words\15\nwe try to avoid adding bindings that are unnecessary, as well\15\nas bindings that conflict with other bindings.\15\n\15\nAdding these bindings is delayed until `after-init-hook' is\15\nrun to allow users to set the variable anywhere in their init\15\nfile (without having to make sure to do so before `magit' is\15\nloaded or autoloaded) and to increase the likelihood that all\15\nthe potentially conflicting user bindings have already been\15\nadded.\15\n\15\nTo set this variable use either `setq' or the Custom interface.\15\nDo not use the function `customize-set-variable' because doing\15\nthat would cause Magit to be loaded immediately, when that form\15\nis evaluated (this differs from `custom-set-variables', which\15\ndoesn't load the libraries that define the customized variables).\15\n\15\nSetting this variable has no effect if `after-init-hook' has\15\nalready been run.") (defun magit-maybe-define-global-key-bindings (&optional force) "\15\nSee variable `magit-define-global-key-bindings'." (when magit-define-global-key-bindings (let ((map (current-global-map))) (pcase-dolist (`(,key \, def) (cond ((eq magit-define-global-key-bindings 'recommended) '(("C-x g" . magit-status) ("C-c g" . magit-dispatch) ("C-c f" . magit-file-dispatch))) ('(("C-x g" . magit-status) ("C-x M-g" . magit-dispatch) ("C-c M-g" . magit-file-dispatch))))) (when (or force (not (or (lookup-key map (kbd key)) (where-is-internal def (make-sparse-keymap) t)))) (define-key map (kbd key) def)))))) (if after-init-time (magit-maybe-define-global-key-bindings) (add-hook 'after-init-hook #'magit-maybe-define-global-key-bindings t)) (autoload 'magit-dispatch "magit" nil t) (autoload 'magit-run "magit" nil t) (autoload 'magit-git-command "magit" "\15\nExecute COMMAND asynchronously; display output.\15\n\15\nInteractively, prompt for COMMAND in the minibuffer.  \"git \" is\15\nused as initial input, but can be deleted to run another command.\15\n\15\nWith a prefix argument COMMAND is run in the top-level directory\15\nof the current working tree, otherwise in `default-directory'.\15\n\15\n(fn COMMAND)" t) (autoload 'magit-git-command-topdir "magit" "\15\nExecute COMMAND asynchronously; display output.\15\n\15\nInteractively, prompt for COMMAND in the minibuffer.  \"git \" is\15\nused as initial input, but can be deleted to run another command.\15\n\15\nCOMMAND is run in the top-level directory of the current\15\nworking tree.\15\n\15\n(fn COMMAND)" t) (autoload 'magit-shell-command "magit" "\15\nExecute COMMAND asynchronously; display output.\15\n\15\nInteractively, prompt for COMMAND in the minibuffer.  With a\15\nprefix argument COMMAND is run in the top-level directory of\15\nthe current working tree, otherwise in `default-directory'.\15\n\15\n(fn COMMAND)" t) (autoload 'magit-shell-command-topdir "magit" "\15\nExecute COMMAND asynchronously; display output.\15\n\15\nInteractively, prompt for COMMAND in the minibuffer.  COMMAND\15\nis run in the top-level directory of the current working tree.\15\n\15\n(fn COMMAND)" t) (autoload 'magit-version "magit" "\15\nReturn the version of Magit currently in use.\15\n\15\nIf optional argument PRINT-DEST is non-nil, also print the used\15\nversions of Magit, Transient, Git and Emacs to the output stream\15\nselected by that argument.  Interactively use the echo area, or\15\nwith a prefix argument use the current buffer.  Additionally put\15\nthe output in the kill ring.\15\n\15\n(fn &optional PRINT-DEST)" t) (autoload 'magit-stage-files "magit-apply" "\15\nRead one or more files and stage all changes in those files.\15\nWith prefix argument FORCE, offer ignored files for completion.\15\n\15\n(fn FILES &optional FORCE)" t) (autoload 'magit-stage-modified "magit-apply" "\15\nStage all changes to files modified in the worktree.\15\nStage all new content of tracked files and remove tracked files\15\nthat no longer exist in the working tree from the index also.\15\nWith a prefix argument also stage previously untracked (but not\15\nignored) files.\15\n\15\n(fn &optional ALL)" t) (autoload 'magit-unstage-files "magit-apply" "\15\nRead one or more files and unstage all changes to those files.\15\n\15\n(fn FILES)" t) (autoload 'magit-unstage-all "magit-apply" "\15\nRemove all changes from the staging area." t) (put 'magit-auto-revert-mode 'globalized-minor-mode t) (defvar magit-auto-revert-mode (not (or global-auto-revert-mode noninteractive)) "\15\nNon-nil if Magit-Auto-Revert mode is enabled.\15\nSee the `magit-auto-revert-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `magit-auto-revert-mode'.") (autoload 'magit-auto-revert-mode "magit-autorevert" "\15\nToggle Auto-Revert mode in all buffers.\15\nWith prefix ARG, enable Magit-Auto-Revert mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nAuto-Revert mode is enabled in all buffers where\15\n`magit-turn-on-auto-revert-mode-if-desired' would do it.\15\n\15\nSee `auto-revert-mode' for more information on Auto-Revert mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'magit-emacs-Q-command "magit-base" "\15\nShow a shell command that runs an uncustomized Emacs with only Magit loaded.\15\nSee info node `(magit)Debugging Tools' for more information." t) (define-advice Info-follow-nearest-node (:around (fn &optional fork) gitman) (let ((node (Info-get-token (point) "\\*note[ \15\n\11]+" "\\*note[ \15\n\11]+\\([^:]*\\):\\(:\\|[ \15\n\11]*(\\)?"))) (if (and node (string-match "^(gitman)\\(.+\\)" node)) (pcase magit-view-git-manual-method ('info (funcall fn fork)) ('man (require 'man) (man (match-string 1 node))) ('woman (require 'woman) (woman (match-string 1 node))) (_ (user-error "Invalid value for `magit-view-git-manual-method'"))) (funcall fn fork)))) (define-advice org-man-export (:around (fn link description format) gitman) (if (and (eq format 'texinfo) (string-prefix-p "git" link)) (string-replace "%s" link "\15\n@ifinfo\15\n@ref{%s,,,gitman,}.\15\n@end ifinfo\15\n@ifhtml\15\n@html\15\nthe <a href=\"http://git-scm.com/docs/%s\">%s(1)</a> manpage.\15\n@end html\15\n@end ifhtml\15\n@iftex\15\nthe %s(1) manpage.\15\n@end iftex\15\n") (funcall fn link description format))) (autoload 'magit-bisect "magit-bisect" nil t) (autoload 'magit-bisect-start "magit-bisect" "\15\nStart a bisect session.\15\n\15\nBisecting a bug means to find the commit that introduced it.\15\nThis command starts such a bisect session by asking for a known\15\ngood and a known bad commit.  To move the session forward use the\15\nother actions from the bisect transient command (\\<magit-status-mode-map>\\[magit-bisect]).\15\n\15\n(fn BAD GOOD ARGS)" t) (autoload 'magit-bisect-reset "magit-bisect" "\15\nAfter bisecting, cleanup bisection state and return to original `HEAD'." t) (autoload 'magit-bisect-good "magit-bisect" "\15\nWhile bisecting, mark the current commit as good.\15\nUse this after you have asserted that the commit does not contain\15\nthe bug in question." t) (autoload 'magit-bisect-bad "magit-bisect" "\15\nWhile bisecting, mark the current commit as bad.\15\nUse this after you have asserted that the commit does contain the\15\nbug in question." t) (autoload 'magit-bisect-mark "magit-bisect" "\15\nWhile bisecting, mark the current commit with a bisect term.\15\nDuring a bisect using alternate terms, commits can still be\15\nmarked with `magit-bisect-good' and `magit-bisect-bad', as those\15\ncommands map to the correct term (\"good\" to --term-old's value\15\nand \"bad\" to --term-new's).  However, in some cases, it can be\15\ndifficult to keep that mapping straight in your head; this\15\ncommand provides an interface that exposes the underlying terms." t) (autoload 'magit-bisect-skip "magit-bisect" "\15\nWhile bisecting, skip the current commit.\15\nUse this if for some reason the current commit is not a good one\15\nto test.  This command lets Git choose a different one." t) (autoload 'magit-bisect-run "magit-bisect" "\15\nBisect automatically by running commands after each step.\15\n\15\nUnlike `git bisect run' this can be used before bisecting has\15\nbegun.  In that case it behaves like `git bisect start; git\15\nbisect run'.\15\n\15\n(fn CMDLINE &optional BAD GOOD ARGS)" t) (autoload 'magit-blame-echo "magit-blame" nil t) (autoload 'magit-blame-addition "magit-blame" nil t) (autoload 'magit-blame-removal "magit-blame" nil t) (autoload 'magit-blame-reverse "magit-blame" nil t) (autoload 'magit-blame "magit-blame" nil t) (autoload 'magit-branch "magit" nil t) (autoload 'magit-checkout "magit-branch" "\15\nCheckout REVISION, updating the index and the working tree.\15\nIf REVISION is a local branch, then that becomes the current\15\nbranch.  If it is something else, then `HEAD' becomes detached.\15\nCheckout fails if the working tree or the staging area contain\15\nchanges.\15\n\15\n(git checkout REVISION).\15\n\15\n(fn REVISION &optional ARGS)" t) (function-put 'magit-checkout 'interactive-only 'magit--checkout) (autoload 'magit-branch-create "magit-branch" "\15\nCreate BRANCH at branch or revision START-POINT.\15\n\15\n(fn BRANCH START-POINT)" t) (function-put 'magit-branch-create 'interactive-only 'magit-call-git) (autoload 'magit-branch-and-checkout "magit-branch" "\15\nCreate and checkout BRANCH at branch or revision START-POINT.\15\n\15\n(fn BRANCH START-POINT &optional ARGS)" t) (function-put 'magit-branch-and-checkout 'interactive-only 'magit-call-git) (autoload 'magit-branch-or-checkout "magit-branch" "\15\nHybrid between `magit-checkout' and `magit-branch-and-checkout'.\15\n\15\nAsk the user for an existing branch or revision.  If the user\15\ninput actually can be resolved as a branch or revision, then\15\ncheck that out, just like `magit-checkout' would.\15\n\15\nOtherwise create and checkout a new branch using the input as\15\nits name.  Before doing so read the starting-point for the new\15\nbranch.  This is similar to what `magit-branch-and-checkout'\15\ndoes.\15\n\15\n(fn ARG &optional START-POINT)" t) (function-put 'magit-branch-or-checkout 'interactive-only 'magit-call-git) (autoload 'magit-branch-checkout "magit-branch" "\15\nCheckout an existing or new local branch.\15\n\15\nRead a branch name from the user offering all local branches and\15\na subset of remote branches as candidates.  Omit remote branches\15\nfor which a local branch by the same name exists from the list\15\nof candidates.  The user can also enter a completely new branch\15\nname.\15\n\15\n- If the user selects an existing local branch, then check that\15\n  out.\15\n\15\n- If the user selects a remote branch, then create and checkout\15\n  a new local branch with the same name.  Configure the selected\15\n  remote branch as push target.\15\n\15\n- If the user enters a new branch name, then create and check\15\n  that out, after also reading the starting-point from the user.\15\n\15\nIn the latter two cases the upstream is also set.  Whether it is\15\nset to the chosen START-POINT or something else depends on the\15\nvalue of `magit-branch-adjust-remote-upstream-alist', just like\15\nwhen using `magit-branch-and-checkout'.\15\n\15\n(fn BRANCH &optional START-POINT)" t) (function-put 'magit-branch-checkout 'interactive-only 'magit-call-git) (autoload 'magit-branch-orphan "magit-branch" "\15\nCreate and checkout an orphan BRANCH with contents from revision START-POINT.\15\n\15\n(fn BRANCH START-POINT)" t) (autoload 'magit-branch-spinout "magit-branch" "\15\nCreate new branch from the unpushed commits.\15\nLike `magit-branch-spinoff' but remain on the current branch.\15\nIf there are any uncommitted changes, then behave exactly like\15\n`magit-branch-spinoff'.\15\n\15\n(fn BRANCH &optional FROM)" t) (autoload 'magit-branch-spinoff "magit-branch" "\15\nCreate new branch from the unpushed commits.\15\n\15\nCreate and checkout a new branch starting at and tracking the\15\ncurrent branch.  That branch in turn is reset to the last commit\15\nit shares with its upstream.  If the current branch has no\15\nupstream or no unpushed commits, then the new branch is created\15\nanyway and the previously current branch is not touched.\15\n\15\nThis is useful to create a feature branch after work has already\15\nbegan on the old branch (likely but not necessarily \"master\").\15\n\15\nIf the current branch is a member of the value of option\15\n`magit-branch-prefer-remote-upstream' (which see), then the\15\ncurrent branch will be used as the starting point as usual, but\15\nthe upstream of the starting-point may be used as the upstream\15\nof the new branch, instead of the starting-point itself.\15\n\15\nIf optional FROM is non-nil, then the source branch is reset\15\nto `FROM~', instead of to the last commit it shares with its\15\nupstream.  Interactively, FROM is only ever non-nil, if the\15\nregion selects some commits, and among those commits, FROM is\15\nthe commit that is the fewest commits ahead of the source\15\nbranch.\15\n\15\nThe commit at the other end of the selection actually does not\15\nmatter, all commits between FROM and `HEAD' are moved to the new\15\nbranch.  If FROM is not reachable from `HEAD' or is reachable\15\nfrom the source branch's upstream, then an error is raised.\15\n\15\n(fn BRANCH &optional FROM)" t) (autoload 'magit-branch-reset "magit-branch" "\15\nReset a branch to the tip of another branch or any other commit.\15\n\15\nWhen the branch being reset is the current branch, then do a\15\nhard reset.  If there are any uncommitted changes, then the user\15\nhas to confirm the reset because those changes would be lost.\15\n\15\nThis is useful when you have started work on a feature branch but\15\nrealize it's all crap and want to start over.\15\n\15\nWhen resetting to another branch and a prefix argument is used,\15\nthen also set the target branch as the upstream of the branch\15\nthat is being reset.\15\n\15\n(fn BRANCH TO &optional SET-UPSTREAM)" t) (autoload 'magit-branch-delete "magit-branch" "\15\nDelete one or multiple branches.\15\n\15\nIf the region marks multiple branches, then offer to delete\15\nthose, otherwise prompt for a single branch to be deleted,\15\ndefaulting to the branch at point.\15\n\15\nRequire confirmation when deleting branches is dangerous in some\15\nway.  Option `magit-no-confirm' can be customized to not require\15\nconfirmation in certain cases.  See its docstring to learn why\15\nconfirmation is required by default in certain cases or if a\15\nprompt is confusing.\15\n\15\n(fn BRANCHES &optional FORCE)" t) (autoload 'magit-branch-rename "magit-branch" "\15\nRename the branch named OLD to NEW.\15\n\15\nWith a prefix argument FORCE, rename even if a branch named NEW\15\nalready exists.\15\n\15\nIf `branch.OLD.pushRemote' is set, then unset it.  Depending on\15\nthe value of `magit-branch-rename-push-target' (which see) maybe\15\nset `branch.NEW.pushRemote' and maybe rename the push-target on\15\nthe remote.\15\n\15\n(fn OLD NEW &optional FORCE)" t) (autoload 'magit-branch-shelve "magit-branch" "\15\nShelve a BRANCH.\15\nRename \"refs/heads/BRANCH\" to \"refs/shelved/YYYY-MM-DD-BRANCH\",\15\nand also rename the respective reflog file.\15\n\15\n(fn BRANCH)" t) (autoload 'magit-branch-unshelve "magit-branch" "\15\nUnshelve a BRANCH.\15\nRename \"refs/shelved/BRANCH\" to \"refs/heads/BRANCH\".  If BRANCH\15\nis prefixed with \"YYYY-MM-DD\", then drop that part of the name.\15\nAlso rename the respective reflog file.\15\n\15\n(fn BRANCH)" t) (autoload 'magit-branch-configure "magit-branch" nil t) (autoload 'magit-bundle "magit-bundle" nil t) (autoload 'magit-bundle-import "magit-bundle" nil t) (autoload 'magit-bundle-create-tracked "magit-bundle" "\15\nCreate and track a new bundle.\15\n\15\n(fn FILE TAG BRANCH REFS ARGS)" t) (autoload 'magit-bundle-update-tracked "magit-bundle" "\15\nUpdate a bundle that is being tracked using TAG.\15\n\15\n(fn TAG)" t) (autoload 'magit-bundle-verify "magit-bundle" "\15\nCheck whether FILE is valid and applies to the current repository.\15\n\15\n(fn FILE)" t) (autoload 'magit-bundle-list-heads "magit-bundle" "\15\nList the refs in FILE.\15\n\15\n(fn FILE)" t) (autoload 'magit-clone "magit-clone" nil t) (autoload 'magit-clone-regular "magit-clone" "\15\nCreate a clone of REPOSITORY in DIRECTORY.\15\nThen show the status buffer for the new repository.\15\n\15\n(fn REPOSITORY DIRECTORY ARGS)" t) (autoload 'magit-clone-shallow "magit-clone" "\15\nCreate a shallow clone of REPOSITORY in DIRECTORY.\15\nThen show the status buffer for the new repository.\15\nWith a prefix argument read the DEPTH of the clone;\15\notherwise use 1.\15\n\15\n(fn REPOSITORY DIRECTORY ARGS DEPTH)" t) (autoload 'magit-clone-shallow-since "magit-clone" "\15\nCreate a shallow clone of REPOSITORY in DIRECTORY.\15\nThen show the status buffer for the new repository.\15\nExclude commits before DATE, which is read from the\15\nuser.\15\n\15\n(fn REPOSITORY DIRECTORY ARGS DATE)" t) (autoload 'magit-clone-shallow-exclude "magit-clone" "\15\nCreate a shallow clone of REPOSITORY in DIRECTORY.\15\nThen show the status buffer for the new repository.\15\nExclude commits reachable from EXCLUDE, which is a\15\nbranch or tag read from the user.\15\n\15\n(fn REPOSITORY DIRECTORY ARGS EXCLUDE)" t) (autoload 'magit-clone-bare "magit-clone" "\15\nCreate a bare clone of REPOSITORY in DIRECTORY.\15\nThen show the status buffer for the new repository.\15\n\15\n(fn REPOSITORY DIRECTORY ARGS)" t) (autoload 'magit-clone-mirror "magit-clone" "\15\nCreate a mirror of REPOSITORY in DIRECTORY.\15\nThen show the status buffer for the new repository.\15\n\15\n(fn REPOSITORY DIRECTORY ARGS)" t) (autoload 'magit-clone-sparse "magit-clone" "\15\nClone REPOSITORY into DIRECTORY and create a sparse checkout.\15\n\15\n(fn REPOSITORY DIRECTORY ARGS)" t) (autoload 'magit-commit "magit-commit" nil t) (autoload 'magit-commit-create "magit-commit" "\15\nCreate a new commit.\15\n\15\n(fn &optional ARGS)" t) (autoload 'magit-commit-extend "magit-commit" "\15\nAmend staged changes to the last commit, without editing its message.\15\n\15\nWith a prefix argument do not update the committer date; without an\15\nargument update it.  The option `magit-commit-extend-override-date'\15\ncan be used to inverse the meaning of the prefix argument.  Called\15\nnon-interactively, the optional OVERRIDE-DATE argument controls this\15\nbehavior, and the option is of no relevance.\15\n\15\n(fn &optional ARGS OVERRIDE-DATE)" t) (autoload 'magit-commit-amend "magit-commit" "\15\nAmend staged changes (if any) to the last commit, and edit its message.\15\n\15\n(fn &optional ARGS)" t) (autoload 'magit-commit-reword "magit-commit" "\15\nReword the message of the last commit, without amending its tree.\15\n\15\nWith a prefix argument do not update the committer date; without an\15\nargument update it.  The option `magit-commit-reword-override-date'\15\ncan be used to inverse the meaning of the prefix argument.  Called\15\nnon-interactively, the optional OVERRIDE-DATE argument controls this\15\nbehavior, and the option is of no relevance.\15\n\15\n(fn &optional ARGS OVERRIDE-DATE)" t) (autoload 'magit-commit-fixup "magit-commit" "\15\nCreate a fixup commit, leaving the original commit message untouched.\15\n\15\nIf there is a reachable commit at point, target that.  Otherwise prompt\15\nfor a commit.  If `magit-commit-squash-confirm' is non-nil, always make\15\nthe user explicitly select a commit, in a buffer dedicated to that task.\15\n\15\nDuring a later rebase, when this commit gets squashed into its targeted\15\ncommit, the original message of the targeted commit is used as-is.\15\n\15\nIn other words, call \"git commit --fixup=COMMIT --no-edit\".\15\n\15\n(fn &optional COMMIT ARGS)" t) (autoload 'magit-commit-squash "magit-commit" "\15\nCreate a squash commit, without the user authoring a commit message.\15\n\15\nIf there is a reachable commit at point, target that.  Otherwise prompt\15\nfor a commit.  If `magit-commit-squash-confirm' is non-nil, always make\15\nthe user explicitly select a commit, in a buffer dedicated to that task.\15\n\15\nDuring a later rebase, when this commit gets squashed into its targeted\15\ncommit, the user is given a chance to edit the original message to take\15\nthe changes from the squash commit into account.\15\n\15\nIn other words, call \"git commit --squash=COMMIT --no-edit\".\15\n\15\n(fn &optional COMMIT ARGS)" t) (autoload 'magit-commit-alter "magit-commit" "\15\nCreate a squash commit, authoring the final commit message now.\15\n\15\nIf there is a reachable commit at point, target that.  Otherwise prompt\15\nfor a commit.  If `magit-commit-squash-confirm' is non-nil, always make\15\nthe user explicitly select a commit, in a buffer dedicated to that task.\15\n\15\nDuring a later rebase, when this commit gets squashed into its targeted\15\ncommit, the original message of the targeted commit is replaced with the\15\nmessage of this commit, without the user automatically being given a\15\nchance to edit again.\15\n\15\nIn other words, call \"git commit --fixup=amend:COMMIT --edit\".\15\n\15\n(fn &optional COMMIT ARGS)" t) (autoload 'magit-commit-augment "magit-commit" "\15\nCreate a squash commit, authoring a new temporary commit message.\15\n\15\nIf there is a reachable commit at point, target that.  Otherwise prompt\15\nfor a commit.  If `magit-commit-squash-confirm' is non-nil, always make\15\nthe user explicitly select a commit, in a buffer dedicated to that task.\15\n\15\nDuring a later rebase, when this commit gets squashed into its targeted\15\ncommit, the user is asked to write a final commit message, in a buffer\15\nthat starts out containing both the original commit message, as well as\15\nthe temporary commit message of the squash commit.\15\n\15\nIn other words, call \"git commit --squash=COMMIT --edit\".\15\n\15\n(fn &optional COMMIT ARGS)" t) (autoload 'magit-commit-revise "magit-commit" "\15\nReword the message of an existing commit, without editing its tree.\15\n\15\nIf there is a reachable commit at point, target that.  Otherwise prompt\15\nfor a commit.  If `magit-commit-squash-confirm' is non-nil, always make\15\nthe user explicitly select a commit, in a buffer dedicated to that task.\15\n\15\nDuring a later rebase, when this commit gets squashed into its targeted\15\ncommit, a combined commit is created which uses the message of the fixup\15\ncommit and the tree of the targeted commit.\15\n\15\nIn other words, call \"git commit --fixup=reword:COMMIT --edit\".\15\n\15\n(fn &optional COMMIT ARGS)" t) (autoload 'magit-commit-instant-fixup "magit-commit" "\15\nCreate a fixup commit, and immediately combine it with its target.\15\n\15\nIf there is a reachable commit at point, target that.  Otherwise prompt\15\nfor a commit.  If `magit-commit-squash-confirm' is non-nil, always make\15\nthe user explicitly select a commit, in a buffer dedicated to that task.\15\n\15\nLeave the original commit message of the targeted commit untouched.\15\n\15\nLike `magit-commit-fixup' but also run a `--autofixup' rebase.\15\n\15\n(fn &optional COMMIT ARGS)" t) (autoload 'magit-commit-instant-squash "magit-commit" "\15\nCreate a squash commit, and immediately combine it with its target.\15\n\15\nIf there is a reachable commit at point, target that.  Otherwise prompt\15\nfor a commit.  If `magit-commit-squash-confirm' is non-nil, always make\15\nthe user explicitly select a commit, in a buffer dedicated to that task.\15\n\15\nTuring the rebase phase, when the two commits are being squashed, ask\15\nthe user to author the final commit message, based on the original\15\nmessage of the targeted commit.\15\n\15\nLike `magit-commit-squash' but also run a `--autofixup' rebase.\15\n\15\n(fn &optional COMMIT ARGS)" t) (autoload 'magit-commit-reshelve "magit-commit" "\15\nChange committer (and possibly author) date of the last commit.\15\n\15\nThe current time is used as the initial minibuffer input and the\15\noriginal author or committer date is available as the previous\15\nhistory element.\15\n\15\nBoth the author and the committer dates are changed, unless one\15\nof the following is true, in which case only the committer date\15\nis updated:\15\n- You are not the author of the commit that is being reshelved.\15\n- The command was invoked with a prefix argument.\15\n- Non-interactively if UPDATE-AUTHOR is nil.\15\n\15\n(fn DATE UPDATE-AUTHOR &optional ARGS)" t) (autoload 'magit-commit-absorb-modules "magit-commit" "\15\nSpread modified modules across recent commits.\15\n\15\n(fn PHASE COMMIT)" t) (autoload 'magit-commit-absorb "magit-commit" nil t) (autoload 'magit-commit-autofixup "magit-commit" nil t) (autoload 'magit-diff "magit-diff" nil t) (autoload 'magit-diff-refresh "magit-diff" nil t) (autoload 'magit-diff-dwim "magit-diff" "\15\nShow changes for the thing at point.\15\n\15\nFor example, if point is on a commit, show the changes introduced by\15\nthat commit.  Likewise if point is on the section titled \"Unstaged\15\nchanges\", then show those changes in a separate buffer.  Generally\15\nspeaking, compare the thing at point with the most logical, trivial\15\nand (in *any* situation) at least potentially useful other thing it\15\ncould be compared to.\15\n\15\nWhen the region selects commits, then compare the two commits at\15\neither end.  There are different ways two commits can be compared.\15\nIn the buffer showing the diff, you can control how the comparison,\15\nis done, using \"D r\" and \"D f\".\15\n\15\nThis function does not always show the changes that you might want\15\nto view in any given situation.  You can think of the changes being\15\nshown as the smallest common denominator.  There is no AI involved.\15\nIf this command never does what you want, then ignore it, and instead\15\nuse the commands that allow you to explicitly specify what you need.\15\n\15\n(fn &optional ARGS FILES)" t) (autoload 'magit-diff-range "magit-diff" "\15\nShow differences between two commits.\15\n\15\nREV-OR-RANGE should be a range or a single revision.  If it is a\15\nrevision, then show changes in the working tree relative to that\15\nrevision.  If it is a range, but one side is omitted, then show\15\nchanges relative to `HEAD'.\15\n\15\nIf the region is active, use the revisions on the first and last\15\nline of the region as the two sides of the range.  With a prefix\15\nargument, instead of diffing the revisions, choose a revision to\15\nview changes along, starting at the common ancestor of both\15\nrevisions (i.e., use a \"...\" range).\15\n\15\n(fn REV-OR-RANGE &optional ARGS FILES)" t) (autoload 'magit-diff-working-tree "magit-diff" "\15\nShow changes between the current working tree and the `HEAD' commit.\15\nWith a prefix argument show changes between the working tree and\15\na commit read from the minibuffer.\15\n\15\n(fn &optional REV ARGS FILES)" t) (autoload 'magit-diff-staged "magit-diff" "\15\nShow changes between the index and the `HEAD' commit.\15\nWith a prefix argument show changes between the index and\15\na commit read from the minibuffer.\15\n\15\n(fn &optional REV ARGS FILES)" t) (autoload 'magit-diff-unstaged "magit-diff" "\15\nShow changes between the working tree and the index.\15\n\15\n(fn &optional ARGS FILES)" t) (autoload 'magit-diff-unmerged "magit-diff" "\15\nShow changes that are being merged.\15\n\15\n(fn &optional ARGS FILES)" t) (autoload 'magit-diff-while-committing "magit-diff" "\15\nWhile committing, show the changes that are about to be committed.\15\nWhile amending, invoking the command again toggles between\15\nshowing just the new changes or all the changes that will\15\nbe committed." t) (autoload 'magit-diff-buffer-file "magit-diff" "\15\nShow diff for the blob or file visited in the current buffer.\15\n\15\nWhen the buffer visits a blob, then show the respective commit.\15\nWhen the buffer visits a file, then show the differences between\15\n`HEAD' and the working tree.  In both cases limit the diff to\15\nthe file or blob." t) (autoload 'magit-diff-paths "magit-diff" "\15\nShow changes between any two files on disk.\15\n\15\n(fn A B)" t) (autoload 'magit-show-commit "magit-diff" "\15\nVisit the revision at point in another buffer.\15\nIf there is no revision at point or with a prefix argument prompt\15\nfor a revision.\15\n\15\n(fn REV &optional ARGS FILES MODULE)" t) (autoload 'magit-dired-jump "magit-dired" "\15\nVisit file at point using Dired.\15\nWith a prefix argument, visit in another window.  If there\15\nis no file at point, then instead visit `default-directory'.\15\n\15\n(fn &optional OTHER-WINDOW)" t) (autoload 'magit-dired-stage "magit-dired" "\15\nIn Dired, staged all marked files or the file at point." t) (autoload 'magit-dired-unstage "magit-dired" "\15\nIn Dired, unstaged all marked files or the file at point." t) (autoload 'magit-dired-log "magit-dired" "\15\nIn Dired, show log for all marked files or the directory if none are marked.\15\n\15\n(fn &optional FOLLOW)" t) (autoload 'magit-dired-am-apply-patches "magit-dired" "\15\nIn Dired, apply the marked (or next ARG) files as patches.\15\nIf inside a repository, then apply in that.  Otherwise prompt\15\nfor a repository.\15\n\15\n(fn REPO &optional ARG)" t) (autoload 'magit-do-async-shell-command "magit-dired" "\15\nOpen FILE with `dired-do-async-shell-command'.\15\nInteractively, open the file at point.\15\n\15\n(fn FILE)" t) (autoload 'magit-ediff "magit-ediff" nil) (autoload 'magit-ediff-resolve-all "magit-ediff" "\15\nResolve all conflicts in the FILE at point using Ediff.\15\n\15\nIf there is no file at point or if it doesn't have any unmerged\15\nchanges, then prompt for a file.\15\n\15\nSee info node `(magit) Ediffing' for more information about this\15\nand alternative commands.\15\n\15\n(fn FILE)" t) (autoload 'magit-ediff-resolve-rest "magit-ediff" "\15\nResolve outstanding conflicts in the FILE at point using Ediff.\15\n\15\nIf there is no file at point or if it doesn't have any unmerged\15\nchanges, then prompt for a file.\15\n\15\nSee info node `(magit) Ediffing' for more information about this\15\nand alternative commands.\15\n\15\n(fn FILE)" t) (autoload 'magit-ediff-stage "magit-ediff" "\15\nStage and unstage changes to FILE using Ediff.\15\nFILE has to be relative to the top directory of the repository.\15\n\15\n(fn FILE)" t) (autoload 'magit-ediff-compare "magit-ediff" "\15\nCompare REVA:FILEA with REVB:FILEB using Ediff.\15\n\15\nFILEA and FILEB have to be relative to the top directory of the\15\nrepository.  If REVA or REVB is nil, then this stands for the\15\nworking tree state.\15\n\15\nIf the region is active, use the revisions on the first and last\15\nline of the region.  With a prefix argument, instead of diffing\15\nthe revisions, choose a revision to view changes along, starting\15\nat the common ancestor of both revisions (i.e., use a \"...\"\15\nrange).\15\n\15\n(fn REVA REVB FILEA FILEB)" t) (autoload 'magit-ediff-dwim "magit-ediff" "\15\nCompare, stage, or resolve using Ediff.\15\nThis command tries to guess what file, and what commit or range\15\nthe user wants to compare, stage, or resolve using Ediff.  It\15\nmight only be able to guess either the file, or range or commit,\15\nin which case the user is asked about the other.  It might not\15\nalways guess right, in which case the appropriate `magit-ediff-*'\15\ncommand has to be used explicitly.  If it cannot read the user's\15\nmind at all, then it asks the user for a command to run." t) (autoload 'magit-ediff-show-staged "magit-ediff" "\15\nShow staged changes using Ediff.\15\n\15\nThis only allows looking at the changes; to stage, unstage,\15\nand discard changes using Ediff, use `magit-ediff-stage'.\15\n\15\nFILE must be relative to the top directory of the repository.\15\n\15\n(fn FILE)" t) (autoload 'magit-ediff-show-unstaged "magit-ediff" "\15\nShow unstaged changes using Ediff.\15\n\15\nThis only allows looking at the changes; to stage, unstage,\15\nand discard changes using Ediff, use `magit-ediff-stage'.\15\n\15\nFILE must be relative to the top directory of the repository.\15\n\15\n(fn FILE)" t) (autoload 'magit-ediff-show-working-tree "magit-ediff" "\15\nShow changes between `HEAD' and working tree using Ediff.\15\nFILE must be relative to the top directory of the repository.\15\n\15\n(fn FILE)" t) (autoload 'magit-ediff-show-commit "magit-ediff" "\15\nShow changes introduced by COMMIT using Ediff.\15\n\15\n(fn COMMIT)" t) (autoload 'magit-ediff-show-stash "magit-ediff" "\15\nShow changes introduced by STASH using Ediff.\15\n`magit-ediff-show-stash-with-index' controls whether a\15\nthree-buffer Ediff is used in order to distinguish changes in the\15\nstash that were staged.\15\n\15\n(fn STASH)" t) (autoload 'magit-git-mergetool "magit-extras" nil t) (autoload 'magit-run-git-gui-blame "magit-extras" "\15\nRun `git gui blame' on the given FILENAME and COMMIT.\15\nInteractively run it for the current file and the `HEAD', with a\15\nprefix or when the current file cannot be determined let the user\15\nchoose.  When the current buffer is visiting FILENAME instruct\15\nblame to center around the line point is on.\15\n\15\n(fn COMMIT FILENAME &optional LINENUM)" t) (autoload 'magit-run-git-gui "magit-extras" "\15\nRun `git gui' for the current git repository." t) (autoload 'magit-run-gitk "magit-extras" "\15\nRun `gitk' in the current repository." t) (autoload 'magit-run-gitk-branches "magit-extras" "\15\nRun `gitk --branches' in the current repository." t) (autoload 'magit-run-gitk-all "magit-extras" "\15\nRun `gitk --all' in the current repository." t) (autoload 'magit-project-status "magit-extras" "\15\nRun `magit-status' in the current project's root." t) (autoload 'magit-previous-line "magit-extras" "\15\nLike `previous-line' but with Magit-specific shift-selection.\15\n\15\nMagit's selection mechanism is based on the region but selects an\15\narea that is larger than the region.  This causes `previous-line'\15\nwhen invoked while holding the shift key to move up one line and\15\nthereby select two lines.  When invoked inside a hunk body this\15\ncommand does not move point on the first invocation and thereby\15\nit only selects a single line.  Which inconsistency you prefer\15\nis a matter of preference.\15\n\15\n(fn &optional ARG TRY-VSCROLL)" t) (function-put 'magit-previous-line 'interactive-only '"use `forward-line' with negative argument instead.") (autoload 'magit-next-line "magit-extras" "\15\nLike `next-line' but with Magit-specific shift-selection.\15\n\15\nMagit's selection mechanism is based on the region but selects\15\nan area that is larger than the region.  This causes `next-line'\15\nwhen invoked while holding the shift key to move down one line\15\nand thereby select two lines.  When invoked inside a hunk body\15\nthis command does not move point on the first invocation and\15\nthereby it only selects a single line.  Which inconsistency you\15\nprefer is a matter of preference.\15\n\15\n(fn &optional ARG TRY-VSCROLL)" t) (function-put 'magit-next-line 'interactive-only 'forward-line) (autoload 'magit-clean "magit-extras" "\15\nRemove untracked files from the working tree.\15\nWith a prefix argument also remove ignored files,\15\nwith two prefix arguments remove ignored files only.\15\n\15\n(git clean -f -d [-x|-X])\15\n\15\n(fn &optional ARG)" t) (autoload 'magit-generate-changelog "magit-extras" "\15\nInsert ChangeLog entries into the current buffer.\15\n\15\nThe entries are generated from the diff being committed.\15\nIf prefix argument, AMENDING, is non-nil, include changes\15\nin HEAD as well as staged changes in the diff to check.\15\n\15\n(fn &optional AMENDING)" t) (autoload 'magit-add-change-log-entry "magit-extras" "\15\nFind change log file and add date entry and item for current change.\15\nThis differs from `add-change-log-entry' (which see) in that\15\nit acts on the current hunk in a Magit buffer instead of on\15\na position in a file-visiting buffer.\15\n\15\n(fn &optional WHOAMI FILE-NAME OTHER-WINDOW)" t) (autoload 'magit-add-change-log-entry-other-window "magit-extras" "\15\nFind change log file in other window and add entry and item.\15\nThis differs from `add-change-log-entry-other-window' (which see)\15\nin that it acts on the current hunk in a Magit buffer instead of\15\non a position in a file-visiting buffer.\15\n\15\n(fn &optional WHOAMI FILE-NAME)" t) (autoload 'magit-edit-line-commit "magit-extras" "\15\nEdit the commit that added the current line.\15\n\15\nWith a prefix argument edit the commit that removes the line,\15\nif any.  The commit is determined using `git blame' and made\15\neditable using `git rebase --interactive' if it is reachable\15\nfrom `HEAD', or by checking out the commit (or a branch that\15\npoints at it) otherwise.\15\n\15\n(fn &optional TYPE)" t) (autoload 'magit-diff-edit-hunk-commit "magit-extras" "\15\nFrom a hunk, edit the respective commit and visit the file.\15\n\15\nFirst visit the file being modified by the hunk at the correct\15\nlocation using `magit-diff-visit-file'.  This actually visits a\15\nblob.  When point is on a diff header, not within an individual\15\nhunk, then this visits the blob the first hunk is about.\15\n\15\nThen invoke `magit-edit-line-commit', which uses an interactive\15\nrebase to make the commit editable, or if that is not possible\15\nbecause the commit is not reachable from `HEAD' by checking out\15\nthat commit directly.  This also causes the actual worktree file\15\nto be visited.\15\n\15\nNeither the blob nor the file buffer are killed when finishing\15\nthe rebase.  If that is undesirable, then it might be better to\15\nuse `magit-rebase-edit-commit' instead of this command.\15\n\15\n(fn FILE)" t) (autoload 'magit-reshelve-since "magit-extras" "\15\nChange the author and committer dates of the commits since REV.\15\n\15\nAsk the user for the first reachable commit whose dates should\15\nbe changed.  Then read the new date for that commit.  The initial\15\nminibuffer input and the previous history element offer good\15\nvalues.  The next commit will be created one minute later and so\15\non.\15\n\15\nThis command is only intended for interactive use and should only\15\nbe used on highly rearranged and unpublished history.\15\n\15\nIf KEYID is non-nil, then use that to sign all reshelved commits.\15\nInteractively use the value of the \"--gpg-sign\" option in the\15\nlist returned by `magit-rebase-arguments'.\15\n\15\n(fn REV KEYID)" t) (autoload 'magit-pop-revision-stack "magit-extras" "\15\nInsert a representation of a revision into the current buffer.\15\n\15\nPop a revision from the `magit-revision-stack' and insert it into\15\nthe current buffer according to `magit-pop-revision-stack-format'.\15\nRevisions can be put on the stack using `magit-copy-section-value'\15\nand `magit-copy-buffer-revision'.\15\n\15\nIf the stack is empty or with a prefix argument, instead read a\15\nrevision in the minibuffer.  By using the minibuffer history this\15\nallows selecting an item which was popped earlier or to insert an\15\narbitrary reference or revision without first pushing it onto the\15\nstack.\15\n\15\nWhen reading the revision from the minibuffer, then it might not\15\nbe possible to guess the correct repository.  When this command\15\nis called inside a repository (e.g., while composing a commit\15\nmessage), then that repository is used.  Otherwise (e.g., while\15\ncomposing an email) then the repository recorded for the top\15\nelement of the stack is used (even though we insert another\15\nrevision).  If not called inside a repository and with an empty\15\nstack, or with two prefix arguments, then read the repository in\15\nthe minibuffer too.\15\n\15\n(fn REV TOPLEVEL)" t) (autoload 'magit-copy-section-value "magit-extras" "\15\nSave the value of the current section for later use.\15\n\15\nSave the section value to the `kill-ring', and, provided that\15\nthe current section is a commit, branch, or tag section, push\15\nthe (referenced) revision to the `magit-revision-stack' for use\15\nwith `magit-pop-revision-stack'.\15\n\15\nWhen `magit-copy-revision-abbreviated' is non-nil, save the\15\nabbreviated revision to the `kill-ring' and the\15\n`magit-revision-stack'.\15\n\15\nWhen the current section is a branch or a tag, and a prefix\15\nargument is used, then save the revision at its tip to the\15\n`kill-ring' instead of the reference name.\15\n\15\nWhen the region is active, then save that to the `kill-ring',\15\nlike `kill-ring-save' would, instead of behaving as described\15\nabove.  If a prefix argument is used and the region is within\15\na hunk, then strip the diff marker column and keep only either\15\nthe added or removed lines, depending on the sign of the prefix\15\nargument.\15\n\15\n(fn ARG)" t) (autoload 'magit-copy-buffer-revision "magit-extras" "\15\nSave the revision of the current buffer for later use.\15\n\15\nSave the revision shown in the current buffer to the `kill-ring'\15\nand push it to the `magit-revision-stack'.\15\n\15\nThis command is mainly intended for use in `magit-revision-mode'\15\nbuffers, the only buffers where it is always unambiguous exactly\15\nwhich revision should be saved.\15\n\15\nMost other Magit buffers usually show more than one revision, in\15\nsome way or another, so this command has to select one of them,\15\nand that choice might not always be the one you think would have\15\nbeen the best pick.\15\n\15\nIn such buffers it is often more useful to save the value of\15\nthe current section instead, using `magit-copy-section-value'.\15\n\15\nWhen the region is active, then save that to the `kill-ring',\15\nlike `kill-ring-save' would, instead of behaving as described\15\nabove.\15\n\15\nWhen `magit-copy-revision-abbreviated' is non-nil, save the\15\nabbreviated revision to the `kill-ring' and the\15\n`magit-revision-stack'." t) (autoload 'magit-display-repository-buffer "magit-extras" "\15\nDisplay a Magit buffer belonging to the current Git repository.\15\nThe buffer is displayed using `magit-display-buffer', which see.\15\n\15\n(fn BUFFER)" t) (autoload 'magit-switch-to-repository-buffer "magit-extras" "\15\nSwitch to a Magit buffer belonging to the current Git repository.\15\n\15\n(fn BUFFER)" t) (autoload 'magit-switch-to-repository-buffer-other-window "magit-extras" "\15\nSwitch to a Magit buffer belonging to the current Git repository.\15\n\15\n(fn BUFFER)" t) (autoload 'magit-switch-to-repository-buffer-other-frame "magit-extras" "\15\nSwitch to a Magit buffer belonging to the current Git repository.\15\n\15\n(fn BUFFER)" t) (autoload 'magit-abort-dwim "magit-extras" "\15\nAbort current operation.\15\nDepending on the context, this will abort a merge, a rebase, a\15\npatch application, a cherry-pick, a revert, or a bisect." t) (autoload 'magit-back-to-indentation "magit-extras" "\15\nMove point to the first non-whitespace character on this line.\15\nIn Magit diffs, also skip over - and + at the beginning of the line." t) (autoload 'magit-fetch "magit-fetch" nil t) (autoload 'magit-fetch-from-pushremote "magit-fetch" nil t) (autoload 'magit-fetch-from-upstream "magit-fetch" nil t) (autoload 'magit-fetch-other "magit-fetch" "\15\nFetch from another repository.\15\n\15\n(fn REMOTE ARGS)" t) (autoload 'magit-fetch-branch "magit-fetch" "\15\nFetch a BRANCH from a REMOTE.\15\n\15\n(fn REMOTE BRANCH ARGS)" t) (autoload 'magit-fetch-refspec "magit-fetch" "\15\nFetch a REFSPEC from a REMOTE.\15\n\15\n(fn REMOTE REFSPEC ARGS)" t) (autoload 'magit-fetch-all "magit-fetch" "\15\nFetch from all remotes.\15\n\15\n(fn ARGS)" t) (autoload 'magit-fetch-all-prune "magit-fetch" "\15\nFetch from all remotes, and prune.\15\nPrune remote tracking branches for branches that have been\15\nremoved on the respective remote." t) (autoload 'magit-fetch-all-no-prune "magit-fetch" "\15\nFetch from all remotes." t) (autoload 'magit-fetch-modules "magit-fetch" nil t) (autoload 'magit-find-file "magit-files" "\15\nView FILE from REV.\15\nSwitch to a buffer visiting blob REV:FILE, creating one if none\15\nalready exists.  If prior to calling this command the current\15\nbuffer and/or cursor position is about the same file, then go\15\nto the line and column corresponding to that location.\15\n\15\n(fn REV FILE)" t) (autoload 'magit-find-file-other-window "magit-files" "\15\nView FILE from REV, in another window.\15\nSwitch to a buffer visiting blob REV:FILE, creating one if none\15\nalready exists.  If prior to calling this command the current\15\nbuffer and/or cursor position is about the same file, then go to\15\nthe line and column corresponding to that location.\15\n\15\n(fn REV FILE)" t) (autoload 'magit-find-file-other-frame "magit-files" "\15\nView FILE from REV, in another frame.\15\nSwitch to a buffer visiting blob REV:FILE, creating one if none\15\nalready exists.  If prior to calling this command the current\15\nbuffer and/or cursor position is about the same file, then go to\15\nthe line and column corresponding to that location.\15\n\15\n(fn REV FILE)" t) (autoload 'magit-file-dispatch "magit" nil t) (autoload 'magit-blob-visit-file "magit-files" "\15\nView the file from the worktree corresponding to the current blob.\15\nWhen visiting a blob or the version from the index, then go to\15\nthe same location in the respective file in the working tree." t) (autoload 'magit-file-stage "magit-files" "\15\nStage all changes to the file being visited in the current buffer." t) (autoload 'magit-file-unstage "magit-files" "\15\nUnstage all changes to the file being visited in the current buffer." t) (autoload 'magit-file-untrack "magit-files" "\15\nUntrack the selected FILES or one file read in the minibuffer.\15\n\15\nWith a prefix argument FORCE do so even when the files have\15\nstaged as well as unstaged changes.\15\n\15\n(fn FILES &optional FORCE)" t) (autoload 'magit-file-rename "magit-files" "\15\nRename or move FILE to NEWNAME.\15\nNEWNAME may be a file or directory name.  If FILE isn't tracked in\15\nGit, fallback to using `rename-file'.\15\n\15\n(fn FILE NEWNAME)" t) (autoload 'magit-file-delete "magit-files" "\15\nDelete the selected FILES or one file read in the minibuffer.\15\n\15\nWith a prefix argument FORCE do so even when the files have\15\nuncommitted changes.  When the files aren't being tracked in\15\nGit, then fallback to using `delete-file'.\15\n\15\n(fn FILES &optional FORCE)" t) (autoload 'magit-file-checkout "magit-files" "\15\nCheckout FILE from REV.\15\n\15\n(fn REV FILE)" t) (autoload 'magit-gitignore "magit-gitignore" nil t) (autoload 'magit-gitignore-in-topdir "magit-gitignore" "\15\nAdd the Git ignore RULE to the top-level \".gitignore\" file.\15\nSince this file is tracked, it is shared with other clones of the\15\nrepository.  Also stage the file.\15\n\15\n(fn RULE)" t) (autoload 'magit-gitignore-in-subdir "magit-gitignore" "\15\nAdd the Git ignore RULE to a \".gitignore\" file in DIRECTORY.\15\nPrompt the user for a directory and add the rule to the\15\n\".gitignore\" file in that directory.  Since such files are\15\ntracked, they are shared with other clones of the repository.\15\nAlso stage the file.\15\n\15\n(fn RULE DIRECTORY)" t) (autoload 'magit-gitignore-in-gitdir "magit-gitignore" "\15\nAdd the Git ignore RULE to \"$GIT_DIR/info/exclude\".\15\nRules in that file only affects this clone of the repository.\15\n\15\n(fn RULE)" t) (autoload 'magit-gitignore-on-system "magit-gitignore" "\15\nAdd the Git ignore RULE to the file specified by `core.excludesFile'.\15\nRules that are defined in that file affect all local repositories.\15\n\15\n(fn RULE)" t) (autoload 'magit-skip-worktree "magit-gitignore" "\15\nCall \"git update-index --skip-worktree -- FILE\".\15\n\15\n(fn FILE)" t) (autoload 'magit-no-skip-worktree "magit-gitignore" "\15\nCall \"git update-index --no-skip-worktree -- FILE\".\15\n\15\n(fn FILE)" t) (autoload 'magit-assume-unchanged "magit-gitignore" "\15\nCall \"git update-index --assume-unchanged -- FILE\".\15\n\15\n(fn FILE)" t) (autoload 'magit-no-assume-unchanged "magit-gitignore" "\15\nCall \"git update-index --no-assume-unchanged -- FILE\".\15\n\15\n(fn FILE)" t) (autoload 'magit-log "magit-log" nil t) (autoload 'magit-log-refresh "magit-log" nil t) (autoload 'magit-log-current "magit-log" nil t) (autoload 'magit-log-head "magit-log" "\15\nShow log for `HEAD'.\15\n\15\n(fn &optional ARGS FILES)" t) (autoload 'magit-log-related "magit-log" "\15\nShow log for the current branch, its upstream and its push target.\15\nWhen the upstream is a local branch, then also show its own\15\nupstream.  When `HEAD' is detached, then show log for that, the\15\npreviously checked out branch and its upstream and push-target.\15\n\15\n(fn REVS &optional ARGS FILES)" t) (autoload 'magit-log-other "magit-log" "\15\nShow log for one or more revs read from the minibuffer.\15\nThe user can input any revision or revisions separated by a\15\nspace, or even ranges, but only branches and tags, and a\15\nrepresentation of the commit at point, are available as\15\ncompletion candidates.\15\n\15\n(fn REVS &optional ARGS FILES)" t) (autoload 'magit-log-branches "magit-log" "\15\nShow log for all local branches and `HEAD'.\15\n\15\n(fn &optional ARGS FILES)" t) (autoload 'magit-log-matching-branches "magit-log" "\15\nShow log for all branches matching PATTERN and `HEAD'.\15\n\15\n(fn PATTERN &optional ARGS FILES)" t) (autoload 'magit-log-matching-tags "magit-log" "\15\nShow log for all tags matching PATTERN and `HEAD'.\15\n\15\n(fn PATTERN &optional ARGS FILES)" t) (autoload 'magit-log-all-branches "magit-log" "\15\nShow log for all local and remote branches and `HEAD'.\15\n\15\n(fn &optional ARGS FILES)" t) (autoload 'magit-log-all "magit-log" "\15\nShow log for all references and `HEAD'.\15\n\15\n(fn &optional ARGS FILES)" t) (autoload 'magit-log-buffer-file "magit-log" "\15\nShow log for the blob or file visited in the current buffer.\15\nWith a prefix argument or when `--follow' is an active log\15\nargument, then follow renames.  When the region is active,\15\nrestrict the log to the lines that the region touches.\15\n\15\n(fn &optional FOLLOW BEG END)" t) (autoload 'magit-log-trace-definition "magit-log" "\15\nShow log for the definition at point.\15\n\15\n(fn FILE FN REV)" t) (autoload 'magit-log-merged "magit-log" "\15\nShow log for the merge of COMMIT into BRANCH.\15\n\15\nMore precisely, find merge commit M that brought COMMIT into\15\nBRANCH, and show the log of the range \"M^1..M\". If COMMIT is\15\ndirectly on BRANCH, then show approximately\15\n`magit-log-merged-commit-count' surrounding commits instead.\15\n\15\nThis command requires git-when-merged, which is available from\15\nhttps://github.com/mhagger/git-when-merged.\15\n\15\n(fn COMMIT BRANCH &optional ARGS FILES)" t) (autoload 'magit-log-move-to-parent "magit-log" "\15\nMove to the Nth parent of the current commit.\15\n\15\n(fn &optional N)" t) (autoload 'magit-shortlog "magit-log" nil t) (autoload 'magit-shortlog-since "magit-log" "\15\nShow a history summary for commits since REV.\15\n\15\n(fn REV ARGS)" t) (autoload 'magit-shortlog-range "magit-log" "\15\nShow a history summary for commit or range REV-OR-RANGE.\15\n\15\n(fn REV-OR-RANGE ARGS)" t) (autoload 'magit-cherry "magit-log" "\15\nShow commits in a branch that are not merged in the upstream branch.\15\n\15\n(fn HEAD UPSTREAM)" t) (autoload 'magit-merge "magit" nil t) (autoload 'magit-merge-plain "magit-merge" "\15\nMerge commit REV into the current branch; using default message.\15\n\15\nUnless there are conflicts or a prefix argument is used create a\15\nmerge commit using a generic commit message and without letting\15\nthe user inspect the result.  With a prefix argument pretend the\15\nmerge failed to give the user the opportunity to inspect the\15\nmerge.\15\n\15\n(git merge --no-edit|--no-commit [ARGS] REV)\15\n\15\n(fn REV &optional ARGS NOCOMMIT)" t) (autoload 'magit-merge-editmsg "magit-merge" "\15\nMerge commit REV into the current branch; and edit message.\15\nPerform the merge and prepare a commit message but let the user\15\nedit it.\15\n\15\n(git merge --edit --no-ff [ARGS] REV)\15\n\15\n(fn REV &optional ARGS)" t) (autoload 'magit-merge-nocommit "magit-merge" "\15\nMerge commit REV into the current branch; pretending it failed.\15\nPretend the merge failed to give the user the opportunity to\15\ninspect the merge and change the commit message.\15\n\15\n(git merge --no-commit --no-ff [ARGS] REV)\15\n\15\n(fn REV &optional ARGS)" t) (autoload 'magit-merge-dissolve "magit-merge" "\15\nMerge the current branch into BRANCH and remove the former.\15\n\15\nBefore merging, force push the source branch to its push-remote,\15\nprovided the respective remote branch already exists, ensuring\15\nthat the respective pull-request (if any) won't get stuck on some\15\nobsolete version of the commits that are being merged.  Finally\15\nif `forge-branch-pullreq' was used to create the merged branch,\15\nthen also remove the respective remote branch.\15\n\15\n(fn BRANCH &optional ARGS)" t) (autoload 'magit-merge-absorb "magit-merge" "\15\nMerge BRANCH into the current branch and remove the former.\15\n\15\nBefore merging, force push the source branch to its push-remote,\15\nprovided the respective remote branch already exists, ensuring\15\nthat the respective pull-request (if any) won't get stuck on some\15\nobsolete version of the commits that are being merged.  Finally\15\nif `forge-branch-pullreq' was used to create the merged branch,\15\nthen also remove the respective remote branch.\15\n\15\n(fn BRANCH &optional ARGS)" t) (autoload 'magit-merge-squash "magit-merge" "\15\nSquash commit REV into the current branch; don't create a commit.\15\n\15\n(git merge --squash REV)\15\n\15\n(fn REV)" t) (autoload 'magit-merge-preview "magit-merge" "\15\nPreview result of merging REV into the current branch.\15\n\15\n(fn REV)" t) (autoload 'magit-merge-abort "magit-merge" "\15\nAbort the current merge operation.\15\n\15\n(git merge --abort)" t) (autoload 'magit-info "magit-mode" "\15\nVisit the Magit manual." t) (autoload 'magit-notes "magit" nil t) (autoload 'magit-patch "magit-patch" nil t) (autoload 'magit-patch-create "magit-patch" nil t) (autoload 'magit-patch-apply "magit-patch" nil t) (autoload 'magit-patch-save "magit-patch" "\15\nWrite current diff into patch FILE.\15\n\15\nWhat arguments are used to create the patch depends on the value\15\nof `magit-patch-save-arguments' and whether a prefix argument is\15\nused.\15\n\15\nIf the value is the symbol `buffer', then use the same arguments\15\nas the buffer.  With a prefix argument use no arguments.\15\n\15\nIf the value is a list beginning with the symbol `exclude', then\15\nuse the same arguments as the buffer except for those matched by\15\nentries in the cdr of the list.  The comparison is done using\15\n`string-prefix-p'.  With a prefix argument use the same arguments\15\nas the buffer.\15\n\15\nIf the value is a list of strings (including the empty list),\15\nthen use those arguments.  With a prefix argument use the same\15\narguments as the buffer.\15\n\15\nOf course the arguments that are required to actually show the\15\nsame differences as those shown in the buffer are always used.\15\n\15\n(fn FILE &optional ARG)" t) (autoload 'magit-request-pull "magit-patch" "\15\nRequest upstream to pull from your public repository.\15\n\15\nURL is the url of your publicly accessible repository.\15\nSTART is a commit that already is in the upstream repository.\15\nEND is the last commit, usually a branch name, which upstream\15\nis asked to pull.  START has to be reachable from that commit.\15\n\15\n(fn URL START END)" t) (autoload 'magit-pull "magit-pull" nil t) (autoload 'magit-pull-from-pushremote "magit-pull" nil t) (autoload 'magit-pull-from-upstream "magit-pull" nil t) (autoload 'magit-pull-branch "magit-pull" "\15\nPull from a branch read in the minibuffer.\15\n\15\n(fn SOURCE ARGS)" t) (autoload 'magit-push "magit-push" nil t) (autoload 'magit-push-current-to-pushremote "magit-push" nil t) (autoload 'magit-push-current-to-upstream "magit-push" nil t) (autoload 'magit-push-current "magit-push" "\15\nPush the current branch to a branch read in the minibuffer.\15\n\15\n(fn TARGET ARGS)" t) (autoload 'magit-push-other "magit-push" "\15\nPush an arbitrary branch or commit somewhere.\15\nBoth the source and the target are read in the minibuffer.\15\n\15\n(fn SOURCE TARGET ARGS)" t) (autoload 'magit-push-refspecs "magit-push" "\15\nPush one or multiple REFSPECS to a REMOTE.\15\nBoth the REMOTE and the REFSPECS are read in the minibuffer.  To\15\nuse multiple REFSPECS, separate them with commas.  Completion is\15\nonly available for the part before the colon, or when no colon\15\nis used.\15\n\15\n(fn REMOTE REFSPECS ARGS)" t) (autoload 'magit-push-matching "magit-push" "\15\nPush all matching branches to another repository.\15\nIf multiple remotes exist, then read one from the user.\15\nIf just one exists, use that without requiring confirmation.\15\n\15\n(fn REMOTE &optional ARGS)" t) (autoload 'magit-push-tags "magit-push" "\15\nPush all tags to another repository.\15\nIf only one remote exists, then push to that.  Otherwise prompt\15\nfor a remote, offering the remote configured for the current\15\nbranch as default.\15\n\15\n(fn REMOTE &optional ARGS)" t) (autoload 'magit-push-tag "magit-push" "\15\nPush a tag to another repository.\15\n\15\n(fn TAG REMOTE &optional ARGS)" t) (autoload 'magit-push-notes-ref "magit-push" "\15\nPush a notes ref to another repository.\15\n\15\n(fn REF REMOTE &optional ARGS)" t) (autoload 'magit-push-implicitly "magit-push" nil t) (autoload 'magit-push-to-remote "magit-push" nil t) (autoload 'magit-reflog-current "magit-reflog" "\15\nDisplay the reflog of the current branch.\15\nIf `HEAD' is detached, then show the reflog for that instead." t) (autoload 'magit-reflog-other "magit-reflog" "\15\nDisplay the reflog of a branch or another ref.\15\n\15\n(fn REF)" t) (autoload 'magit-reflog-head "magit-reflog" "\15\nDisplay the `HEAD' reflog." t) (autoload 'magit-show-refs "magit-refs" nil t) (autoload 'magit-show-refs-head "magit-refs" "\15\nList and compare references in a dedicated buffer.\15\nCompared with `HEAD'.\15\n\15\n(fn &optional ARGS)" t) (autoload 'magit-show-refs-current "magit-refs" "\15\nList and compare references in a dedicated buffer.\15\nCompare with the current branch or `HEAD' if it is detached.\15\n\15\n(fn &optional ARGS)" t) (autoload 'magit-show-refs-other "magit-refs" "\15\nList and compare references in a dedicated buffer.\15\nCompared with a branch read from the user.\15\n\15\n(fn &optional REF ARGS)" t) (autoload 'magit-remote "magit-remote" nil t) (autoload 'magit-remote-add "magit-remote" "\15\nAdd a remote named REMOTE and fetch it.\15\n\15\n(fn REMOTE URL &optional ARGS)" t) (autoload 'magit-remote-rename "magit-remote" "\15\nRename the remote named OLD to NEW.\15\n\15\n(fn OLD NEW)" t) (autoload 'magit-remote-remove "magit-remote" "\15\nDelete the remote named REMOTE.\15\n\15\n(fn REMOTE)" t) (autoload 'magit-remote-prune "magit-remote" "\15\nRemove stale remote-tracking branches for REMOTE.\15\n\15\n(fn REMOTE)" t) (autoload 'magit-remote-prune-refspecs "magit-remote" "\15\nRemove stale refspecs for REMOTE.\15\n\15\nA refspec is stale if there no longer exists at least one branch\15\non the remote that would be fetched due to that refspec.  A stale\15\nrefspec is problematic because its existence causes Git to refuse\15\nto fetch according to the remaining non-stale refspecs.\15\n\15\nIf only stale refspecs remain, then offer to either delete the\15\nremote or to replace the stale refspecs with the default refspec.\15\n\15\nAlso remove the remote-tracking branches that were created due to\15\nthe now stale refspecs.  Other stale branches are not removed.\15\n\15\n(fn REMOTE)" t) (autoload 'magit-remote-set-head "magit-remote" "\15\nSet the local representation of REMOTE's default branch.\15\nQuery REMOTE and set the symbolic-ref refs/remotes/<remote>/HEAD\15\naccordingly.  With a prefix argument query for the branch to be\15\nused, which allows you to select an incorrect value if you fancy\15\ndoing that.\15\n\15\n(fn REMOTE &optional BRANCH)" t) (autoload 'magit-remote-unset-head "magit-remote" "\15\nUnset the local representation of REMOTE's default branch.\15\nDelete the symbolic-ref \"refs/remotes/<remote>/HEAD\".\15\n\15\n(fn REMOTE)" t) (autoload 'magit-update-default-branch "magit-remote" nil t) (autoload 'magit-remote-unshallow "magit-remote" "\15\nConvert a shallow remote into a full one.\15\nIf only a single refspec is set and it does not contain a\15\nwildcard, then also offer to replace it with the standard\15\nrefspec.\15\n\15\n(fn REMOTE)" t) (autoload 'magit-remote-configure "magit-remote" nil t) (autoload 'magit-list-repositories "magit-repos" "\15\nDisplay a list of repositories.\15\n\15\nUse the option `magit-repository-directories' to control which\15\nrepositories are displayed." t) (autoload 'magit-reset "magit" nil t) (autoload 'magit-reset-mixed "magit-reset" "\15\nReset the `HEAD' and index to COMMIT, but not the working tree.\15\n\15\n(git reset --mixed COMMIT)\15\n\15\n(fn COMMIT)" t) (autoload 'magit-reset-soft "magit-reset" "\15\nReset the `HEAD' to COMMIT, but not the index and working tree.\15\n\15\n(git reset --soft REVISION)\15\n\15\n(fn COMMIT)" t) (autoload 'magit-reset-hard "magit-reset" "\15\nReset the `HEAD', index, and working tree to COMMIT.\15\n\15\n(git reset --hard REVISION)\15\n\15\n(fn COMMIT)" t) (autoload 'magit-reset-keep "magit-reset" "\15\nReset the `HEAD' and index to COMMIT, while keeping uncommitted changes.\15\n\15\n(git reset --keep REVISION)\15\n\15\n(fn COMMIT)" t) (autoload 'magit-reset-index "magit-reset" "\15\nReset the index to COMMIT.\15\nKeep the `HEAD' and working tree as-is, so if COMMIT refers to the\15\nhead this effectively unstages all changes.\15\n\15\n(git reset COMMIT .)\15\n\15\n(fn COMMIT)" t) (autoload 'magit-reset-worktree "magit-reset" "\15\nReset the worktree to COMMIT.\15\nKeep the `HEAD' and index as-is.\15\n\15\n(fn COMMIT)" t) (autoload 'magit-reset-quickly "magit-reset" "\15\nReset the `HEAD' and index to COMMIT, and possibly the working tree.\15\nWith a prefix argument reset the working tree otherwise don't.\15\n\15\n(git reset --mixed|--hard COMMIT)\15\n\15\n(fn COMMIT &optional HARD)" t) (autoload 'magit-sequencer-continue "magit-sequence" "\15\nResume the current cherry-pick or revert sequence." t) (autoload 'magit-sequencer-skip "magit-sequence" "\15\nSkip the stopped at commit during a cherry-pick or revert sequence." t) (autoload 'magit-sequencer-abort "magit-sequence" "\15\nAbort the current cherry-pick or revert sequence.\15\nThis discards all changes made since the sequence started." t) (autoload 'magit-cherry-pick "magit-sequence" nil t) (autoload 'magit-cherry-copy "magit-sequence" "\15\nCopy COMMITS from another branch onto the current branch.\15\nPrompt for a commit, defaulting to the commit at point.  If\15\nthe region selects multiple commits, then pick all of them,\15\nwithout prompting.\15\n\15\n(fn COMMITS &optional ARGS)" t) (autoload 'magit-cherry-apply "magit-sequence" "\15\nApply the changes in COMMITS but do not commit them.\15\nPrompt for a commit, defaulting to the commit at point.  If\15\nthe region selects multiple commits, then apply all of them,\15\nwithout prompting.\15\n\15\n(fn COMMITS &optional ARGS)" t) (autoload 'magit-cherry-harvest "magit-sequence" "\15\nMove COMMITS from another BRANCH onto the current branch.\15\nRemove the COMMITS from BRANCH and stay on the current branch.\15\nIf a conflict occurs, then you have to fix that and finish the\15\nprocess manually.\15\n\15\n(fn COMMITS BRANCH &optional ARGS)" t) (autoload 'magit-cherry-donate "magit-sequence" "\15\nMove COMMITS from the current branch onto another existing BRANCH.\15\nRemove COMMITS from the current branch and stay on that branch.\15\nIf a conflict occurs, then you have to fix that and finish the\15\nprocess manually.  `HEAD' is allowed to be detached initially.\15\n\15\n(fn COMMITS BRANCH &optional ARGS)" t) (autoload 'magit-cherry-spinout "magit-sequence" "\15\nMove COMMITS from the current branch onto a new BRANCH.\15\nRemove COMMITS from the current branch and stay on that branch.\15\nIf a conflict occurs, then you have to fix that and finish the\15\nprocess manually.\15\n\15\n(fn COMMITS BRANCH START-POINT &optional ARGS)" t) (autoload 'magit-cherry-spinoff "magit-sequence" "\15\nMove COMMITS from the current branch onto a new BRANCH.\15\nRemove COMMITS from the current branch and checkout BRANCH.\15\nIf a conflict occurs, then you have to fix that and finish\15\nthe process manually.\15\n\15\n(fn COMMITS BRANCH START-POINT &optional ARGS)" t) (autoload 'magit-revert "magit-sequence" nil t) (autoload 'magit-revert-and-commit "magit-sequence" "\15\nRevert COMMIT by creating a new commit.\15\nPrompt for a commit, defaulting to the commit at point.  If\15\nthe region selects multiple commits, then revert all of them,\15\nwithout prompting.\15\n\15\n(fn COMMIT &optional ARGS)" t) (autoload 'magit-revert-no-commit "magit-sequence" "\15\nRevert COMMIT by applying it in reverse to the worktree.\15\nPrompt for a commit, defaulting to the commit at point.  If\15\nthe region selects multiple commits, then revert all of them,\15\nwithout prompting.\15\n\15\n(fn COMMIT &optional ARGS)" t) (autoload 'magit-am "magit-sequence" nil t) (autoload 'magit-am-apply-patches "magit-sequence" "\15\nApply the patches FILES.\15\n\15\n(fn &optional FILES ARGS)" t) (autoload 'magit-am-apply-maildir "magit-sequence" "\15\nApply the patches from MAILDIR.\15\n\15\n(fn &optional MAILDIR ARGS)" t) (autoload 'magit-am-continue "magit-sequence" "\15\nResume the current patch applying sequence." t) (autoload 'magit-am-skip "magit-sequence" "\15\nSkip the stopped at patch during a patch applying sequence." t) (autoload 'magit-am-abort "magit-sequence" "\15\nAbort the current patch applying sequence.\15\nThis discards all changes made since the sequence started." t) (autoload 'magit-rebase "magit-sequence" nil t) (autoload 'magit-rebase-onto-pushremote "magit-sequence" nil t) (autoload 'magit-rebase-onto-upstream "magit-sequence" nil t) (autoload 'magit-rebase-branch "magit-sequence" "\15\nRebase the current branch onto a branch read in the minibuffer.\15\nAll commits that are reachable from `HEAD' but not from the\15\nselected branch TARGET are being rebased.\15\n\15\n(fn TARGET ARGS)" t) (autoload 'magit-rebase-subset "magit-sequence" "\15\nRebase a subset of the current branch's history onto a new base.\15\nRebase commits from START to `HEAD' onto NEWBASE.\15\nSTART has to be selected from a list of recent commits.\15\n\15\n(fn NEWBASE START ARGS)" t) (autoload 'magit-rebase-interactive "magit-sequence" "\15\nStart an interactive rebase sequence.\15\n\15\n(fn COMMIT ARGS)" t) (autoload 'magit-rebase-autosquash "magit-sequence" "\15\nCombine squash and fixup commits with their intended targets.\15\nBy default only squash into commits that are not reachable from\15\nthe upstream branch.  If no upstream is configured or with a prefix\15\nargument, prompt for the first commit to potentially squash into.\15\n\15\n(fn SELECT ARGS)" t) (autoload 'magit-rebase-edit-commit "magit-sequence" "\15\nEdit a single older commit using rebase.\15\n\15\n(fn COMMIT ARGS)" t) (autoload 'magit-rebase-reword-commit "magit-sequence" "\15\nReword a single older commit using rebase.\15\n\15\n(fn COMMIT ARGS)" t) (autoload 'magit-rebase-remove-commit "magit-sequence" "\15\nRemove a single older commit using rebase.\15\n\15\n(fn COMMIT ARGS)" t) (autoload 'magit-rebase-continue "magit-sequence" "\15\nRestart the current rebasing operation.\15\nIn some cases this pops up a commit message buffer for you do\15\nedit.  With a prefix argument the old message is reused as-is.\15\n\15\n(fn &optional NOEDIT)" t) (autoload 'magit-rebase-skip "magit-sequence" "\15\nSkip the current commit and restart the current rebase operation." t) (autoload 'magit-rebase-edit "magit-sequence" "\15\nEdit the todo list of the current rebase operation." t) (autoload 'magit-rebase-abort "magit-sequence" "\15\nAbort the current rebase operation, restoring the original branch." t) (autoload 'magit-sparse-checkout "magit-sparse-checkout" nil t) (autoload 'magit-sparse-checkout-enable "magit-sparse-checkout" "\15\nConvert the working tree to a sparse checkout.\15\n\15\n(fn &optional ARGS)" t) (autoload 'magit-sparse-checkout-set "magit-sparse-checkout" "\15\nRestrict working tree to DIRECTORIES.\15\nTo extend rather than override the currently configured\15\ndirectories, call `magit-sparse-checkout-add' instead.\15\n\15\n(fn DIRECTORIES)" t) (autoload 'magit-sparse-checkout-add "magit-sparse-checkout" "\15\nAdd DIRECTORIES to the working tree.\15\nTo override rather than extend the currently configured\15\ndirectories, call `magit-sparse-checkout-set' instead.\15\n\15\n(fn DIRECTORIES)" t) (autoload 'magit-sparse-checkout-reapply "magit-sparse-checkout" "\15\nReapply the sparse checkout rules to the working tree.\15\nSome operations such as merging or rebasing may need to check out\15\nfiles that aren't included in the sparse checkout.  Call this\15\ncommand to reset to the sparse checkout state." t) (autoload 'magit-sparse-checkout-disable "magit-sparse-checkout" "\15\nConvert sparse checkout to full checkout.\15\nNote that disabling the sparse checkout does not clear the\15\nconfigured directories.  Call `magit-sparse-checkout-enable' to\15\nrestore the previous sparse checkout." t) (autoload 'magit-stash "magit-stash" nil t) (autoload 'magit-stash-both "magit-stash" "\15\nCreate a stash of the index and working tree.\15\nUntracked files are included according to infix arguments.\15\nOne prefix argument is equivalent to `--include-untracked'\15\nwhile two prefix arguments are equivalent to `--all'.\15\n\15\n(fn MESSAGE &optional INCLUDE-UNTRACKED)" t) (autoload 'magit-stash-index "magit-stash" "\15\nCreate a stash of the index only.\15\nUnstaged and untracked changes are not stashed.  The stashed\15\nchanges are applied in reverse to both the index and the\15\nworktree.  This command can fail when the worktree is not clean.\15\nApplying the resulting stash has the inverse effect.\15\n\15\n(fn MESSAGE)" t) (autoload 'magit-stash-worktree "magit-stash" "\15\nCreate a stash of unstaged changes in the working tree.\15\nUntracked files are included according to infix arguments.\15\nOne prefix argument is equivalent to `--include-untracked'\15\nwhile two prefix arguments are equivalent to `--all'.\15\n\15\n(fn MESSAGE &optional INCLUDE-UNTRACKED)" t) (autoload 'magit-stash-keep-index "magit-stash" "\15\nCreate a stash of the index and working tree, keeping index intact.\15\nUntracked files are included according to infix arguments.\15\nOne prefix argument is equivalent to `--include-untracked'\15\nwhile two prefix arguments are equivalent to `--all'.\15\n\15\n(fn MESSAGE &optional INCLUDE-UNTRACKED)" t) (autoload 'magit-snapshot-both "magit-stash" "\15\nCreate a snapshot of the index and working tree.\15\nUntracked files are included according to infix arguments.\15\nOne prefix argument is equivalent to `--include-untracked'\15\nwhile two prefix arguments are equivalent to `--all'.\15\n\15\n(fn &optional INCLUDE-UNTRACKED)" t) (autoload 'magit-snapshot-index "magit-stash" "\15\nCreate a snapshot of the index only.\15\nUnstaged and untracked changes are not stashed." t) (autoload 'magit-snapshot-worktree "magit-stash" "\15\nCreate a snapshot of unstaged changes in the working tree.\15\nUntracked files are included according to infix arguments.\15\nOne prefix argument is equivalent to `--include-untracked'\15\nwhile two prefix arguments are equivalent to `--all'.\15\n\15\n(fn &optional INCLUDE-UNTRACKED)" t) (autoload 'magit-stash-push "magit-stash" nil t) (autoload 'magit-stash-apply "magit-stash" "\15\nApply a stash to the working tree.\15\n\15\nWhen using a Git release before v2.38.0, simply run \"git stash\15\napply\" or with a prefix argument \"git stash apply --index\".\15\n\15\nWhen using Git v2.38.0 or later, behave more intelligently:\15\n\15\nFirst try \"git stash apply --index\", which tries to preserve the\15\nindex stored in the stash, if any.  This may fail because applying\15\nthe stash could result in conflicts and those have to be stored in\15\nthe index, making it impossible to also store the stash's index\15\nthere.\15\n\15\nIf \"git stash\" fails, then potentially fall back to using \"git\15\napply\".  If the stash does not touch any unstaged files, then pass\15\n\"--3way\" to that command.  Otherwise ask the user whether to use\15\nthat argument or \"--reject\".  Customize `magit-no-confirm' if you\15\nwant to fall back to using \"--3way\", without being prompted.\15\n\15\n(fn STASH)" t) (autoload 'magit-stash-pop "magit-stash" "\15\nApply a stash to the working tree, on success remove it from stash list.\15\n\15\nWhen using a Git release before v2.38.0, simply run \"git stash\15\npop\" or with a prefix argument \"git stash pop --index\".\15\n\15\nWhen using Git v2.38.0 or later, behave more intelligently:\15\n\15\nFirst try \"git stash apply --index\", which tries to preserve the\15\nindex stored in the stash, if any.  This may fail because applying\15\nthe stash could result in conflicts and those have to be stored in\15\nthe index, making it impossible to also store the stash's index\15\nthere.\15\n\15\nIf \"git stash\" fails, then potentially fall back to using \"git\15\napply\".  If the stash does not touch any unstaged files, then pass\15\n\"--3way\" to that command.  Otherwise ask the user whether to use\15\nthat argument or \"--reject\".  Customize `magit-no-confirm' if you\15\nwant to fall back to using \"--3way\", without being prompted.\15\n\15\n(fn STASH)" t) (autoload 'magit-stash-drop "magit-stash" "\15\nRemove a stash from the stash list.\15\nWhen the region is active offer to drop all contained stashes.\15\n\15\n(fn STASH)" t) (autoload 'magit-stash-clear "magit-stash" "\15\nRemove all stashes saved in REF's reflog by deleting REF.\15\n\15\n(fn REF)" t) (autoload 'magit-stash-branch "magit-stash" "\15\nCreate and checkout a new BRANCH from an existing STASH.\15\nThe new branch starts at the commit that was current when the\15\nstash was created.  If the stash applies cleanly, then drop it.\15\n\15\n(fn STASH BRANCH)" t) (autoload 'magit-stash-branch-here "magit-stash" "\15\nCreate and checkout a new BRANCH from an existing STASH.\15\nUse the current branch or `HEAD' as the starting-point of BRANCH.\15\nThen apply STASH, dropping it if it applies cleanly.\15\n\15\n(fn STASH BRANCH)" t) (autoload 'magit-stash-format-patch "magit-stash" "\15\nCreate a patch from STASH.\15\n\15\n(fn STASH)" t) (autoload 'magit-stash-list "magit-stash" "\15\nList all stashes in a buffer." t) (autoload 'magit-stash-show "magit-stash" "\15\nShow all diffs of a stash in a buffer.\15\n\15\n(fn STASH &optional ARGS FILES)" t) (autoload 'magit-init "magit-status" "\15\nInitialize a Git repository, then show its status.\15\n\15\nIf the directory is below an existing repository, then the user\15\nhas to confirm that a new one should be created inside.  If the\15\ndirectory is the root of the existing repository, then the user\15\nhas to confirm that it should be reinitialized.\15\n\15\nNon-interactively DIRECTORY is (re-)initialized unconditionally.\15\n\15\n(fn DIRECTORY)" t) (autoload 'magit-status "magit-status" "\15\nShow the status of the current Git repository in a buffer.\15\n\15\nIf the current directory isn't located within a Git repository,\15\nthen prompt for an existing repository or an arbitrary directory,\15\ndepending on option `magit-repository-directories', and show the\15\nstatus of the selected repository instead.\15\n\15\n* If that option specifies any existing repositories, then offer\15\n  those for completion and show the status buffer for the\15\n  selected one.\15\n\15\n* Otherwise read an arbitrary directory using regular file-name\15\n  completion.  If the selected directory is the top-level of an\15\n  existing working tree, then show the status buffer for that.\15\n\15\n* Otherwise offer to initialize the selected directory as a new\15\n  repository.  After creating the repository show its status\15\n  buffer.\15\n\15\nThese fallback behaviors can also be forced using one or more\15\nprefix arguments:\15\n\15\n* With two prefix arguments (or more precisely a numeric prefix\15\n  value of 16 or greater) read an arbitrary directory and act on\15\n  it as described above.  The same could be accomplished using\15\n  the command `magit-init'.\15\n\15\n* With a single prefix argument read an existing repository, or\15\n  if none can be found based on `magit-repository-directories',\15\n  then fall back to the same behavior as with two prefix\15\n  arguments.\15\n\15\n(fn &optional DIRECTORY CACHE)" t) (defalias 'magit #'magit-status "\15\nBegin using Magit.\15\n\15\nThis alias for `magit-status' exists for better discoverability.\15\n\15\nInstead of invoking this alias for `magit-status' using\15\n\"M-x magit RET\", you should bind a key to `magit-status'\15\nand read the info node `(magit)Getting Started', which\15\nalso contains other useful hints.") (autoload 'magit-status-here "magit-status" "\15\nLike `magit-status' but with non-nil `magit-status-goto-file-position'." t) (autoload 'magit-status-quick "magit-status" "\15\nShow the status of the current Git repository, maybe without refreshing.\15\n\15\nIf the status buffer of the current Git repository exists but\15\nisn't being displayed in the selected frame, then display it\15\nwithout refreshing it.\15\n\15\nIf the status buffer is being displayed in the selected frame,\15\nthen also refresh it.\15\n\15\nPrefix arguments have the same meaning as for `magit-status',\15\nand additionally cause the buffer to be refresh.\15\n\15\nTo use this function instead of `magit-status', add this to your\15\ninit file: (global-set-key (kbd \"C-x g\") \\='magit-status-quick)." t) (autoload 'magit-status-setup-buffer "magit-status" "\15\n\15\n\15\n(fn &optional DIRECTORY)") (autoload 'magit-submodule "magit-submodule" nil t) (autoload 'magit-submodule-add "magit-submodule" nil t) (autoload 'magit-submodule-read-name-for-path "magit-submodule" "\15\n\15\n\15\n(fn PATH &optional PREFER-SHORT)") (autoload 'magit-submodule-register "magit-submodule" nil t) (autoload 'magit-submodule-populate "magit-submodule" nil t) (autoload 'magit-submodule-update "magit-submodule" nil t) (autoload 'magit-submodule-synchronize "magit-submodule" nil t) (autoload 'magit-submodule-unpopulate "magit-submodule" nil t) (autoload 'magit-submodule-remove "magit-submodule" "\15\nUnregister MODULES and remove their working directories.\15\n\15\nFor safety reasons, do not remove the gitdirs and if a module has\15\nuncommitted changes, then do not remove it at all.  If a module's\15\ngitdir is located inside the working directory, then move it into\15\nthe gitdir of the superproject first.\15\n\15\nWith the \"--force\" argument offer to remove dirty working\15\ndirectories and with a prefix argument offer to delete gitdirs.\15\nBoth actions are very dangerous and have to be confirmed.  There\15\nare additional safety precautions in place, so you might be able\15\nto recover from making a mistake here, but don't count on it.\15\n\15\n(fn MODULES ARGS TRASH-GITDIRS)" t) (autoload 'magit-insert-modules "magit-submodule" "\15\nInsert submodule sections.\15\nHook `magit-module-sections-hook' controls which module sections\15\nare inserted, and option `magit-module-sections-nested' controls\15\nwhether they are wrapped in an additional section.") (autoload 'magit-insert-modules-overview "magit-submodule" "\15\nInsert sections for all modules.\15\nFor each section insert the path and the output of `git describe --tags',\15\nor, failing that, the abbreviated HEAD commit hash.") (autoload 'magit-insert-modules-unpulled-from-upstream "magit-submodule" "\15\nInsert sections for modules that haven't been pulled from the upstream.\15\nThese sections can be expanded to show the respective commits.") (autoload 'magit-insert-modules-unpulled-from-pushremote "magit-submodule" "\15\nInsert sections for modules that haven't been pulled from the push-remote.\15\nThese sections can be expanded to show the respective commits.") (autoload 'magit-insert-modules-unpushed-to-upstream "magit-submodule" "\15\nInsert sections for modules that haven't been pushed to the upstream.\15\nThese sections can be expanded to show the respective commits.") (autoload 'magit-insert-modules-unpushed-to-pushremote "magit-submodule" "\15\nInsert sections for modules that haven't been pushed to the push-remote.\15\nThese sections can be expanded to show the respective commits.") (autoload 'magit-list-submodules "magit-submodule" "\15\nDisplay a list of the current repository's populated submodules." t) (autoload 'magit-subtree "magit-subtree" nil t) (autoload 'magit-subtree-import "magit-subtree" nil t) (autoload 'magit-subtree-export "magit-subtree" nil t) (autoload 'magit-subtree-add "magit-subtree" "\15\nAdd REF from REPOSITORY as a new subtree at PREFIX.\15\n\15\n(fn PREFIX REPOSITORY REF ARGS)" t) (autoload 'magit-subtree-add-commit "magit-subtree" "\15\nAdd COMMIT as a new subtree at PREFIX.\15\n\15\n(fn PREFIX COMMIT ARGS)" t) (autoload 'magit-subtree-merge "magit-subtree" "\15\nMerge COMMIT into the PREFIX subtree.\15\n\15\n(fn PREFIX COMMIT ARGS)" t) (autoload 'magit-subtree-pull "magit-subtree" "\15\nPull REF from REPOSITORY into the PREFIX subtree.\15\n\15\n(fn PREFIX REPOSITORY REF ARGS)" t) (autoload 'magit-subtree-push "magit-subtree" "\15\nExtract the history of the subtree PREFIX and push it to REF on REPOSITORY.\15\n\15\n(fn PREFIX REPOSITORY REF ARGS)" t) (autoload 'magit-subtree-split "magit-subtree" "\15\nExtract the history of the subtree PREFIX.\15\n\15\n(fn PREFIX COMMIT ARGS)" t) (autoload 'magit-tag "magit" nil t) (autoload 'magit-tag-create "magit-tag" "\15\nCreate a new tag with the given NAME at REV.\15\nWith a prefix argument annotate the tag.\15\n\15\n(git tag [--annotate] NAME REV)\15\n\15\n(fn NAME REV &optional ARGS)" t) (autoload 'magit-tag-delete "magit-tag" "\15\nDelete one or more tags.\15\nIf the region marks multiple tags (and nothing else), then offer\15\nto delete those, otherwise prompt for a single tag to be deleted,\15\ndefaulting to the tag at point.\15\n\15\n(git tag -d TAGS)\15\n\15\n(fn TAGS)" t) (autoload 'magit-tag-prune "magit-tag" "\15\nOffer to delete tags missing locally from REMOTE, and vice versa.\15\n\15\n(fn TAGS REMOTE-TAGS REMOTE)" t) (autoload 'magit-tag-release "magit-tag" "\15\nCreate a release tag for `HEAD'.\15\n\15\nAssume that release tags match `magit-release-tag-regexp'.\15\n\15\nIf `HEAD's message matches `magit-release-commit-regexp', then\15\nbase the tag on the version string specified by that.  Otherwise\15\nprompt for the name of the new tag using the highest existing\15\ntag as initial input and leaving it to the user to increment the\15\ndesired part of the version string.\15\n\15\nWhen creating an annotated tag, prepare a message based on the message\15\nof the highest existing tag, provided that contains the corresponding\15\nversion string, and substituting the new version string for that.  If\15\nthat is not the case, propose a message using a reasonable format.\15\n\15\n(fn TAG MSG &optional ARGS)" t) (defvar magit-wip-mode nil "\15\nNon-nil if Magit-Wip mode is enabled.\15\nSee the `magit-wip-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `magit-wip-mode'.") (autoload 'magit-wip-mode "magit-wip" "\15\nSave uncommitted changes to work-in-progress refs.\15\n\15\nWhenever appropriate (i.e., when dataloss would be a possibility\15\notherwise) this mode causes uncommitted changes to be committed\15\nto dedicated work-in-progress refs.\15\n\15\nFor historic reasons this mode is implemented on top of four\15\nother `magit-wip-*' modes, which can also be used individually,\15\nif you want finer control over when the wip refs are updated;\15\nbut that is discouraged.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Magit-Wip mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='magit-wip-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'magit-wip-after-save-mode 'globalized-minor-mode t) (defvar magit-wip-after-save-mode nil "\15\nNon-nil if Magit-Wip-After-Save mode is enabled.\15\nSee the `magit-wip-after-save-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `magit-wip-after-save-mode'.") (autoload 'magit-wip-after-save-mode "magit-wip" "\15\nToggle Magit-Wip-After-Save-Local mode in all buffers.\15\nWith prefix ARG, enable Magit-Wip-After-Save mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nMagit-Wip-After-Save-Local mode is enabled in all buffers where\15\n`magit-wip-after-save-local-mode-turn-on' would do it.\15\n\15\nSee `magit-wip-after-save-local-mode' for more information on\15\nMagit-Wip-After-Save-Local mode.\15\n\15\n(fn &optional ARG)" t) (defvar magit-wip-after-apply-mode nil "\15\nNon-nil if Magit-Wip-After-Apply mode is enabled.\15\nSee the `magit-wip-after-apply-mode' command\15\nfor a description of this minor mode.") (autoload 'magit-wip-after-apply-mode "magit-wip" "\15\nCommit to work-in-progress refs.\15\n\15\nAfter applying a change using any \"apply variant\"\15\ncommand (apply, stage, unstage, discard, and reverse) commit the\15\naffected files to the current wip refs.  For each branch there\15\nmay be two wip refs; one contains snapshots of the files as found\15\nin the worktree and the other contains snapshots of the entries\15\nin the index.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Magit-Wip-After-Apply mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='magit-wip-after-apply-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (defvar magit-wip-before-change-mode nil "\15\nNon-nil if Magit-Wip-Before-Change mode is enabled.\15\nSee the `magit-wip-before-change-mode' command\15\nfor a description of this minor mode.") (autoload 'magit-wip-before-change-mode "magit-wip" "\15\nCommit to work-in-progress refs before certain destructive changes.\15\n\15\nBefore invoking a revert command or an \"apply variant\"\15\ncommand (apply, stage, unstage, discard, and reverse) commit the\15\naffected tracked files to the current wip refs.  For each branch\15\nthere may be two wip refs; one contains snapshots of the files\15\nas found in the worktree and the other contains snapshots of the\15\nentries in the index.\15\n\15\nOnly changes to files which could potentially be affected by the\15\ncommand which is about to be called are committed.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Magit-Wip-Before-Change mode' mode.  If the prefix argument is\15\npositive, enable the mode, and if it is zero or negative, disable the\15\nmode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='magit-wip-before-change-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'magit-wip-commit-initial-backup "magit-wip" "\15\nBefore saving, commit current file to a worktree wip ref.\15\n\15\nThe user has to add this function to `before-save-hook'.\15\n\15\nCommit the current state of the visited file before saving the\15\ncurrent buffer to that file.  This backs up the same version of\15\nthe file as `backup-buffer' would, but stores the backup in the\15\nworktree wip ref, which is also used by the various Magit Wip\15\nmodes, instead of in a backup file as `backup-buffer' would.\15\n\15\nThis function ignores the variables that affect `backup-buffer'\15\nand can be used along-side that function, which is recommended\15\nbecause this function only backs up files that are tracked in\15\na Git repository.") (autoload 'magit-worktree "magit-worktree" nil t) (autoload 'magit-worktree-checkout "magit-worktree" "\15\nCheckout BRANCH in a new worktree at PATH.\15\n\15\n(fn PATH BRANCH)" t) (autoload 'magit-worktree-branch "magit-worktree" "\15\nCreate a new BRANCH and check it out in a new worktree at PATH.\15\n\15\n(fn PATH BRANCH START-POINT)" t) (autoload 'magit-worktree-move "magit-worktree" "\15\nMove WORKTREE to PATH.\15\n\15\n(fn WORKTREE PATH)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/orgit/orgit-autoloads.el") (load-true-file-name load-file-name)) (with-eval-after-load 'magit (keymap-set magit-mode-map "<remap> <org-store-link>" #'orgit-store-link)) (autoload 'orgit-store-link "orgit" "\15\nLike `org-store-link' but store links to all selected commits, if any.\15\n\15\n(fn ARG)" t) (with-eval-after-load 'org (with-eval-after-load 'magit (org-link-set-parameters "orgit" :store #'orgit-status-store :follow #'orgit-status-open :export #'orgit-status-export :complete #'orgit-status-complete-link))) (autoload 'orgit-status-store "orgit" "\15\nStore a link to a Magit-Status mode buffer.\15\nWhen the region selects one or more commits, then do nothing.\15\nIn that case `orgit-rev-store' stores one or more links instead.") (autoload 'orgit-status-open "orgit" "\15\n\15\n\15\n(fn REPO)") (autoload 'orgit-status-export "orgit" "\15\n\15\n\15\n(fn PATH DESC FORMAT)") (autoload 'orgit-status-complete-link "orgit" "\15\n\15\n\15\n(fn &optional ARG)") (with-eval-after-load 'org (with-eval-after-load 'magit (org-link-set-parameters "orgit-log" :store #'orgit-log-store :follow #'orgit-log-open :export #'orgit-log-export :complete #'orgit-log-complete-link))) (autoload 'orgit-log-store "orgit" "\15\nStore a link to a Magit-Log mode buffer.\15\nWhen the region selects one or more commits, then do nothing.\15\nIn that case `orgit-rev-store' stores one or more links instead.") (autoload 'orgit-log-open "orgit" "\15\n\15\n\15\n(fn PATH)") (autoload 'orgit-log-export "orgit" "\15\n\15\n\15\n(fn PATH DESC FORMAT)") (autoload 'orgit-log-complete-link "orgit" "\15\n\15\n\15\n(fn &optional ARG)") (with-eval-after-load 'org (with-eval-after-load 'magit (org-link-set-parameters "orgit-rev" :store #'orgit-rev-store :follow #'orgit-rev-open :export #'orgit-rev-export :complete #'orgit-rev-complete-link))) (autoload 'orgit-rev-store "orgit" "\15\nStore a link to a Magit-Revision mode buffer.\15\n\15\nBy default store an abbreviated revision hash.\15\n\15\n\\<global-map>With a single \\[universal-argument] prefix argument instead store the name of a tag\15\nor branch that points at the revision, if any.  The meaning of this\15\nprefix argument is reversed if `orgit-store-reference' is non-nil.\15\n\15\nWith a single \\[negative-argument] negative prefix argument store revision using the\15\nform \":/TEXT\", which is described in the gitrevisions(7) manpage.\15\n\15\nWhen more than one prefix argument is used, then `org-store-link'\15\nstores a link itself, without calling this function.\15\n\15\nWhen the region selects one or more commits, e.g., in a log, then\15\nstore links to the Magit-Revision mode buffers for these commits.") (autoload 'orgit-rev-open "orgit" "\15\n\15\n\15\n(fn PATH)") (autoload 'orgit-rev-export "orgit" "\15\n\15\n\15\n(fn PATH DESC FORMAT)") (autoload 'orgit-rev-complete-link "orgit" "\15\n\15\n\15\n(fn &optional ARG)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/goto-chg/goto-chg-autoloads.el") (load-true-file-name load-file-name)) (autoload 'goto-last-change "goto-chg" "\15\nGo to the point where the last edit was made in the current buffer.\15\nRepeat the command to go to the second last edit, etc.\15\n\15\nTo go back to more recent edit, the reverse of this command, use \\[goto-last-change-reverse]\15\nor precede this command with \\[universal-argument] - (minus).\15\n\15\nIt does not go to the same point twice even if there has been many edits\15\nthere. I call the minimal distance between distinguishable edits \"span\".\15\nSet variable `glc-default-span' to control how close is \"the same point\".\15\nDefault span is 8.\15\nThe span can be changed temporarily with \\[universal-argument] right before \\[goto-last-change]:\15\n\\[universal-argument] <NUMBER> set current span to that number,\15\n\\[universal-argument] (no number) multiplies span by 4, starting with default.\15\nThe so set span remains until it is changed again with \\[universal-argument], or the consecutive\15\nrepetition of this command is ended by any other command.\15\n\15\nWhen span is zero (i.e. \\[universal-argument] 0) subsequent \\[goto-last-change] visits each and\15\nevery point of edit and a message shows what change was made there.\15\nIn this case it may go to the same point twice.\15\n\15\nThis command uses undo information. If undo is disabled, so is this command.\15\nAt times, when undo information becomes too large, the oldest information is\15\ndiscarded. See variable `undo-limit'.\15\n\15\n(fn ARG)" t) (autoload 'goto-last-change-reverse "goto-chg" "\15\nGo back to more recent changes after \\[goto-last-change] have been used.\15\nSee `goto-last-change' for use of prefix argument.\15\n\15\n(fn ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil/evil-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-mode "evil" nil t) (autoload 'evil-digraph "evil-digraphs" "\15\nConvert DIGRAPH to character or list representation.\15\nIf DIGRAPH is a list (CHAR1 CHAR2), return the corresponding character;\15\nif DIGRAPH is a character, return the corresponding list.\15\nSearches in `evil-digraphs-table-user' and `evil-digraphs-table'.\15\n\15\n(fn DIGRAPH)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-org/evil-org-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-org-mode "evil-org" "\15\nBuffer local minor mode for evil-org\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Evil-Org\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `evil-org-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'evil-org-agenda-mode "evil-org-agenda" "\15\nBuffer local minor mode for evil-org-agenda\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Evil-Org-Agenda mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `evil-org-agenda-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/org-cliplink/org-cliplink-autoloads.el") (load-true-file-name load-file-name)) (autoload 'org-cliplink-retrieve-title "org-cliplink" "\15\n\15\n\15\n(fn URL TITLE-CALLBACK)") (autoload 'org-cliplink-insert-transformed-title "org-cliplink" "\15\nTakes the URL, asynchronously retrieves the title and applies\15\na custom TRANSFORMER which transforms the url and title and insert\15\nthe required text to the current buffer.\15\n\15\n(fn URL TRANSFORMER)") (autoload 'org-cliplink-retrieve-title-synchronously "org-cliplink" "\15\n\15\n\15\n(fn URL)") (autoload 'org-cliplink "org-cliplink" "\15\nTakes a URL from the clipboard and inserts an org-mode link\15\nwith the title of a page found by the URL into the current\15\nbuffer" t) (autoload 'org-cliplink-capture "org-cliplink" "\15\norg-cliplink version for org-capture templates.\15\nMakes synchronous request. Returns the link instead of inserting\15\nit to the current buffer. Doesn't support Basic Auth. Doesn't\15\nsupport cURL transport." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/toc-org/toc-org-autoloads.el") (load-true-file-name load-file-name)) (autoload 'toc-org-enable "toc-org" "\15\nEnable toc-org in this buffer.") (autoload 'toc-org-mode "toc-org" "\15\nToggle `toc-org' in this buffer.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Toc-Org\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `toc-org-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/htmlize/htmlize-autoloads.el") (load-true-file-name load-file-name)) (autoload 'htmlize-buffer "htmlize" "\15\nConvert BUFFER to HTML, preserving colors and decorations.\15\n\15\nThe generated HTML is available in a new buffer, which is returned.\15\nWhen invoked interactively (or if optional INTERACTIVE is non-nil),\15\nthe new buffer is selected in the current window.  The title of the\15\ngenerated document will be set to the buffer's file name or, if that\15\nis not available, to the buffer's name.\15\n\15\nNote that htmlize doesn't fontify your buffers, it only uses the\15\ndecorations that are already present.  If you don't set up font-lock or\15\nsomething else to fontify your buffers, the resulting HTML will be\15\nplain.  Likewise, if you don't like the choice of colors, fix the mode\15\nthat created them, or simply alter the faces it uses.\15\n\15\n(fn &optional BUFFER INTERACTIVE)" t) (autoload 'htmlize-region "htmlize" "\15\nConvert the region to HTML, preserving colors and decorations.\15\nSee `htmlize-buffer' for details.\15\n\15\n(fn BEG END &optional INTERACTIVE)" t) (autoload 'htmlize-file "htmlize" "\15\nLoad FILE, fontify it, convert it to HTML, and save the result.\15\n\15\nContents of FILE are inserted into a temporary buffer, whose major mode\15\nis set with `normal-mode' as appropriate for the file type.  The buffer\15\nis subsequently fontified with `font-lock' and converted to HTML.  Note\15\nthat, unlike `htmlize-buffer', this function explicitly turns on\15\nfont-lock.  If a form of highlighting other than font-lock is desired,\15\nplease use `htmlize-buffer' directly on buffers so highlighted.\15\n\15\nBuffers currently visiting FILE are unaffected by this function.  The\15\nfunction does not change current buffer or move the point.\15\n\15\nIf TARGET is specified and names a directory, the resulting file will be\15\nsaved there instead of to FILE's directory.  If TARGET is specified and\15\ndoes not name a directory, it will be used as output file name.\15\n\15\n(fn FILE &optional TARGET)" t) (autoload 'htmlize-many-files "htmlize" "\15\nConvert FILES to HTML and save the corresponding HTML versions.\15\n\15\nFILES should be a list of file names to convert.  This function calls\15\n`htmlize-file' on each file; see that function for details.  When\15\ninvoked interactively, you are prompted for a list of files to convert,\15\nterminated with RET.\15\n\15\nIf TARGET-DIRECTORY is specified, the HTML files will be saved to that\15\ndirectory.  Normally, each HTML file is saved to the directory of the\15\ncorresponding source file.\15\n\15\n(fn FILES &optional TARGET-DIRECTORY)" t) (autoload 'htmlize-many-files-dired "htmlize" "\15\nHTMLize dired-marked files.\15\n\15\n(fn ARG &optional TARGET-DIRECTORY)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/ox-clip/ox-clip-autoloads.el") (load-true-file-name load-file-name)) (autoload 'ox-clip-get-command "ox-clip" "\15\nGet the command form OPTIONS.\15\nOPTIONS is one of `ox-clip-w32-cmd', `ox-clip-osx-cmd', or\15\n`ox-clip-linux-cmd'. Those may be a string, or a list of\15\ncandidates to choose from.\15\n\15\n(fn OPTIONS)") (autoload 'ox-clip-formatted-copy "ox-clip" "\15\nExport the selected region to HTML and copy it to the clipboard.\15\nR1 and R2 define the selected region.\15\n\15\nIf SUBTREEP (interactively, the prefix argument) is non-nil then\15\nexport the current `org-mode' subtree, including hidden content.\15\n\15\n(fn R1 R2 &optional SUBTREEP)" t) (autoload 'ox-clip-image-to-clipboard "ox-clip" "\15\nCopy the image file or latex fragment at point to the clipboard as an image.\15\nSCALE is a numerical\15\nprefix (default=`ox-clip-default-latex-scale') that determines\15\nthe size of the latex image. It has no effect on other kinds of\15\nimages. Currently only works on Linux.\15\n\15\n(fn &optional SCALE)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/org-contrib/org-contrib-autoloads.el") (load-true-file-name load-file-name)) (autoload 'org-annotate-file "org-annotate-file" "\15\nVisit `org-annotate-file-storage-file` and add a new annotation section.\15\nThe annotation is opened at the new section which will be referencing\15\nthe point in the current file." t) (autoload 'org-annotate-file-show-section "org-annotate-file" "\15\nAdd or show annotation entry in STORAGE-FILE and return the buffer.\15\nThe annotation will link to ANNOTATED-BUFFER if specified,\15\n  otherwise the current buffer is used.\15\n\15\n(fn STORAGE-FILE &optional ANNOTATED-BUFFER)") (autoload 'org-eldoc-load "org-eldoc" "\15\nSet up org-eldoc documentation function." t) (autoload 'org-registry-show "org-registry" "\15\nShow Org files where there are links pointing to the current\15\nbuffer.\15\n\15\n(fn &optional VISIT)" t) (autoload 'org-registry-visit "org-registry" "\15\nIf an Org file contains a link to the current location, visit\15\nthis file." t) (autoload 'org-registry-initialize "org-registry" "\15\nInitialize `org-registry-alist'.\15\nIf FROM-SCRATCH is non-nil or the registry does not exist yet,\15\ncreate a new registry from scratch and eval it. If the registry\15\nexists, eval `org-registry-file' and make it the new value for\15\n`org-registry-alist'.\15\n\15\n(fn &optional FROM-SCRATCH)" t) (autoload 'org-registry-insinuate "org-registry" "\15\nCall `org-registry-update' after saving in Org-mode.\15\nUse with caution.  This could slow down things a bit." t) (autoload 'org-registry-update "org-registry" "\15\nUpdate the registry for the current Org file." t) (autoload 'org-screenshot-take "org-screenshot" "\15\nTake a screenshot and insert link to it at point, if image\15\ndisplay is already on (see \\[org-toggle-inline-images])\15\nscreenshot will be displayed as an image\15\n\15\nScreen area for the screenshot is selected with the mouse, left\15\nclick on a window screenshots that window, while left click and\15\ndrag selects a region. Pressing any key cancels the screen shot\15\n\15\nWith `C-u' universal argument waits one second after target is\15\nselected before taking the screenshot. With double `C-u' wait two\15\nseconds.\15\n\15\nWith triple `C-u' wait 3 seconds, and also rings the bell when\15\nscreenshot is done, any more `C-u' after that increases delay by\15\n2 seconds\15\n\15\n(fn &optional DELAY)" t) (autoload 'org-screenshot-rotate-prev "org-screenshot" "\15\nRotate last screenshot with one of the previously taken\15\nscreenshots from the same directory. If DIR is negative, rotate\15\nin the other direction\15\n\15\n(fn DIR)" t) (autoload 'org-screenshot-rotate-next "org-screenshot" "\15\nRotate last screenshot with one of the previously taken\15\nscreenshots from the same directory. If DIR is negative, rotate\15\nin the other direction\15\n\15\n(fn DIR)" t) (autoload 'org-screenshot-show-unused "org-screenshot" "\15\nOpen A Dired buffer with unused screenshots marked" t) (autoload 'org-toc-show "org-toc" "\15\nShow the table of contents of the current Org-mode buffer.\15\n\15\n(fn &optional DEPTH POSITION)" t) (autoload 'org-freemind-export-to-freemind "ox-freemind" "\15\nExport current buffer to a Freemind Mindmap file.\15\n\15\nIf narrowing is active in the current buffer, only export its\15\nnarrowed part.\15\n\15\nIf a region is active, export that region.\15\n\15\nA non-nil optional argument ASYNC means the process should happen\15\nasynchronously.  The resulting file should be accessible through\15\nthe `org-export-stack' interface.\15\n\15\nWhen optional argument SUBTREEP is non-nil, export the sub-tree\15\nat point, extracting information from the headline properties\15\nfirst.\15\n\15\nWhen optional argument VISIBLE-ONLY is non-nil, don't export\15\ncontents of hidden elements.\15\n\15\nWhen optional argument BODY-ONLY is non-nil, only write code\15\nbetween \"<body>\" and \"</body>\" tags.\15\n\15\nEXT-PLIST, when provided, is a property list with external\15\nparameters overriding Org default settings, but still inferior to\15\nfile-local settings.\15\n\15\nReturn output file's name.\15\n\15\n(fn &optional ASYNC SUBTREEP VISIBLE-ONLY BODY-ONLY EXT-PLIST)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-markdown/evil-markdown-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-markdown-mode "evil-markdown" "\15\nBuffer local minor mode for evil-markdown\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Evil-Markdown mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `evil-markdown-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'evil-markdown-set-key-theme "evil-markdown" "\15\nSelect what key THEMEs to enable.\15\n\15\n(fn THEME)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/edit-indirect/edit-indirect-autoloads.el") (load-true-file-name load-file-name)) (autoload 'edit-indirect-region "edit-indirect" "\15\nEdit the region BEG..END in a separate buffer.\15\nThe region is copied, without text properties, to a separate\15\nbuffer, called edit-indirect buffer, and\15\n`edit-indirect-guess-mode-function' is called to set the major\15\nmode.\15\nWhen done, exit with `edit-indirect-commit', which will remove the\15\noriginal region and replace it with the edited version; or with\15\n`edit-indirect-abort', which will drop the modifications.\15\n\15\nThis differs from `clone-indirect-buffer' with narrowing in that\15\nthe text properties are not shared, so the parent buffer major mode\15\nand the edit-indirect buffer major mode will not be able to tread\15\non each other's toes by setting up potentially conflicting text\15\nproperties, which happens surprisingly often when the font-lock\15\nmode is used.\15\n\15\nEdit-indirect buffers use the `edit-indirect-mode-map' keymap.\15\nRegions with active edit-indirect buffers use the\15\n`edit-indirect-overlay-map' keymap.\15\n\15\nIf there's already an edit-indirect buffer for BEG..END, use that.\15\nIf there's already an edit-indirect buffer active overlapping any\15\nportion of BEG..END, an `edit-indirect-overlapping' error is\15\nsignaled.\15\n\15\nWhen DISPLAY-BUFFER is non-nil or when called interactively,\15\ndisplay the edit-indirect buffer in some window and select it.\15\n\15\nIn any case, return the edit-indirect buffer.\15\n\15\n(fn BEG END &optional DISPLAY-BUFFER)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/markdown-mode/markdown-mode-autoloads.el") (load-true-file-name load-file-name)) (autoload 'markdown-mode "markdown-mode" "\15\nMajor mode for editing Markdown files.\15\n\15\n(fn)" t) (autoload 'gfm-mode "markdown-mode" "\15\nMajor mode for editing GitHub Flavored Markdown files.\15\n\15\n(fn)" t) (autoload 'markdown-view-mode "markdown-mode" "\15\nMajor mode for viewing Markdown content.\15\n\15\n(fn)" t) (autoload 'gfm-view-mode "markdown-mode" "\15\nMajor mode for viewing GitHub Flavored Markdown content.\15\n\15\n(fn)" t) (autoload 'markdown-live-preview-mode "markdown-mode" "\15\nToggle native previewing on save for a specific markdown file.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Markdown-Live-Preview mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `markdown-live-preview-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/markdown-toc/markdown-toc-autoloads.el") (load-true-file-name load-file-name)) (autoload 'markdown-toc-version "markdown-toc" "\15\nMarkdown-toc version." t) (autoload 'markdown-toc-generate-toc "markdown-toc" "\15\nGenerate a TOC for markdown file at current point.\15\nDeletes any previous TOC." t) (autoload 'markdown-toc-generate-or-refresh-toc "markdown-toc" "\15\nGenerate a TOC for markdown file at current point or refreshes it." t) (autoload 'markdown-toc-refresh-toc "markdown-toc" "\15\nRefreshes an already generated TOC." t) (autoload 'markdown-toc-delete-toc "markdown-toc" "\15\nDeletes a previously generated TOC." t) (autoload 'markdown-toc-follow-link-at-point "markdown-toc" "\15\nOn a given toc link, navigate to the current markdown header.\15\nIf the toc is misindented (according to `markdown-toc-indentation-space')\15\nor if not on a toc link, this does nothing." t) (autoload 'markdown-toc-mode "markdown-toc" "\15\nFunctionality for generating toc in markdown file.\15\n\15\nWith no argument, the mode is toggled on/off.\15\nNon-nil argument turns mode on.\15\nNil argument turns mode off.\15\n\15\nCommands:\15\n\\{markdown-toc-mode-map}\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Markdown-Toc\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `markdown-toc-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/buttercup/buttercup-autoloads.el") (load-true-file-name load-file-name)) (autoload 'buttercup-run-at-point "buttercup" "\15\nRun the buttercup suite at point." t) (autoload 'buttercup-run-discover "buttercup" "\15\nDiscover and load test files, then run all defined suites.\15\n\15\nTakes directories as command line arguments, defaulting to the\15\ncurrent directory.") (autoload 'buttercup-run-markdown-buffer "buttercup" "\15\nRun all test suites defined in MARKDOWN-BUFFERS.\15\nA suite must be defined within a Markdown \"lisp\" code block.\15\nIf MARKDOWN-BUFFERS is empty (nil), use the current buffer.\15\n\15\n(fn &rest MARKDOWN-BUFFERS)" t) (autoload 'buttercup-run-markdown "buttercup" "\15\nRun all test suites defined in Markdown files passed as arguments.\15\nA suite must be defined within a Markdown \"lisp\" code block.") (autoload 'buttercup-run-markdown-file "buttercup" "\15\nRun all test suites defined in Markdown FILE.\15\nA suite must be defined within a Markdown \"lisp\" code block.\15\n\15\n(fn FILE)" t) (autoload 'buttercup-minor-mode "buttercup" "\15\nActivate buttercup minor mode.\15\n\15\nWith buttercup minor mode active the following is activated:\15\n\15\n- `describe' and `it' forms are fontified with\15\n  `font-lock-keyword-face'.\15\n- `describe' and `it' forms are available from `imenu' for\15\n  quicker access.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Buttercup\15\nminor mode' mode.  If the prefix argument is positive, enable the mode,\15\nand if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `buttercup-minor-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/package-lint/package-lint-autoloads.el") (load-true-file-name load-file-name)) (autoload 'package-lint-describe-symbol-history "package-lint" "\15\nShow the version history of SYM, if any.\15\n\15\n(fn SYM)" t) (autoload 'package-lint-buffer "package-lint" "\15\nGet linter errors and warnings for BUFFER.\15\n\15\nReturns a list, each element of which is list of\15\n\15\n   (LINE COL TYPE MESSAGE)\15\n\15\nwhere TYPE is either `warning' or `error'.\15\n\15\nCurrent buffer is used if none is specified.\15\n\15\n(fn &optional BUFFER)") (autoload 'package-lint-current-buffer "package-lint" "\15\nDisplay lint errors and warnings for the current buffer." t) (autoload 'package-lint-batch-and-exit "package-lint" "\15\nRun `package-lint-buffer' on the files remaining on the command line.\15\nUse this only with -batch, it won't work interactively.\15\n\15\nWhen done, exit Emacs with status 1 in case of any errors, otherwise exit\15\nwith status 0.  The variable `package-lint-batch-fail-on-warnings' controls\15\nwhether or not warnings alone produce a non-zero exit code.") (autoload 'package-lint-looks-like-a-package-p "package-lint" "\15\nReturn non-nil if the current buffer appears to be intended as a package.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/flycheck/flycheck-autoloads.el") (load-true-file-name load-file-name)) (autoload 'flycheck-manual "flycheck" "\15\nOpen the Flycheck manual." t) (autoload 'flycheck-quick-help "flycheck" "\15\nDisplay brief Flycheck help." t) (autoload 'flycheck-mode "flycheck" "\15\nFlycheck is a minor mode for on-the-fly syntax checking.\15\n\15\nIn `flycheck-mode' the buffer is automatically syntax-checked\15\nusing the first suitable syntax checker from `flycheck-checkers'.\15\nUse `flycheck-select-checker' to select a checker for the current\15\nbuffer manually.\15\n\15\nIf you run into issues, use `\\[flycheck-verify-setup]' to get help.\15\n\15\nFlycheck supports many languages out of the box, and many\15\nadditional ones are available on MELPA.  Adding new ones is very\15\neasy.  Complete documentation is available online at URL\15\n`https://www.flycheck.org/en/latest/'.  Please report issues and\15\nrequest features at URL `https://github.com/flycheck/flycheck'.\15\n\15\nFlycheck displays its status in the mode line.  In the default\15\nconfiguration, it looks like this:\15\n\15\n`FlyC'     This buffer has not been checked yet.\15\n`FlyC*'    Flycheck is running.  Expect results soon!\15\n`FlyC:0'   Last check resulted in no errors and no warnings.\15\n`FlyC:3|5' This buffer contains three errors and five warnings.\15\n           Use `\\[flycheck-list-errors]' to see the list.\15\n`FlyC-'    Flycheck doesn't have a checker for this buffer.\15\n\15\nYou may also see the following icons:\15\n`FlyC!'    The checker crashed.\15\n`FlyC.'    The last syntax check was manually interrupted.\15\n`FlyC?'    The checker did something unexpected, like exiting with 1\15\n           but returning no errors.\15\n\15\nThe following keybindings are available in `flycheck-mode':\15\n\15\n\\{flycheck-mode-map}\15\n(you can change the prefix by customizing\15\n`flycheck-keymap-prefix')\15\n\15\nIf called interactively, enable Flycheck mode if ARG is positive,\15\nand disable it if ARG is zero or negative.  If called from Lisp,\15\nalso enable the mode if ARG is omitted or nil, and toggle it if\15\nARG is \x2018toggle\x2019; disable the mode otherwise.\15\n\15\n(fn &optional ARG)" t) (put 'global-flycheck-mode 'globalized-minor-mode t) (defvar global-flycheck-mode nil "\15\nNon-nil if Global Flycheck mode is enabled.\15\nSee the `global-flycheck-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-flycheck-mode'.") (autoload 'global-flycheck-mode "flycheck" "\15\nToggle Flycheck mode in all buffers.\15\nWith prefix ARG, enable Global Flycheck mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nFlycheck mode is enabled in all buffers where `flycheck-mode-on-safe'\15\nwould do it.\15\n\15\nSee `flycheck-mode' for more information on Flycheck mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'flycheck-define-error-level "flycheck" "\15\nDefine a new error LEVEL with PROPERTIES.\15\n\15\nThe following PROPERTIES constitute an error level:\15\n\15\n`:severity SEVERITY'\15\n     A number denoting the severity of this level.  The higher\15\n     the number, the more severe is this level compared to other\15\n     levels.  Defaults to 0; info is -10, warning is 10, and\15\n     error is 100.\15\n\15\n     The severity is used by `flycheck-error-level-<' to\15\n     determine the ordering of errors according to their levels.\15\n\15\n`:compilation-level LEVEL'\15\n\15\n     A number indicating the broad class of messages that errors\15\n     at this level belong to: one of 0 (info), 1 (warning), or\15\n     2 or nil (error).  Defaults to nil.\15\n\15\n     This is used by `flycheck-checker-pattern-to-error-regexp'\15\n     to map error levels into `compilation-mode''s hierarchy and\15\n     to get proper highlighting of errors in `compilation-mode'.\15\n\15\n`:overlay-category CATEGORY'\15\n     A symbol denoting the overlay category to use for error\15\n     highlight overlays for this level.  See Info\15\n     node `(elisp)Overlay Properties' for more information about\15\n     overlay categories.\15\n\15\n     A category for an error level overlay should at least define\15\n     the `face' property, for error highlighting.  Another useful\15\n     property for error level categories is `priority', to\15\n     influence the stacking of multiple error level overlays.\15\n\15\n`:fringe-bitmap BITMAPS'\15\n     A fringe bitmap symbol denoting the bitmap to use for fringe\15\n     indicators for this level, or a cons of two bitmaps (one for\15\n     narrow fringes and one for wide fringes).  See Info node\15\n     `(elisp)Fringe Bitmaps' for more information about fringe\15\n     bitmaps, including a list of built-in fringe bitmaps.\15\n\15\n`:fringe-face FACE'\15\n     A face symbol denoting the face to use for fringe indicators\15\n     for this level.\15\n\15\n`:margin-spec SPEC'\15\n     A display specification indicating what to display in the\15\n     margin when `flycheck-indication-mode' is `left-margin' or\15\n     `right-margin'.  See Info node `(elisp)Displaying in the\15\n     Margins'.  If omitted, Flycheck generates an image spec from\15\n     the fringe bitmap.\15\n\15\n`:error-list-face FACE'\15\n     A face symbol denoting the face to use for messages of this\15\n     level in the error list.  See `flycheck-list-errors'.\15\n\15\n(fn LEVEL &rest PROPERTIES)") (function-put 'flycheck-define-error-level 'lisp-indent-function 1) (autoload 'flycheck-define-command-checker "flycheck" "\15\nDefine SYMBOL as syntax checker to run a command.\15\n\15\nDefine SYMBOL as generic syntax checker via\15\n`flycheck-define-generic-checker', which uses an external command\15\nto check the buffer.  SYMBOL and DOCSTRING are the same as for\15\n`flycheck-define-generic-checker'.\15\n\15\nIn addition to the properties understood by\15\n`flycheck-define-generic-checker', the following PROPERTIES\15\nconstitute a command syntax checker.  Unless otherwise noted, all\15\nproperties are mandatory.  Note that the default `:error-filter'\15\nof command checkers is `flycheck-sanitize-errors'.\15\n\15\n`:command COMMAND'\15\n     The command to run for syntax checking.\15\n\15\n     COMMAND is a list of the form `(EXECUTABLE [ARG ...])'.\15\n\15\n     EXECUTABLE is a string with the executable of this syntax\15\n     checker.  It can be overridden with the variable\15\n     `flycheck-SYMBOL-executable'.  Note that this variable is\15\n     NOT implicitly defined by this function.  Use\15\n     `flycheck-def-executable-var' to define this variable.\15\n\15\n     Each ARG is an argument to the executable, either as string,\15\n     or as special symbol or form for\15\n     `flycheck-substitute-argument', which see.\15\n\15\n`:error-patterns PATTERNS'\15\n     A list of patterns to parse the output of the `:command'.\15\n\15\n     Each ITEM in PATTERNS is a list `(LEVEL SEXP ...)', where\15\n     LEVEL is a Flycheck error level (see\15\n     `flycheck-define-error-level'), followed by one or more RX\15\n     `SEXP's which parse an error of that level and extract line,\15\n     column, file name and the message.\15\n\15\n     See `rx' for general information about RX, and\15\n     `flycheck-rx-to-string' for some special RX forms provided\15\n     by Flycheck.\15\n\15\n     All patterns are applied in the order of declaration to the\15\n     whole output of the syntax checker.  Output already matched\15\n     by a pattern will not be matched by subsequent patterns.  In\15\n     other words, the first pattern wins.\15\n\15\n     This property is optional.  If omitted, however, an\15\n     `:error-parser' is mandatory.\15\n\15\n`:error-parser FUNCTION'\15\n     A function to parse errors with.\15\n\15\n     The function shall accept three arguments OUTPUT CHECKER\15\n     BUFFER.  OUTPUT is the syntax checker output as string,\15\n     CHECKER the syntax checker that was used, and BUFFER a\15\n     buffer object representing the checked buffer.  The function\15\n     must return a list of `flycheck-error' objects parsed from\15\n     OUTPUT.\15\n\15\n     This property is optional.  If omitted, it defaults to\15\n     `flycheck-parse-with-patterns'.  In this case,\15\n     `:error-patterns' is mandatory.\15\n\15\n`:standard-input t'\15\n     Whether to send the buffer contents on standard input.\15\n\15\n     If this property is given and has a non-nil value, send the\15\n     contents of the buffer on standard input.\15\n\15\n     Some checkers that support reading from standard input have\15\n     a separate flag to indicate the name of the file whose\15\n     contents are being passed on standard input (typically\15\n     `stdin-filename').  In that case, use the `(option)' form in\15\n     `:command' to pass the value of variable `buffer-file-name'\15\n     when the current buffer has a file name (that is,\15\n     use `option \"--stdin-file-name\" buffer-file-name').\15\n\15\n     For buffers not backed by files, checkers that support input\15\n     on stdin typically report a file name like `-' or `<stdin>'.\15\n     Make sure your error parser or patterns expect these file\15\n     names (for example, use `(or \"<stdin>\" (file-name))') or\15\n     call `flycheck-remove-error-file-names' in a custom\15\n     `:error-filter'.\15\n\15\n     Defaults to nil.\15\n\15\nNote that you may not give `:start', `:interrupt', and\15\n`:print-doc' for a command checker.  You can give a custom\15\n`:verify' function, though, whose results will be appended to the\15\ndefault `:verify' function of command checkers.\15\n\15\n(fn SYMBOL DOCSTRING &rest PROPERTIES)") (function-put 'flycheck-define-command-checker 'lisp-indent-function 1) (function-put 'flycheck-define-command-checker 'doc-string-elt 2) (autoload 'flycheck-def-config-file-var "flycheck" "\15\nDefine SYMBOL as config file variable for CHECKER, with default FILE-NAME.\15\n\15\nSYMBOL is declared as customizable variable using `defcustom', to\15\nprovide configuration files for the given syntax CHECKER.\15\nCUSTOM-ARGS are forwarded to `defcustom'.\15\n\15\nFILE-NAME is the initial value of the new variable.  If omitted,\15\nthe default value is nil.  It can be either a string or a list of\15\nstrings.\15\n\15\nUse this together with the `config-file' form in the `:command'\15\nargument to `flycheck-define-checker'.\15\n\15\n(fn SYMBOL CHECKER &optional FILE-NAME &rest CUSTOM-ARGS)" nil t) (function-put 'flycheck-def-config-file-var 'lisp-indent-function 3) (autoload 'flycheck-def-option-var "flycheck" "\15\nDefine SYMBOL as option variable with INIT-VALUE for CHECKER.\15\n\15\nSYMBOL is declared as customizable variable using `defcustom', to\15\nprovide an option for the given syntax CHECKERS (a checker or a\15\nlist of checkers).  INIT-VALUE is the initial value of the\15\nvariable, and DOCSTRING is its docstring.  CUSTOM-ARGS are\15\nforwarded to `defcustom'.\15\n\15\nUse this together with the `option', `option-list' and\15\n`option-flag' forms in the `:command' argument to\15\n`flycheck-define-checker'.\15\n\15\n(fn SYMBOL INIT-VALUE CHECKERS DOCSTRING &rest CUSTOM-ARGS)" nil t) (function-put 'flycheck-def-option-var 'lisp-indent-function 3) (function-put 'flycheck-def-option-var 'doc-string-elt 4) (autoload 'flycheck-define-checker "flycheck" "\15\nDefine SYMBOL as command syntax checker with DOCSTRING and PROPERTIES.\15\n\15\nLike `flycheck-define-command-checker', but PROPERTIES must not\15\nbe quoted.  Also, implicitly define the executable variable for\15\nSYMBOL with `flycheck-def-executable-var'.\15\n\15\n(fn SYMBOL DOCSTRING &rest PROPERTIES)" nil t) (function-put 'flycheck-define-checker 'lisp-indent-function 1) (function-put 'flycheck-define-checker 'doc-string-elt 2) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/flycheck-package/flycheck-package-autoloads.el") (load-true-file-name load-file-name)) (autoload 'flycheck-package-setup "flycheck-package" "\15\nSetup flycheck-package.\15\nAdd `flycheck-emacs-lisp-package' to `flycheck-checkers'." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/elisp-demos/elisp-demos-autoloads.el") (load-true-file-name load-file-name)) (autoload 'elisp-demos-advice-describe-function-1 "elisp-demos" "\15\n\15\n\15\n(fn FUNCTION)") (autoload 'elisp-demos-advice-helpful-update "elisp-demos") (autoload 'elisp-demos-for-helpful "elisp-demos" "\15\nFind a demo for the current `helpful' buffer." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/elisp-def/elisp-def-autoloads.el") (load-true-file-name load-file-name)) (autoload 'elisp-def "elisp-def" "\15\nGo to the definition of the symbol at point." t) (autoload 'elisp-def-mode "elisp-def" "\15\nMinor mode for finding definitions with `elisp-def'.\15\n\15\n\\{elisp-def-mode-map}\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Elisp-Def\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `elisp-def-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/pkg-info/pkg-info-autoloads.el") (load-true-file-name load-file-name)) (autoload 'pkg-info-library-original-version "pkg-info" "\15\nGet the original version in the header of LIBRARY.\15\n\15\nThe original version is stored in the X-Original-Version header.\15\nThis header is added by the MELPA package archive to preserve\15\nupstream version numbers.\15\n\15\nLIBRARY is either a symbol denoting a named feature, or a library\15\nname as string.\15\n\15\nIf SHOW is non-nil, show the version in the minibuffer.\15\n\15\nReturn the version from the header of LIBRARY as list.  Signal an\15\nerror if the LIBRARY was not found or had no X-Original-Version\15\nheader.\15\n\15\nSee Info node `(elisp)Library Headers' for more information\15\nabout library headers.\15\n\15\n(fn LIBRARY &optional SHOW)" t) (autoload 'pkg-info-library-version "pkg-info" "\15\nGet the version in the header of LIBRARY.\15\n\15\nLIBRARY is either a symbol denoting a named feature, or a library\15\nname as string.\15\n\15\nIf SHOW is non-nil, show the version in the minibuffer.\15\n\15\nReturn the version from the header of LIBRARY as list.  Signal an\15\nerror if the LIBRARY was not found or had no proper header.\15\n\15\nSee Info node `(elisp)Library Headers' for more information\15\nabout library headers.\15\n\15\n(fn LIBRARY &optional SHOW)" t) (autoload 'pkg-info-defining-library-original-version "pkg-info" "\15\nGet the original version of the library defining FUNCTION.\15\n\15\nThe original version is stored in the X-Original-Version header.\15\nThis header is added by the MELPA package archive to preserve\15\nupstream version numbers.\15\n\15\nIf SHOW is non-nil, show the version in mini-buffer.\15\n\15\nThis function is mainly intended to find the version of a major\15\nor minor mode, i.e.\15\n\15\n   (pkg-info-defining-library-version 'flycheck-mode)\15\n\15\nReturn the version of the library defining FUNCTION.  Signal an\15\nerror if FUNCTION is not a valid function, if its defining\15\nlibrary was not found, or if the library had no proper version\15\nheader.\15\n\15\n(fn FUNCTION &optional SHOW)" t) (autoload 'pkg-info-defining-library-version "pkg-info" "\15\nGet the version of the library defining FUNCTION.\15\n\15\nIf SHOW is non-nil, show the version in mini-buffer.\15\n\15\nThis function is mainly intended to find the version of a major\15\nor minor mode, i.e.\15\n\15\n   (pkg-info-defining-library-version 'flycheck-mode)\15\n\15\nReturn the version of the library defining FUNCTION.  Signal an\15\nerror if FUNCTION is not a valid function, if its defining\15\nlibrary was not found, or if the library had no proper version\15\nheader.\15\n\15\n(fn FUNCTION &optional SHOW)" t) (autoload 'pkg-info-package-version "pkg-info" "\15\nGet the version of an installed PACKAGE.\15\n\15\nIf SHOW is non-nil, show the version in the minibuffer.\15\n\15\nReturn the version as list, or nil if PACKAGE is not installed.\15\n\15\n(fn PACKAGE &optional SHOW)" t) (autoload 'pkg-info-version-info "pkg-info" "\15\nObtain complete version info for LIBRARY and PACKAGE.\15\n\15\nLIBRARY is a symbol denoting a named feature, or a library name\15\nas string.  PACKAGE is a symbol denoting an ELPA package.  If\15\nomitted or nil, default to LIBRARY.\15\n\15\nIf SHOW is non-nil, show the version in the minibuffer.\15\n\15\nWhen called interactively, prompt for LIBRARY.  When called\15\ninteractively with prefix argument, prompt for PACKAGE as well.\15\n\15\nReturn a string with complete version information for LIBRARY.\15\nThis version information contains the version from the headers of\15\nLIBRARY, and the version of the installed PACKAGE, the LIBRARY is\15\npart of.  If PACKAGE is not installed, or if the PACKAGE version\15\nis the same as the LIBRARY version, do not include a package\15\nversion.\15\n\15\n(fn LIBRARY &optional PACKAGE SHOW)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/overseer/overseer-autoloads.el") (load-true-file-name load-file-name)) (autoload 'overseer-version "overseer" "\15\nGet the Overseer version as string.\15\n\15\nIf called interactively or if SHOW-VERSION is non-nil, show the\15\nversion in the echo area and the messages buffer.\15\n\15\nThe returned string includes both, the version from package.el\15\nand the library version, if both a present and different.\15\n\15\nIf the version number could not be determined, signal an error,\15\nif called interactively, or if SHOW-VERSION is non-nil, otherwise\15\njust return nil.\15\n\15\n(fn &optional SHOW-VERSION)" t) (autoload 'overseer-mode "overseer" "\15\nMinor mode for emacs lisp files to test through ert-runner.\15\n\15\nKey bindings:\15\n\\{overseer-mode-map}\15\n\15\nThis is a minor mode.  If called interactively, toggle the `overseer\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `overseer-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'overseer-enable-mode "overseer") (dolist (hook '(emacs-lisp-mode-hook)) (add-hook hook 'overseer-enable-mode)) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/macrostep/macrostep-autoloads.el") (load-true-file-name load-file-name)) (autoload 'macrostep-mode "macrostep" "\15\nMinor mode for inline expansion of macros in Emacs Lisp source buffers.\15\n\15\n\\<macrostep-mode-map>Progressively expand macro forms with \\[macrostep-expand], collapse them with \\[macrostep-collapse],\15\nand move back and forth with \\[macrostep-next-macro] and \\[macrostep-prev-macro].  Use \\[macrostep-collapse-all] or collapse all\15\nvisible expansions to quit and return to normal editing.\15\n\15\n\\{macrostep-mode-map}\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Macrostep\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `macrostep-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'macrostep-expand "macrostep" "\15\nExpand the macro form following point by one step.\15\n\15\nEnters `macrostep-mode' if it is not already active, making the\15\nbuffer temporarily read-only.  If `macrostep-mode' is active and\15\nthe form following point is not a macro form, search forward in\15\nthe buffer and expand the next macro form found, if any.\15\n\15\nIf optional argument TOGGLE-SEPARATE-BUFFER is non-nil (or set\15\n with a prefix argument), the expansion is displayed in a\15\n separate buffer instead of inline in the current buffer.\15\n Setting `macrostep-expand-in-separate-buffer' to non-nil swaps\15\n these two behaviors.\15\n\15\n(fn &optional TOGGLE-SEPARATE-BUFFER)" t) (autoload 'macrostep-c-mode-hook "macrostep-c") (add-hook 'c-mode-hook #'macrostep-c-mode-hook) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/elisp-refs/elisp-refs-autoloads.el") (load-true-file-name load-file-name)) (autoload 'elisp-refs-function "elisp-refs" "\15\nDisplay all the references to function SYMBOL, in all loaded\15\nelisp files.\15\n\15\nIf called with a prefix, prompt for a directory to limit the search.\15\n\15\nThis searches for functions, not macros. For that, see\15\n`elisp-refs-macro'.\15\n\15\n(fn SYMBOL &optional PATH-PREFIX)" t) (autoload 'elisp-refs-macro "elisp-refs" "\15\nDisplay all the references to macro SYMBOL, in all loaded\15\nelisp files.\15\n\15\nIf called with a prefix, prompt for a directory to limit the search.\15\n\15\nThis searches for macros, not functions. For that, see\15\n`elisp-refs-function'.\15\n\15\n(fn SYMBOL &optional PATH-PREFIX)" t) (autoload 'elisp-refs-special "elisp-refs" "\15\nDisplay all the references to special form SYMBOL, in all loaded\15\nelisp files.\15\n\15\nIf called with a prefix, prompt for a directory to limit the search.\15\n\15\n(fn SYMBOL &optional PATH-PREFIX)" t) (autoload 'elisp-refs-variable "elisp-refs" "\15\nDisplay all the references to variable SYMBOL, in all loaded\15\nelisp files.\15\n\15\nIf called with a prefix, prompt for a directory to limit the search.\15\n\15\n(fn SYMBOL &optional PATH-PREFIX)" t) (autoload 'elisp-refs-symbol "elisp-refs" "\15\nDisplay all the references to SYMBOL in all loaded elisp files.\15\n\15\nIf called with a prefix, prompt for a directory to limit the\15\nsearch.\15\n\15\n(fn SYMBOL &optional PATH-PREFIX)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/helpful/helpful-autoloads.el") (load-true-file-name load-file-name)) (autoload 'helpful-function "helpful" "\15\nShow help for function named SYMBOL.\15\n\15\nSee also `helpful-macro', `helpful-command' and `helpful-callable'.\15\n\15\n(fn SYMBOL)" t) (autoload 'helpful-command "helpful" "\15\nShow help for interactive function named SYMBOL.\15\n\15\nSee also `helpful-function'.\15\n\15\n(fn SYMBOL)" t) (autoload 'helpful-key "helpful" "\15\nShow help for interactive command bound to KEY-SEQUENCE.\15\n\15\n(fn KEY-SEQUENCE)" t) (autoload 'helpful-macro "helpful" "\15\nShow help for macro named SYMBOL.\15\n\15\n(fn SYMBOL)" t) (autoload 'helpful-callable "helpful" "\15\nShow help for function, macro or special form named SYMBOL.\15\n\15\nSee also `helpful-macro', `helpful-function' and `helpful-command'.\15\n\15\n(fn SYMBOL)" t) (autoload 'helpful-symbol "helpful" "\15\nShow help for SYMBOL, a variable, function, macro, or face.\15\n\15\nSee also `helpful-callable' and `helpful-variable'.\15\n\15\n(fn SYMBOL)" t) (autoload 'helpful-variable "helpful" "\15\nShow help for variable named SYMBOL.\15\n\15\n(fn SYMBOL)" t) (autoload 'helpful-at-point "helpful" "\15\nShow help for the symbol at point." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/highlight-quoted/highlight-quoted-autoloads.el") (load-true-file-name load-file-name)) (autoload 'highlight-quoted-mode "highlight-quoted" "\15\nHighlight Lisp quotes and quoted symbols.\15\n\15\nToggle Highlight-Quoted mode on or off.\15\nWith a prefix argument ARG, enable Highlight-Quoted mode if ARG is positive, and\15\ndisable it otherwise.  If called from Lisp, enable the mode if ARG is omitted or\15\nnil, and toggle it if ARG is `toggle'.\15\n\\{highlight-quoted-mode-map}\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/request/request-autoloads.el") (load-true-file-name load-file-name)) (autoload 'request-response-header "request" "\15\nFetch the values of RESPONSE header field named FIELD-NAME.\15\n\15\nIt returns comma separated values when the header has multiple\15\nfield with the same name, as :RFC:`2616` specifies.\15\n\15\nExamples::\15\n\15\n  (request-response-header response\15\n                           \"content-type\") ; => \"text/html; charset=utf-8\"\15\n  (request-response-header response\15\n                           \"unknown-field\") ; => nil\15\n\15\n(fn RESPONSE FIELD-NAME)") (autoload 'request-response-headers "request" "\15\nReturn RESPONSE headers as an alist.\15\nI would have chosen a function name that wasn't so suggestive that\15\n`headers` is a member of the `request-response` struct, but\15\nas there's already precedent with `request-response-header', I\15\nhew to consistency.\15\n\15\n(fn RESPONSE)") (autoload 'request "request" "\15\nMain entry requesting URL with property list SETTINGS as follow.\15\n\15\n==================== ========================================================\15\nKeyword argument      Explanation\15\n==================== ========================================================\15\nTYPE          (string)   type of request to make: POST/GET/PUT/DELETE\15\nPARAMS         (alist)   set \"?key=val\" part in URL\15\nDATA    (string/alist)   data to be sent to the server\15\nFILES          (alist)   files to be sent to the server (see below)\15\nPARSER        (symbol)   a function that reads current buffer and return data\15\nHEADERS        (alist)   additional headers to send with the request\15\nENCODING      (symbol)   encoding for request body (utf-8 by default)\15\nSUCCESS     (function)   called on success\15\nERROR       (function)   called on error\15\nCOMPLETE    (function)   called on both success and error\15\nTIMEOUT       (number)   timeout in second\15\nSTATUS-CODE    (alist)   map status code (int) to callback\15\nSYNC            (bool)   If non-nil, wait until request is done. Default is nil.\15\n==================== ========================================================\15\n\15\n\15\n* Callback functions\15\n\15\nCallback functions STATUS, ERROR, COMPLETE and `cdr\\='s in element of\15\nthe alist STATUS-CODE take same keyword arguments listed below.  For\15\nforward compatibility, these functions must ignore unused keyword\15\narguments (i.e., it\\='s better to use `&allow-other-keys\\=' [#]_).::\15\n\15\n    (CALLBACK                      ; SUCCESS/ERROR/COMPLETE/STATUS-CODE\15\n     :data          data           ; whatever PARSER function returns, or nil\15\n     :error-thrown  error-thrown   ; (ERROR-SYMBOL . DATA), or nil\15\n     :symbol-status symbol-status  ; success/error/timeout/abort/parse-error\15\n     :response      response       ; request-response object\15\n     ...)\15\n\15\n.. [#] `&allow-other-keys\\=' is a special \"markers\" available in macros\15\n   in the CL library for function definition such as `cl-defun\\=' and\15\n   `cl-function\\='.  Without this marker, you need to specify all arguments\15\n   to be passed.  This becomes problem when request.el adds new arguments\15\n   when calling callback functions.  If you use `&allow-other-keys\\='\15\n   (or manually ignore other arguments), your code is free from this\15\n   problem.  See info node `(cl) Argument Lists\\=' for more information.\15\n\15\nArguments data, error-thrown, symbol-status can be accessed by\15\n`request-response-data\\=', `request-response-error-thrown\\=',\15\n`request-response-symbol-status\\=' accessors, i.e.::\15\n\15\n    (request-response-data RESPONSE)  ; same as data\15\n\15\nResponse object holds other information which can be accessed by\15\nthe following accessors:\15\n`request-response-status-code\\=',\15\n`request-response-url\\=' and\15\n`request-response-settings\\='\15\n\15\n* STATUS-CODE callback\15\n\15\nSTATUS-CODE is an alist of the following format::\15\n\15\n    ((N-1 . CALLBACK-1)\15\n     (N-2 . CALLBACK-2)\15\n     ...)\15\n\15\nHere, N-1, N-2,... are integer status codes such as 200.\15\n\15\n\15\n* FILES\15\n\15\nFILES is an alist of the following format::\15\n\15\n    ((NAME-1 . FILE-1)\15\n     (NAME-2 . FILE-2)\15\n     ...)\15\n\15\nwhere FILE-N is a list of the form::\15\n\15\n    (FILENAME &key PATH BUFFER STRING MIME-TYPE)\15\n\15\nFILE-N can also be a string (path to the file) or a buffer object.\15\nIn that case, FILENAME is set to the file name or buffer name.\15\n\15\nExample FILES argument::\15\n\15\n    `((\"passwd\"   . \"/etc/passwd\")                ; filename = passwd\15\n      (\"scratch\"  . ,(get-buffer \"*scratch*\"))    ; filename = *scratch*\15\n      (\"passwd2\"  . (\"password.txt\" :file \"/etc/passwd\"))\15\n      (\"scratch2\" . (\"scratch.txt\"  :buffer ,(get-buffer \"*scratch*\")))\15\n      (\"data\"     . (\"data.csv\"     :data \"1,2,3\\n4,5,6\\n\")))\15\n\15\n.. note:: FILES is implemented only for curl backend for now.\15\n   As furl.el_ supports multipart POST, it should be possible to\15\n   support FILES in pure elisp by making furl.el_ another backend.\15\n   Contributions are welcome.\15\n\15\n   .. _furl.el: https://code.google.com/p/furl-el/\15\n\15\n\15\n* PARSER function\15\n\15\nPARSER function takes no argument and it is executed in the\15\nbuffer with HTTP response body.  The current position in the HTTP\15\nresponse buffer is at the beginning of the buffer.  As the HTTP\15\nheader is stripped off, the cursor is actually at the beginning\15\nof the response body.  So, for example, you can pass `json-read\\='\15\nto parse JSON object in the buffer.  To fetch whole response as a\15\nstring, pass `buffer-string\\='.\15\n\15\nWhen using `json-read\\=', it is useful to know that the returned\15\ntype can be modified by `json-object-type\\=', `json-array-type\\=',\15\n`json-key-type\\=', `json-false\\=' and `json-null\\='.  See docstring of\15\neach function for what it does.  For example, to convert JSON\15\nobjects to plist instead of alist, wrap `json-read\\=' by `lambda\\='\15\nlike this.::\15\n\15\n    (request\15\n     \"https://...\"\15\n     :parser (lambda ()\15\n               (let ((json-object-type \\='plist))\15\n                 (json-read)))\15\n     ...)\15\n\15\nThis is analogous to the `dataType\\=' argument of jQuery.ajax_.\15\nOnly this function can access to the process buffer, which\15\nis killed immediately after the execution of this function.\15\n\15\n* SYNC\15\n\15\nSynchronous request is functional, but *please* don\\='t use it\15\nother than testing or debugging.  Emacs users have better things\15\nto do rather than waiting for HTTP request.  If you want a better\15\nway to write callback chains, use `request-deferred\\='.\15\n\15\nIf you can\\='t avoid using it (e.g., you are inside of some hook\15\nwhich must return some value), make sure to set TIMEOUT to\15\nrelatively small value.\15\n\15\nDue to limitation of `url-retrieve-synchronously\\=', response slots\15\n`request-response-error-thrown\\=', `request-response-history\\=' and\15\n`request-response-url\\=' are unknown (always nil) when using\15\nsynchronous request with `url-retrieve\\=' backend.\15\n\15\n* Note\15\n\15\nAPI of `request\\=' is somewhat mixture of jQuery.ajax_ (Javascript)\15\nand requests.request_ (Python).\15\n\15\n.. _jQuery.ajax: https://api.jquery.com/jQuery.ajax/\15\n.. _requests.request: https://docs.python-requests.org\15\n\15\n(fn URL &rest SETTINGS &key (PARAMS nil) (DATA nil) (HEADERS nil) (ENCODING \\='utf-8) (ERROR nil) (SYNC nil) (RESPONSE (make-request-response)) &allow-other-keys)") (function-put 'request 'lisp-indent-function 'defun) (autoload 'request-untrampify-filename "request" "\15\nReturn FILE as the local file name.\15\n\15\n(fn FILE)") (autoload 'request-abort "request" "\15\nAbort request for RESPONSE (the object returned by `request').\15\nNote that this function invoke ERROR and COMPLETE callbacks.\15\nCallbacks may not be called immediately but called later when\15\nassociated process is exited.\15\n\15\n(fn RESPONSE)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/dumb-jump/dumb-jump-autoloads.el") (load-true-file-name load-file-name)) (defvar dumb-jump-mode-map (let ((map (make-sparse-keymap))) (define-key map (kbd "C-M-g") 'dumb-jump-go) (define-key map (kbd "C-M-p") 'dumb-jump-back) (define-key map (kbd "C-M-q") 'dumb-jump-quick-look) map)) (autoload 'dumb-jump-back "dumb-jump" "\15\nJump back to where the last jump was done." t) (autoload 'dumb-jump-quick-look "dumb-jump" "\15\nRun dumb-jump-go in quick look mode.  That is, show a tooltip of where it would jump instead." t) (autoload 'dumb-jump-go-other-window "dumb-jump" "\15\nLike 'dumb-jump-go' but use 'find-file-other-window' instead of 'find-file'." t) (autoload 'dumb-jump-go-current-window "dumb-jump" "\15\nLike dumb-jump-go but always use 'find-file'." t) (autoload 'dumb-jump-go-prefer-external "dumb-jump" "\15\nLike dumb-jump-go but prefer external matches from the current file." t) (autoload 'dumb-jump-go-prompt "dumb-jump" "\15\nLike dumb-jump-go but prompts for function instead of using under point" t) (autoload 'dumb-jump-go-prefer-external-other-window "dumb-jump" "\15\nLike dumb-jump-go-prefer-external but use 'find-file-other-window' instead of 'find-file'." t) (autoload 'dumb-jump-go "dumb-jump" "\15\nGo to the function/variable declaration for thing at point.\15\nWhen USE-TOOLTIP is t a tooltip jump preview will show instead.\15\nWhen PREFER-EXTERNAL is t it will sort external matches before\15\ncurrent file.\15\n\15\n(fn &optional USE-TOOLTIP PREFER-EXTERNAL PROMPT)" t) (defvar dumb-jump-mode nil "\15\nNon-nil if Dumb-Jump mode is enabled.\15\nSee the `dumb-jump-mode' command\15\nfor a description of this minor mode.") (autoload 'dumb-jump-mode "dumb-jump" "\15\nMinor mode for jumping to variable and function definitions\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Dumb-Jump mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='dumb-jump-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n\\{dumb-jump-mode-map}\15\n\15\n(fn &optional ARG)" t) (autoload 'dumb-jump-xref-activate "dumb-jump" "\15\nFunction to activate xref backend.\15\nAdd this function to `xref-backend-functions' to dumb jump to be\15\nactiviated, whenever it finds a project. It is recommended to add\15\nit to the end, so that it only gets activated when no better\15\noption is found.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/eros/eros-autoloads.el") (load-true-file-name load-file-name)) (autoload 'eros-eval-last-sexp "eros" "\15\nWrapper for `eval-last-sexp' that overlays results.\15\n\15\n(fn EVAL-LAST-SEXP-ARG-INTERNAL)" t) (autoload 'eros-eval-defun "eros" "\15\nWrapper for `eval-defun' that overlays results.\15\n\15\n(fn EDEBUG-IT)" t) (defvar eros-mode nil "\15\nNon-nil if Eros mode is enabled.\15\nSee the `eros-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `eros-mode'.") (autoload 'eros-mode "eros" "\15\nDisplay Emacs Lisp evaluation results overlays.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the `Eros\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='eros-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/quickrun/quickrun-autoloads.el") (load-true-file-name load-file-name)) (autoload 'quickrun-set-default "quickrun" "\15\nSet `key' as default key in programing language `lang'.\15\n\15\n(fn LANG KEY)") (autoload 'quickrun-select-default "quickrun" "\15\nUpdate the default." t) (autoload 'quickrun-add-command "quickrun" "\15\nNot documented.\15\n\15\n(fn KEY ALIST &key DEFAULT MODE OVERRIDE)") (function-put 'quickrun-add-command 'lisp-indent-function 'defun) (autoload 'quickrun "quickrun" "\15\nRun commands quickly for current buffer.\15\n\15\nWith universal prefix argument(C-u), select command-key,\15\nWith double prefix argument(C-u C-u), run in compile-only-mode.\15\n\15\n(fn &rest PLIST)" t) (autoload 'quickrun-select "quickrun" "\15\nRun commands after selecting the backend." t) (autoload 'quickrun-with-arg "quickrun" "\15\nRun commands quickly for current buffer with arguments.\15\n\15\n(fn ARG)" t) (autoload 'quickrun-region "quickrun" "\15\nRun commands with specified region.\15\n\15\n(fn START END)" t) (autoload 'quickrun-replace-region "quickrun" "\15\nRun commands with specified region and replace.\15\n\15\n(fn START END)" t) (autoload 'quickrun-eval-print "quickrun" "\15\nRun commands with specified region and replace.\15\n\15\n(fn START END)" t) (autoload 'quickrun-compile-only "quickrun" "\15\nExec only compilation." t) (autoload 'quickrun-compile-only-select "quickrun" "\15\nRun commands after selecting the backend." t) (autoload 'quickrun-shell "quickrun" "\15\nRun commands in shell for interactive programs." t) (autoload 'quickrun-autorun-mode "quickrun" "\15\n`quickrun' after saving buffer.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Quickrun-Autorun mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `quickrun-autorun-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'anything-quickrun "quickrun" "\15\nRun quickrun with `anything'." t) (autoload 'helm-quickrun "quickrun" "\15\nRun quickrun with `helm'." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/flycheck-popup-tip/flycheck-popup-tip-autoloads.el") (load-true-file-name load-file-name)) (autoload 'flycheck-popup-tip-mode "flycheck-popup-tip" "\15\nA minor mode to show Flycheck error messages in a popup.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Flycheck-Popup-Tip mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `flycheck-popup-tip-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/git-modes/git-modes-autoloads.el") (load-true-file-name load-file-name)) (autoload 'gitattributes-mode "gitattributes-mode" "\15\nA major mode for editing .gitattributes files.\15\n\\{gitattributes-mode-map}\15\n\15\n(fn)" t) (dolist (pattern '("/\\.gitattributes\\'" "/info/attributes\\'" "/git/attributes\\'")) (add-to-list 'auto-mode-alist (cons pattern #'gitattributes-mode))) (autoload 'gitconfig-mode "gitconfig-mode" "\15\nA major mode for editing .gitconfig files.\15\n\15\n(fn)" t) (dolist (pattern '("/\\.gitconfig\\'" "/\\.git/config\\'" "/modules/.*/config\\'" "/git/config\\'" "/\\.gitmodules\\'" "/etc/gitconfig\\'")) (add-to-list 'auto-mode-alist (cons pattern 'gitconfig-mode))) (autoload 'gitignore-mode "gitignore-mode" "\15\nA major mode for editing .gitignore files.\15\n\15\n(fn)" t) (dolist (pattern (list "/\\.gitignore\\'" "/info/exclude\\'" "/git/ignore\\'")) (add-to-list 'auto-mode-alist (cons pattern 'gitignore-mode))) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/git-timemachine/git-timemachine-autoloads.el") (load-true-file-name load-file-name)) (autoload 'git-timemachine-toggle "git-timemachine" "\15\nToggle git timemachine mode." t) (autoload 'git-timemachine "git-timemachine" "\15\nEnable git timemachine for file of current buffer." t) (autoload 'git-timemachine-switch-branch "git-timemachine" "\15\nEnable git timemachine for current buffer, switching to GIT-BRANCH.\15\n\15\n(fn GIT-BRANCH)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/browse-at-remote/browse-at-remote-autoloads.el") (load-true-file-name load-file-name)) (autoload 'browse-at-remote "browse-at-remote" "\15\nBrowse the current file with `browse-url'." t) (autoload 'browse-at-remote-kill "browse-at-remote" "\15\nAdd the URL of the current file to the kill ring.\15\n\15\nWorks like `browse-at-remote', but puts the address in the\15\nkill ring instead of opening it with `browse-url'." t) (defalias 'bar-browse 'browse-at-remote "\15\nBrowse the current file with `browse-url'.") (defalias 'bar-to-clipboard 'browse-at-remote-kill "\15\nAdd the URL of the current file to the kill ring.\15\n\15\nWorks like `browse-at-remote', but puts the address in the\15\nkill ring instead of opening it with `browse-url'.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/vundo/vundo-autoloads.el") (load-true-file-name load-file-name)) (defconst vundo-ascii-symbols '((selected-node . 120) (node . 111) (horizontal-stem . 45) (vertical-stem . 124) (branch . 124) (last-branch . 96)) "\15\nASCII symbols to draw vundo tree.") (defconst vundo-unicode-symbols '((selected-node . 9679) (node . 9675) (horizontal-stem . 9472) (vertical-stem . 9474) (branch . 9500) (last-branch . 9492)) "\15\nUnicode symbols to draw vundo tree.") (autoload 'vundo "vundo" "\15\nDisplay visual undo for the current buffer." t) (autoload 'vundo-diff-mark "vundo-diff" "\15\nMark NODE for vundo diff.\15\nNODE defaults to the current node.\15\n\15\n(fn &optional NODE)" t) (autoload 'vundo-diff-unmark "vundo-diff" "\15\nUnmark the node marked for vundo diff." t) (autoload 'vundo-diff "vundo-diff" "\15\nPerform diff between marked and current buffer state.\15\nDisplays in a separate diff buffer with name based on\15\nthe original buffer name." t) (autoload 'vundo-popup-mode "vundo-popup" "\15\nDisplay a vundo popup when using any ordinary undo command.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Vundo-Popup\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `vundo-popup-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/undo-fu-session/undo-fu-session-autoloads.el") (load-true-file-name load-file-name)) (autoload 'undo-fu-session-save "undo-fu-session" "\15\nSave undo data." t) (function-put 'undo-fu-session-save 'important-return-value 'nil) (autoload 'undo-fu-session-recover "undo-fu-session" "\15\nRecover undo data." t) (function-put 'undo-fu-session-recover 'important-return-value 'nil) (autoload 'undo-fu-session-compression-update "undo-fu-session" "\15\nUpdate existing undo session data after changing compression settings." t) (function-put 'undo-fu-session-compression-update 'important-return-value 'nil) (autoload 'undo-fu-session-mode "undo-fu-session" "\15\nToggle saving the undo data in the current buffer (Undo-Fu Session Mode).\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Undo-Fu-Session mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `undo-fu-session-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'undo-fu-session-global-mode 'globalized-minor-mode t) (defvar undo-fu-session-global-mode nil "\15\nNon-nil if Undo-Fu-Session-Global mode is enabled.\15\nSee the `undo-fu-session-global-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `undo-fu-session-global-mode'.") (autoload 'undo-fu-session-global-mode "undo-fu-session" "\15\nToggle Undo-Fu-Session mode in all buffers.\15\nWith prefix ARG, enable Undo-Fu-Session-Global mode if ARG is\15\npositive; otherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nUndo-Fu-Session mode is enabled in all buffers where\15\n`undo-fu-session--mode-turn-on' would do it.\15\n\15\nSee `undo-fu-session-mode' for more information on Undo-Fu-Session\15\nmode.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/undo-fu/undo-fu-autoloads.el") (load-true-file-name load-file-name)) (autoload 'undo-fu-disable-checkpoint "undo-fu" "\15\nRemove the undo-fu checkpoint, making all future actions unconstrained.\15\n\15\nThis command is needed when `undo-fu-ignore-keyboard-quit' is t,\15\nsince in this case `keyboard-quit' cannot be used\15\nto perform unconstrained undo/redo actions." t) (function-put 'undo-fu-disable-checkpoint 'important-return-value 'nil) (autoload 'undo-fu-only-redo-all "undo-fu" "\15\nRedo all actions until the initial undo step.\15\n\15\nwraps the `undo' function." t) (function-put 'undo-fu-only-redo-all 'important-return-value 'nil) (autoload 'undo-fu-only-redo "undo-fu" "\15\nRedo an action until the initial undo action.\15\n\15\nwraps the `undo' function.\15\n\15\nOptional argument ARG The number of steps to redo.\15\n\15\n(fn &optional ARG)" t) (function-put 'undo-fu-only-redo 'important-return-value 'nil) (autoload 'undo-fu-only-undo "undo-fu" "\15\nUndo the last action.\15\n\15\nwraps the `undo-only' function.\15\n\15\nOptional argument ARG the number of steps to undo.\15\n\15\n(fn &optional ARG)" t) (function-put 'undo-fu-only-undo 'important-return-value 'nil) (autoload 'undo-fu-clear-all "undo-fu" "\15\nClear all undo/redo steps." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/diredfl/diredfl-autoloads.el") (load-true-file-name load-file-name)) (autoload 'diredfl-mode "diredfl" "\15\nEnable additional font locking in `dired-mode'.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Diredfl\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `diredfl-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'diredfl-global-mode 'globalized-minor-mode t) (defvar diredfl-global-mode nil "\15\nNon-nil if Diredfl-Global mode is enabled.\15\nSee the `diredfl-global-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `diredfl-global-mode'.") (autoload 'diredfl-global-mode "diredfl" "\15\nToggle Diredfl mode in all buffers.\15\nWith prefix ARG, enable Diredfl-Global mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nDiredfl mode is enabled in all buffers where `(lambda nil (when\15\n(derived-mode-p 'dired-mode) (diredfl-mode)))' would do it.\15\n\15\nSee `diredfl-mode' for more information on Diredfl mode.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/dirvish/dirvish-autoloads.el") (load-true-file-name load-file-name)) (defvar dirvish-override-dired-mode nil "\15\nNon-nil if Dirvish-Override-Dired mode is enabled.\15\nSee the `dirvish-override-dired-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `dirvish-override-dired-mode'.") (autoload 'dirvish-override-dired-mode "dirvish" "\15\nLet Dirvish take over Dired globally.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Dirvish-Override-Dired mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='dirvish-override-dired-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'dirvish "dirvish" "\15\nOpen PATH in a fullframe Dirvish session.\15\nPrompt for PATH if called with \\[universal-arguments], otherwise PATH\15\ndefaults to `default-directory'.\15\n\15\n(fn &optional PATH)" t) (autoload 'dirvish-dwim "dirvish" "\15\nOpen PATH in a fullframe session if selected window is the only window.\15\nPrompt for PATH if called with \\[universal-arguments], otherwise PATH\15\ndefaults to `default-directory'.  If there are other windows exist in the\15\nselected frame, the session occupies only the selected window.\15\n\15\n(fn &optional PATH)" t) (autoload 'dirvish-emerge-menu "dirvish-emerge" "\15\nManage pinned files in Dirvish." t) (autoload 'dirvish-emerge-mode "dirvish-emerge" "\15\nToggle grouping of files in Dirvish.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Dirvish-Emerge mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `dirvish-emerge-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'dirvish-setup-menu "dirvish-extras" nil t) (autoload 'dirvish-copy-file-name "dirvish-extras" "\15\nCopy filename of marked files.\15\nIf MULTI-LINE, make every name occupy a new line.\15\n\15\n(fn &optional MULTI-LINE)" t) (autoload 'dirvish-copy-file-path "dirvish-extras" "\15\nCopy filepath of marked files.\15\nIf MULTI-LINE, make every path occupy a new line.\15\n\15\n(fn &optional MULTI-LINE)" t) (autoload 'dirvish-total-file-size "dirvish-extras" "\15\nEcho total file size of FILESET.\15\nFILESET defaults to `dired-get-marked-files'.\15\n\15\n(fn &optional FILESET)" t) (autoload 'dirvish-layout-switch "dirvish-extras" "\15\nSwitch Dirvish layout according to RECIPE.\15\nIf RECIPE is not provided, switch to the recipe next to the\15\ncurrent layout defined in `dirvish-layout-recipes'.\15\n\15\n(fn &optional RECIPE)" t) (autoload 'dirvish-file-info-menu "dirvish-extras" nil t) (autoload 'dirvish-chxxx-menu "dirvish-extras" nil t) (autoload 'dirvish-mark-menu "dirvish-extras" nil t) (autoload 'dirvish-renaming-menu "dirvish-extras" nil t) (autoload 'dirvish-dired-cheatsheet "dirvish-extras" nil t) (autoload 'dirvish-dispatch "dirvish-extras" nil t) (autoload 'dirvish-fd-switches-menu "dirvish-fd" nil t) (autoload 'dirvish-fd "dirvish-fd" "\15\nRun `fd' on DIR and go into Dired mode on a buffer of the output.\15\nThe command run is essentially:\15\n\15\n  fd --color=never `dirvish-fd-switches'\15\n     --and PATTERN [--and PATTERN1 --and PATTERN2 \x2026 ]\15\n     --exec-batch `dirvish-fd-ls-program' `dired-listing-switches' --directory\15\n\15\nIf called with \\`C-u', prompt for the target directory,\15\n`default-directory' is used.  If prefixed with \\`C-u' twice, also\15\nprompt for the search regex PATTERN as a comma separated list.\15\n\15\n(fn DIR PATTERN)" t) (autoload 'dirvish-history-jump "dirvish-history" "\15\nRead a recently visited directory from minibuffer and revisit it." t) (autoload 'dirvish-history-last "dirvish-history" "\15\nSwitch to the most recently visited dirvish buffer." t) (autoload 'dirvish-history-go-forward "dirvish-history" "\15\nNavigate to next ARG directory in history.\15\nARG defaults to 1.\15\n\15\n(fn ARG)" t) (autoload 'dirvish-history-go-backward "dirvish-history" "\15\nNavigate to previous ARG directory in history.\15\nARG defaults to 1.\15\n\15\n(fn ARG)" t) (autoload 'dirvish-history-menu "dirvish-history" nil t) (autoload 'dirvish-quicksort "dirvish-ls" nil t) (autoload 'dirvish-ls-switches-menu "dirvish-ls" nil t) (autoload 'dirvish-narrow "dirvish-narrow" "\15\nNarrow a Dirvish buffer to the files matching a regex." '(dired-mode)) (defvar dirvish-peek-mode nil "\15\nNon-nil if Dirvish-Peek mode is enabled.\15\nSee the `dirvish-peek-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `dirvish-peek-mode'.") (autoload 'dirvish-peek-mode "dirvish-peek" "\15\nShow file preview when narrowing candidates using minibuffer.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Dirvish-Peek mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='dirvish-peek-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'dirvish-quick-access "dirvish-quick-access" nil t) (autoload 'dirvish-rsync "dirvish-rsync" "\15\nRsync marked files to DEST, prompt for DEST if not called with.\15\nIf either the sources or the DEST is located in a remote host, the\15\n`dirvish-rsync-program' and `dirvish-rsync-args' are used to transfer\15\nthe files.\15\n\15\nThis command requires proper ssh authentication setup to work correctly\15\nfor file transfer involving remote hosts, because rsync command is\15\nalways run locally, the password prompts may lead to unexpected errors.\15\n\15\n(fn DEST)" t) (autoload 'dirvish-rsync-switches-menu "dirvish-rsync" nil t) (defvar dirvish-side-follow-mode nil "\15\nNon-nil if Dirvish-Side-Follow mode is enabled.\15\nSee the `dirvish-side-follow-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `dirvish-side-follow-mode'.") (autoload 'dirvish-side-follow-mode "dirvish-side" "\15\nToggle `dirvish-side-follow-mode'.\15\n\15\nWhen enabled the visible side session will select the current\15\nbuffer's filename.  It will also visits the latest `project-root'\15\nafter switching to a new project.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Dirvish-Side-Follow mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='dirvish-side-follow-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'dirvish-side "dirvish-side" "\15\nToggle a Dirvish session at the side window.\15\n\15\n- If the current window is a side session window, hide it.\15\n- If a side session is visible, select it.\15\n- If a side session exists but is not visible, show it.\15\n- If there is no side session exists, create a new one with PATH.\15\n\15\nIf called with \\[universal-arguments], prompt for PATH,\15\notherwise it defaults to `project-current'.\15\n\15\n(fn &optional PATH)" t) (autoload 'dirvish-subtree-up "dirvish-subtree" "\15\nJump to beginning of current subtree." t) (autoload 'dirvish-subtree-remove "dirvish-subtree" "\15\nRemove subtree at point." t) (autoload 'dirvish-subtree-clear "dirvish-subtree" "\15\nClear all subtrees in the buffer." t) (autoload 'dirvish-subtree-toggle "dirvish-subtree" "\15\nInsert subtree at point or remove it if it was not present." t) (autoload 'dirvish-subtree-menu "dirvish-subtree" nil t) (autoload 'dirvish-vc-menu "dirvish-vc" nil t) (autoload 'dirvish-yank-menu "dirvish-yank" nil t) (autoload 'dirvish-yank "dirvish-yank" "\15\nPaste marked files to DEST.\15\nPrompt for DEST when prefixed with \\[universal-argument], it defaults\15\nto `dired-current-directory.'\15\n\15\n(fn &optional DEST)" t) (autoload 'dirvish-move "dirvish-yank" "\15\nMove marked files to DEST.\15\nPrompt for DEST when prefixed with \\[universal-argument], it defaults\15\nto `dired-current-directory'.\15\n\15\n(fn &optional DEST)" t) (autoload 'dirvish-symlink "dirvish-yank" "\15\nSymlink marked files to DEST.\15\nPrompt for DEST when prefixed with \\[universal-argument], it defaults\15\nto `dired-current-directory'.\15\n\15\n(fn &optional DEST)" t) (autoload 'dirvish-relative-symlink "dirvish-yank" "\15\nSimilar to `dirvish-symlink', but link files relatively.\15\nPrompt for DEST when prefixed with \\[universal-argument], it defaults\15\nto `dired-current-directory'.\15\n\15\n(fn &optional DEST)" t) (autoload 'dirvish-hardlink "dirvish-yank" "\15\nHardlink marked files to DEST.\15\nPrompt for DEST when prefixed with \\[universal-argument], it defaults\15\nto `dired-current-directory'.\15\n\15\n(fn &optional DEST)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/yasnippet/yasnippet-autoloads.el") (load-true-file-name load-file-name)) (autoload 'yas-minor-mode "yasnippet" "\15\nYASnippet minor mode.\15\n\15\nWhen YASnippet mode is enabled, `yas-expand', normally bound to\15\nthe TAB key, expands snippets of code depending on the major mode.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `yas minor\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `yas-minor-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'yas-global-mode 'globalized-minor-mode t) (defvar yas-global-mode nil "\15\nNon-nil if Yas-Global mode is enabled.\15\nSee the `yas-global-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `yas-global-mode'.") (autoload 'yas-global-mode "yasnippet" "\15\nToggle Yas minor mode in all buffers.\15\nWith prefix ARG, enable Yas-Global mode if ARG is positive; otherwise,\15\ndisable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nYas minor mode is enabled in all buffers where `yas-minor-mode-on'\15\nwould do it.\15\n\15\nSee `yas-minor-mode' for more information on Yas minor mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'snippet-mode "yasnippet" "A mode for editing yasnippets" t nil) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/doom-snippets/doom-snippets-autoloads.el") (load-true-file-name load-file-name)) (autoload 'doom-snippets-remove-compiled-snippets "doom-snippets" "Delete all .yas-compiled-snippets.el files." t) (autoload 'doom-snippets-initialize "doom-snippets" "Add `doom-snippets-dir' to `yas-snippet-dirs', replacing the default\nyasnippet directory.") (eval-after-load 'yasnippet (lambda nil (doom-snippets-initialize))) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/auto-yasnippet/auto-yasnippet-autoloads.el") (load-true-file-name load-file-name)) (autoload 'aya-create "auto-yasnippet" "\15\nCreate a snippet from the text between BEG and END.\15\nWhen the bounds are not given, use either the current region or line.\15\n\15\nRemove `aya-marker' prefixes, write the corresponding snippet to\15\n`aya-current', with words prefixed by `aya-marker' as fields, and\15\nmirrors properly set up.\15\n\15\n(fn &optional BEG END)" t) (autoload 'aya-create-one-line "auto-yasnippet" "\15\nA simplistic `aya-create' to create only one mirror.\15\nYou can still have as many instances of this mirror as you want.\15\nIt's less flexible than `aya-create', but faster.\15\nIt uses a different marker, which is `aya-marker-one-line'.\15\nYou can use it to quickly generate one-liners such as\15\nmenu.add_item(spamspamspam, \"spamspamspam\")" t) (autoload 'aya-expand "auto-yasnippet" "\15\nInsert the last yasnippet created by `aya-create'.\15\n\15\nOptionally use PREFIX to set any field as `$0' for wrapping the\15\ncurrent region. (`$0' also sets the exit point after `aya-expand'\15\nwhen there's no active region.) When PREFIX is it defaults to 1.\15\n\15\nFor example let's say the second field in a snippet is where you\15\nwant to wrap the currently selected region.\15\n\15\nUse `M-2' \\[aya-expand].\15\n\15\nIf we use this text as a snippet:\15\n\15\n```~lang\15\n~code\15\n````'\15\n\15\nand assume the selected region as:\15\n\15\n`let somePrettyComplexCode = \"Hello World!\"'\15\n\15\nwe'd do `M-2' \\[aya-expand] which allows us to\15\nfill in `~lang' as `javascript' and wraps our\15\ncode into the code-fences like this.\15\n\15\n```javascript\15\nlet somePrettyComplexCode = \"Hello World!\"\15\n```\15\n\15\nHint: if you view the current snippet(s) in history with\15\n`aya-expand-from-history'. The snippets are shown with their\15\nfields numbered.\15\n\15\nIn our example the snippet looks like like this:\15\n\15\n\\`\\`\\`$1\x2936$2\x2936\\`\\`\\`\x2936\15\n\15\n(fn &optional PREFIX)" t) (autoload 'aya-expand-from-history "auto-yasnippet" "\15\nSelect and insert a yasnippet from the `aya-history'.\15\nThe selected snippet will become `aya-current'\15\nand will be used for consecutive `aya-expand' commands.\15\n\15\nWhen PREFIX is given, the corresponding field number is\15\nmodified to make it the current point after expansion.\15\n\15\n(fn &optional PREFIX)" t) (autoload 'aya-delete-from-history "auto-yasnippet" "\15\nSelect and delete one or more snippets from `aya-history'.\15\nIf the selected snippet is also `aya-current', it will be replaced\15\nby the next snippet in history, or blank if no other history items\15\nare available." t) (autoload 'aya-open-line "auto-yasnippet" "\15\nCall `open-line', unless there are abbrevs or snippets at point.\15\nIn that case expand them.  If there's a snippet expansion in progress,\15\nmove to the next field.  Call `open-line' if nothing else applies." t) (autoload 'aya-yank-snippet "auto-yasnippet" "\15\nInsert current snippet at point.\15\nTo save a snippet permanently, create an empty file and call this." t) (autoload 'aya-yank-snippet-from-history "auto-yasnippet" "\15\nInsert snippet from history at point." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/vimish-fold/vimish-fold-autoloads.el") (load-true-file-name load-file-name)) (autoload 'vimish-fold "vimish-fold" "\15\nFold active region staring at BEG, ending at END.\15\n\15\n(fn BEG END)" t) (autoload 'vimish-fold-unfold "vimish-fold" "\15\nDelete all `vimish-fold--folded' overlays at point." t) (autoload 'vimish-fold-refold "vimish-fold" "\15\nRefold unfolded fold at point." t) (autoload 'vimish-fold-delete "vimish-fold" "\15\nDelete fold at point." t) (autoload 'vimish-fold-unfold-all "vimish-fold" "\15\nUnfold all folds in current buffer." t) (autoload 'vimish-fold-refold-all "vimish-fold" "\15\nRefold all closed folds in current buffer." t) (autoload 'vimish-fold-delete-all "vimish-fold" "\15\nDelete all folds in current buffer." t) (autoload 'vimish-fold-toggle "vimish-fold" "\15\nToggle fold at point." t) (autoload 'vimish-fold-toggle-all "vimish-fold" "\15\nToggle all folds in current buffer." t) (autoload 'vimish-fold-avy "vimish-fold" "\15\nFold region of text between point and line selected with avy.\15\n\15\nThis feature needs `avy' package." t) (autoload 'vimish-fold-next-fold "vimish-fold" "\15\nJump to next folded region in current buffer." t) (autoload 'vimish-fold-previous-fold "vimish-fold" "\15\nJump to previous folded region in current buffer." t) (autoload 'vimish-fold-from-marks "vimish-fold" "\15\nCreate folds from folding symbols.\15\n\15\nMark strings are controlled by `vimish-fold-marks' customize variable." t) (autoload 'vimish-fold-mode "vimish-fold" "\15\nToggle `vimish-fold-mode' minor mode.\15\n\15\nWith a prefix argument ARG, enable `vimish-fold-mode' mode if ARG\15\nis positive, and disable it otherwise.  If called from Lisp,\15\nenable the mode if ARG is omitted or NIL, and toggle it if ARG is\15\n`toggle'.\15\n\15\nThis minor mode sets hooks so when you `find-file' it calls\15\n`vimish-fold--restore-folds' and when you kill a file it calls\15\n`vimish-fold--save-folds'.\15\n\15\nFor globalized version of this mode see `vimish-fold-global-mode'.\15\n\15\n(fn &optional ARG)" t) (put 'vimish-fold-global-mode 'globalized-minor-mode t) (defvar vimish-fold-global-mode nil "\15\nNon-nil if Vimish-Fold-Global mode is enabled.\15\nSee the `vimish-fold-global-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `vimish-fold-global-mode'.") (autoload 'vimish-fold-global-mode "vimish-fold" "\15\nToggle Vimish-Fold mode in all buffers.\15\nWith prefix ARG, enable Vimish-Fold-Global mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nVimish-Fold mode is enabled in all buffers where `vimish-fold-mode'\15\nwould do it.\15\n\15\nSee `vimish-fold-mode' for more information on Vimish-Fold mode.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-vimish-fold/evil-vimish-fold-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-vimish-fold-mode "evil-vimish-fold" "\15\nEvil-vimish-fold-mode.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Evil-Vimish-Fold mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `evil-vimish-fold-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-evil-vimish-fold-mode 'globalized-minor-mode t) (defvar global-evil-vimish-fold-mode nil "\15\nNon-nil if Global Evil-Vimish-Fold mode is enabled.\15\nSee the `global-evil-vimish-fold-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-evil-vimish-fold-mode'.") (autoload 'global-evil-vimish-fold-mode "evil-vimish-fold" "\15\nToggle Evil-Vimish-Fold mode in all buffers.\15\nWith prefix ARG, enable Global Evil-Vimish-Fold mode if ARG is\15\npositive; otherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nEvil-Vimish-Fold mode is enabled in all buffers where\15\n`turn-on-evil-vimish-fold-mode' would do it.\15\n\15\nSee `evil-vimish-fold-mode' for more information on Evil-Vimish-Fold\15\nmode.\15\n\15\n(fn &optional ARG)" t) (autoload 'turn-on-evil-vimish-fold-mode "evil-vimish-fold") (autoload 'turn-off-evil-vimish-fold-mode "evil-vimish-fold" "\15\nTurn off `evil-vimish-fold-mode'." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/annalist/annalist-autoloads.el") (load-true-file-name load-file-name)) (autoload 'annalist-record "annalist" "\15\nIn the store for ANNALIST, TYPE, and LOCAL, record RECORD.\15\nANNALIST should correspond to the package/user recording this information (e.g.\15\n'general, 'me, etc.). TYPE is the type of information being recorded (e.g.\15\n'keybindings). LOCAL corresponds to whether to store RECORD only for the current\15\nbuffer. This information together is used to select where RECORD should be\15\nstored in and later retrieved from with `annalist-describe'. RECORD should be a\15\nlist of items to record and later print as org headings and column entries in a\15\nsingle row. If PLIST is non-nil, RECORD should be a plist instead of an ordered\15\nlist (e.g. '(keymap org-mode-map key \"C-c a\" ...)). The plist keys should be\15\nthe symbols used for the definition of TYPE.\15\n\15\n(fn ANNALIST TYPE RECORD &key LOCAL PLIST)") (autoload 'annalist-describe "annalist" "\15\nDescribe information recorded by ANNALIST for TYPE.\15\nFor example: (annalist-describe 'general 'keybindings) If VIEW is non-nil, use\15\nthose settings for displaying recorded information instead of the defaults.\15\n\15\n(fn ANNALIST TYPE &optional VIEW)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-collection/evil-collection-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-collection-translate-minor-mode-key "evil-collection" "\15\nTranslate keys in the keymap(s) corresponding to STATES and MODES.\15\n\15\nSimilar to `evil-collection-translate-key' but for minor modes.\15\nSTATES should be the name of an evil state, a list of states, or nil. MODES\15\nshould be a symbol corresponding to minor-mode to make the translations in or a\15\nlist of minor-mode symbols. TRANSLATIONS corresponds to a list of\15\nkey replacement pairs. For example, specifying \"a\" \"b\" will bind \"a\" to\15\n\"b\"'s definition in the keymap. Specifying nil as a replacement will unbind a\15\nkey. If DESTRUCTIVE is nil, a backup of the keymap will be stored on the initial\15\ninvocation, and future invocations will always look up keys in the backup\15\nkeymap. When no TRANSLATIONS are given, this function will only create the\15\nbackup keymap without making any translations. On the other hand, if DESTRUCTIVE\15\nis non-nil, the keymap will be destructively altered without creating a backup.\15\nFor example, calling this function multiple times with \"a\" \"b\" \"b\" \"a\"\15\nwould continue to swap and unswap the definitions of these keys. This means that\15\nwhen DESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same\15\ninvocation.\15\n\15\n(fn STATES MODES &rest TRANSLATIONS &key DESTRUCTIVE &allow-other-keys)") (function-put 'evil-collection-translate-minor-mode-key 'lisp-indent-function 'defun) (autoload 'evil-collection-translate-key "evil-collection" "\15\nTranslate keys in the keymap(s) corresponding to STATES and KEYMAPS.\15\nSTATES should be the name of an evil state, a list of states, or nil. KEYMAPS\15\nshould be a symbol corresponding to the keymap to make the translations in or a\15\nlist of keymap symbols. Like `evil-define-key', when a keymap does not exist,\15\nthe keybindings will be deferred until the keymap is defined, so\15\n`with-eval-after-load' is not necessary. TRANSLATIONS corresponds to a list of\15\nkey replacement pairs. For example, specifying \"a\" \"b\" will bind \"a\" to\15\n\"b\"'s definition in the keymap. Specifying nil as a replacement will unbind a\15\nkey. If DESTRUCTIVE is nil, a backup of the keymap will be stored on the initial\15\ninvocation, and future invocations will always look up keys in the backup\15\nkeymap. When no TRANSLATIONS are given, this function will only create the\15\nbackup keymap without making any translations. On the other hand, if DESTRUCTIVE\15\nis non-nil, the keymap will be destructively altered without creating a backup.\15\nFor example, calling this function multiple times with \"a\" \"b\" \"b\" \"a\"\15\nwould continue to swap and unswap the definitions of these keys. This means that\15\nwhen DESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same\15\ninvocation.\15\n\15\n(fn STATES KEYMAPS &rest TRANSLATIONS &key DESTRUCTIVE &allow-other-keys)") (function-put 'evil-collection-translate-key 'lisp-indent-function 'defun) (autoload 'evil-collection-swap-key "evil-collection" "\15\nWrapper around `evil-collection-translate-key' for swapping keys.\15\nSTATES, KEYMAPS, and ARGS are passed to `evil-collection-translate-key'. ARGS\15\nshould consist of key swaps (e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\"\15\n\"a\" with `evil-collection-translate-key') and optionally keyword arguments for\15\n`evil-collection-translate-key'.\15\n\15\n(fn STATES KEYMAPS &rest ARGS)" nil t) (function-put 'evil-collection-swap-key 'lisp-indent-function 'defun) (autoload 'evil-collection-swap-minor-mode-key "evil-collection" "\15\nWrapper around `evil-collection-translate-minor-mode-key' for swapping keys.\15\nSTATES, MODES, and ARGS are passed to\15\n`evil-collection-translate-minor-mode-key'. ARGS should consist of key swaps\15\n(e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\" \"a\"\15\nwith `evil-collection-translate-minor-mode-key') and optionally keyword\15\narguments for `evil-collection-translate-minor-mode-key'.\15\n\15\n(fn STATES MODES &rest ARGS)" nil t) (function-put 'evil-collection-swap-minor-mode-key 'lisp-indent-function 'defun) (autoload 'evil-collection-require "evil-collection" "\15\nRequire the evil-collection-MODE file, but do not activate it.\15\n\15\nMODE should be a symbol. This requires the evil-collection-MODE\15\nfeature without needing to manipulate `load-path'. NOERROR is\15\nforwarded to `require'.\15\n\15\n(fn MODE &optional NOERROR)") (autoload 'evil-collection-init "evil-collection" "\15\nRegister the Evil bindings for all modes in `evil-collection-mode-list'.\15\n\15\nAlternatively, you may register select bindings manually, for\15\ninstance:\15\n\15\n  (with-eval-after-load ='calendar\15\n    (evil-collection-calendar-setup))\15\n\15\nIf MODES is specified (as either one mode or a list of modes), use those modes\15\ninstead of the modes in `evil-collection-mode-list'.\15\n\15\n(fn &optional MODES)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-quick-diff/evil-quick-diff-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-quick-diff "evil-quick-diff" "\15\nEdiff two regions with evil motion." t) (autoload 'evil-quick-diff-cancel "evil-quick-diff-cancel" "\15\nCancel evil-quick-diff and remove selections." t) (autoload 'evil-quick-diff-install "evil-quick-diff" "\15\nSetting evil-quick-diff key bindings.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-visualstar/evil-visualstar-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-visualstar-mode "evil-visualstar" "\15\nMinor mode for visual star selection.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Evil-Visualstar mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `evil-visualstar-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-evil-visualstar-mode 'globalized-minor-mode t) (defvar global-evil-visualstar-mode nil "\15\nNon-nil if Global Evil-Visualstar mode is enabled.\15\nSee the `global-evil-visualstar-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-evil-visualstar-mode'.") (autoload 'global-evil-visualstar-mode "evil-visualstar" "\15\nToggle Evil-Visualstar mode in all buffers.\15\nWith prefix ARG, enable Global Evil-Visualstar mode if ARG is\15\npositive; otherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nEvil-Visualstar mode is enabled in all buffers where\15\n`turn-on-evil-visualstar-mode' would do it.\15\n\15\nSee `evil-visualstar-mode' for more information on Evil-Visualstar\15\nmode.\15\n\15\n(fn &optional ARG)" t) (autoload 'turn-on-evil-visualstar-mode "evil-visualstar" "\15\nTurns on visual star selection." t) (autoload 'turn-off-evil-visualstar-mode "evil-visualstar" "\15\nTurns off visual star selection." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-traces/evil-traces-autoloads.el") (load-true-file-name load-file-name)) (defvar evil-traces-mode nil "\15\nNon-nil if Evil-Traces mode is enabled.\15\nSee the `evil-traces-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `evil-traces-mode'.") (autoload 'evil-traces-mode "evil-traces" "\15\nGlobal minor mode for evil-traces.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Evil-Traces mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='evil-traces-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-textobj-anyblock/evil-textobj-anyblock-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-textobj-anyblock-inner-block "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-a-block "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-forward-open-block-start "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-forward-open-block-end "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-forward-close-block-start "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-forward-close-block-end "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-backward-open-block-start "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-backward-open-block-end "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-backward-close-block-start "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-backward-close-block-end "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-forward-any-block-start "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-forward-any-block-end "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-backward-any-block-start "evil-textobj-anyblock" nil t) (autoload 'evil-textobj-anyblock-backward-any-block-end "evil-textobj-anyblock" nil t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-surround/evil-surround-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-surround-delete "evil-surround" "\15\nDelete the surrounding delimiters represented by CHAR.\15\nAlternatively, the text to delete can be represented with\15\nthe overlays OUTER and INNER, where OUTER includes the delimiters\15\nand INNER excludes them. The intersection (i.e., difference)\15\nbetween these overlays is what is deleted.\15\n\15\n(fn CHAR &optional OUTER INNER)" t) (autoload 'evil-surround-change "evil-surround" "\15\nChange the surrounding delimiters represented by CHAR.\15\nAlternatively, the text to delete can be represented with the\15\noverlays OUTER and INNER, which are passed to `evil-surround-delete'.\15\n\15\n(fn CHAR &optional OUTER INNER)" t) (autoload 'evil-surround-mode "evil-surround" "\15\nBuffer-local minor mode to emulate surround.vim.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Evil-Surround mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `evil-surround-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'turn-on-evil-surround-mode "evil-surround" "\15\nEnable evil-surround-mode in the current buffer.") (autoload 'turn-off-evil-surround-mode "evil-surround" "\15\nDisable evil-surround-mode in the current buffer.") (put 'global-evil-surround-mode 'globalized-minor-mode t) (defvar global-evil-surround-mode nil "\15\nNon-nil if Global Evil-Surround mode is enabled.\15\nSee the `global-evil-surround-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-evil-surround-mode'.") (autoload 'global-evil-surround-mode "evil-surround" "\15\nToggle Evil-Surround mode in all buffers.\15\nWith prefix ARG, enable Global Evil-Surround mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nEvil-Surround mode is enabled in all buffers where\15\n`turn-on-evil-surround-mode' would do it.\15\n\15\nSee `evil-surround-mode' for more information on Evil-Surround mode.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-snipe/evil-snipe-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-snipe-def "evil-snipe" "\15\nDefine a N char snipe and bind it to FORWARD-KEY and BACKWARD-KEY.\15\nTYPE can be inclusive or exclusive. Specify FORWARD-FN and/or BACKWARD-FN to\15\nexplicitly choose the function names.\15\n\15\n(fn N TYPE FORWARD-KEY BACKWARD-KEY &key FORWARD-FN BACKWARD-FN)" nil t) (autoload 'evil-snipe-s "evil-snipe" nil t) (autoload 'evil-snipe-S "evil-snipe" nil t) (autoload 'evil-snipe-x "evil-snipe" nil t) (autoload 'evil-snipe-X "evil-snipe" nil t) (autoload 'evil-snipe-f "evil-snipe" nil t) (autoload 'evil-snipe-F "evil-snipe" nil t) (autoload 'evil-snipe-t "evil-snipe" nil t) (autoload 'evil-snipe-T "evil-snipe" nil t) (autoload 'turn-on-evil-snipe-mode "evil-snipe" "\15\nEnable evil-snipe-mode in the current buffer.") (autoload 'turn-on-evil-snipe-override-mode "evil-snipe" "\15\nEnable evil-snipe-mode in the current buffer.") (autoload 'turn-off-evil-snipe-mode "evil-snipe" "\15\nDisable `evil-snipe-local-mode' in the current buffer.") (autoload 'turn-off-evil-snipe-override-mode "evil-snipe" "\15\nDisable evil-snipe-override-mode in the current buffer.") (autoload 'evil-snipe-local-mode "evil-snipe" "\15\nEnable `evil-snipe' in the current buffer.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Evil-snipe-Local mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `evil-snipe-local-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'evil-snipe-override-local-mode "evil-snipe" "\15\nOverride evil-mode's f/F/t/T/;/, motions.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Evil-Snipe-Override-Local mode' mode.  If the prefix argument is\15\npositive, enable the mode, and if it is zero or negative, disable the\15\nmode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `evil-snipe-override-local-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'evil-snipe-mode 'globalized-minor-mode t) (defvar evil-snipe-mode nil "\15\nNon-nil if Evil-Snipe mode is enabled.\15\nSee the `evil-snipe-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `evil-snipe-mode'.") (autoload 'evil-snipe-mode "evil-snipe" "\15\nToggle Evil-Snipe-Local mode in all buffers.\15\nWith prefix ARG, enable Evil-Snipe mode if ARG is positive; otherwise,\15\ndisable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nEvil-Snipe-Local mode is enabled in all buffers where\15\n`turn-on-evil-snipe-mode' would do it.\15\n\15\nSee `evil-snipe-local-mode' for more information on Evil-Snipe-Local\15\nmode.\15\n\15\n(fn &optional ARG)" t) (put 'evil-snipe-override-mode 'globalized-minor-mode t) (defvar evil-snipe-override-mode nil "\15\nNon-nil if Evil-Snipe-Override mode is enabled.\15\nSee the `evil-snipe-override-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `evil-snipe-override-mode'.") (autoload 'evil-snipe-override-mode "evil-snipe" "\15\nToggle Evil-Snipe-Override-Local mode in all buffers.\15\nWith prefix ARG, enable Evil-Snipe-Override mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nEvil-Snipe-Override-Local mode is enabled in all buffers where\15\n`turn-on-evil-snipe-override-mode' would do it.\15\n\15\nSee `evil-snipe-override-local-mode' for more information on\15\nEvil-Snipe-Override-Local mode.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-numbers/evil-numbers-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-numbers/inc-at-pt "evil-numbers" nil t) (autoload 'evil-numbers/dec-at-pt "evil-numbers" nil t) (autoload 'evil-numbers/inc-at-pt-incremental "evil-numbers" nil t) (autoload 'evil-numbers/dec-at-pt-incremental "evil-numbers" nil t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-nerd-commenter/evil-nerd-commenter-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evilnc-comment-or-uncomment-region-internal "evil-nerd-commenter" "\15\nComment or uncomment region from START to END.\15\n\15\n(fn START END)") (autoload 'evilnc-comment-or-uncomment-region "evil-nerd-commenter" "\15\nComment or uncomment region from START to END.\15\n\15\n(fn START END)") (autoload 'evilnc-comment-or-uncomment-paragraphs "evil-nerd-commenter" "\15\nComment or uncomment NUM paragraph(s).\15\nA paragraph is a continuation non-empty lines.\15\nParagraphs are separated by empty lines.\15\n\15\n(fn &optional NUM)" t) (autoload 'evilnc-comment-or-uncomment-to-the-line "evil-nerd-commenter" "\15\nComment or uncomment from current line to LINE-NUM line.\15\n\15\n(fn &optional LINE-NUM)" t) (autoload 'evilnc-quick-comment-or-uncomment-to-the-line "evil-nerd-commenter" "\15\nComment/uncomment to line number by LAST-DIGITS.\15\nFor example, you can use either \\<M-53>\\[evilnc-quick-comment-or-uncomment-to-the-line] or \\<M-3>\\[evilnc-quick-comment-or-uncomment-to-the-line] to comment to the line 6453\15\n\15\n(fn &optional LAST-DIGITS)" t) (autoload 'evilnc-toggle-invert-comment-line-by-line "evil-nerd-commenter" "\15\nPlease note this command may NOT work on complex evil text objects." t) (autoload 'evilnc-toggle-comment-empty-lines "evil-nerd-commenter" "\15\nToggle the flag which decide if empty line will be commented." t) (autoload 'evilnc-comment-or-uncomment-lines "evil-nerd-commenter" "\15\nComment or uncomment NUM lines.  NUM could be negative.\15\n\15\nCase 1: If no region selected, comment/uncomment on current line.\15\nIf NUM>1, comment/uncomment extra N-1 lines from next line.\15\n\15\nCase 2: Selected region is expanded to make it contain whole lines.\15\nThen we comment/uncomment the expanded region.  NUM is ignored.\15\n\15\nCase 3: If a region inside of ONE line is selected,\15\nwe comment/uncomment that region.\15\nCORRECT comment syntax will be used for C++/Java/Javascript.\15\n\15\n(fn &optional NUM)" t) (autoload 'evilnc-copy-and-comment-lines "evil-nerd-commenter" "\15\nCopy&paste NUM lines and comment out original lines.\15\nNUM could be negative.\15\n\15\nCase 1: If no region selected, operate on current line.\15\nif NUM>1, comment/uncomment extra N-1 lines from next line\15\n\15\nCase 2: Selected region is expanded to make it contain whole lines.\15\nThen we operate the expanded region.  NUM is ignored.\15\n\15\n(fn &optional NUM)" t) (autoload 'evilnc-comment-and-kill-ring-save "evil-nerd-commenter" "\15\nComment lines save origin lines into `kill-ring'.\15\nNUM could be negative.\15\n\15\nCase 1: If no region selected, operate on current line.\15\n;; if NUM>1, comment/uncomment extra N-1 lines from next line\15\n\15\nCase 2: Selected region is expanded to make it contain whole lines.\15\nThen we operate the expanded region.  NUM is ignored.\15\n\15\n(fn &optional NUM)" t) (autoload 'evilnc-copy-to-line "evil-nerd-commenter" "\15\nCopy from current line to LINENUM line.  For non-evil user only.\15\n\15\n(fn &optional LINENUM)" t) (autoload 'evilnc-kill-to-line "evil-nerd-commenter" "\15\nKill from the current line to the LINENUM line.  For non-evil user only.\15\n\15\n(fn &optional LINENUM)" t) (autoload 'evilnc-version "evil-nerd-commenter" "\15\nThe version number." t) (autoload 'evilnc-default-hotkeys "evil-nerd-commenter" "\15\nSetup the key bindings of evil-nerd-comment.\15\nIf NO-EVIL-KEYBINDINGS is t, we don't define keybindings in EVIL,\15\nif NO-EMACS-KEYBINDINGS is t, we don't define keybindings in EMACS mode.\15\n\15\n(fn &optional NO-EVIL-KEYBINDINGS NO-EMACS-KEYBINDINGS)" t) (autoload 'evilnc-imenu-create-index-function "evil-nerd-commenter" "\15\nImenu function find comments.") (autoload 'evilnc-comment-or-uncomment-html-tag "evil-nerd-commenter" "\15\nComment or uncomment html tag(s).\15\nIf no region is selected, current tag under focus is automatically selected.\15\nIn this case, only one tag is selected.\15\nIf users manually select region, the region could cross multiple sibling tags\15\nand automatically expands to include complete tags.\15\nUsers can press \"v\" key in evil mode to select multiple tags.\15\nThis command is not dependent on any 3rd party package." t) (autoload 'evilnc-comment-or-uncomment-html-paragraphs "evil-nerd-commenter" "\15\nComment or uncomment NUM paragraphs contain html tag.\15\nA paragraph is a continuation non-empty lines.\15\nParagraphs are separated by empty lines.\15\n\15\n(fn &optional NUM)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-lion/evil-lion-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-lion-left "evil-lion" nil t) (autoload 'evil-lion-right "evil-lion" nil t) (defvar evil-lion-mode nil "\15\nNon-nil if Evil-Lion mode is enabled.\15\nSee the `evil-lion-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `evil-lion-mode'.") (autoload 'evil-lion-mode "evil-lion" "\15\nToggle `evil-lion-mode', defines align operators gl and gL.\15\n\15\n  Align with gl MOTION CHAR or right-align with gL MOTION CHAR.\15\n\15\n  If CHAR is / you will be prompted for a regular expression instead\15\n  of a plain character.\15\n\15\n  If CHAR is RET, alignment will be performed with the rules of\15\n  align.el which are specific for the current major mode.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Evil-Lion mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='evil-lion-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-indent-plus/evil-indent-plus-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-indent-plus-i-indent "evil-indent-plus" nil t) (autoload 'evil-indent-plus-a-indent "evil-indent-plus" nil t) (autoload 'evil-indent-plus-i-indent-up "evil-indent-plus" nil t) (autoload 'evil-indent-plus-a-indent-up "evil-indent-plus" nil t) (autoload 'evil-indent-plus-i-indent-up-down "evil-indent-plus" nil t) (autoload 'evil-indent-plus-a-indent-up-down "evil-indent-plus" nil t) (autoload 'evil-indent-plus-default-bindings "evil-indent-plus" "\15\nSet the default evil-indent-plus keybindings.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-exchange/evil-exchange-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-exchange "evil-exchange" "\15\nExchange two regions with evil motion." t) (autoload 'evil-exchange-cancel "evil-exchange" "\15\nCancel current pending exchange." t) (autoload 'evil-exchange-install "evil-exchange" "\15\nSetting evil-exchange key bindings.") (autoload 'evil-exchange-cx-install "evil-exchange" "\15\nSetting evil-exchange key bindings in a vim-compatible way" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-escape/evil-escape-autoloads.el") (load-true-file-name load-file-name)) (defvar evil-escape-mode nil "\15\nNon-nil if Evil-Escape mode is enabled.\15\nSee the `evil-escape-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `evil-escape-mode'.") (autoload 'evil-escape-mode "evil-escape" "\15\nBuffer-local minor mode to escape insert state and everything else\15\n\15\nwith a key sequence.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Evil-Escape mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='evil-escape-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/expand-region/expand-region-autoloads.el") (load-true-file-name load-file-name)) (autoload 'er/expand-region "expand-region" "\15\nIncrease selected region by semantic units.\15\n\15\nWith prefix argument expands the region that many times.\15\nIf prefix argument is negative calls `er/contract-region'.\15\nIf prefix argument is 0 it resets point and mark to their state\15\nbefore calling `er/expand-region' for the first time.\15\n\15\n(fn ARG)" t) (autoload 'er/contract-region "expand-region-core" "\15\nContract the selected region to its previous size.\15\nWith prefix argument contracts that many times.\15\nIf prefix argument is negative calls `er/expand-region'.\15\nIf prefix argument is 0 it resets point and mark to their state\15\nbefore calling `er/expand-region' for the first time.\15\n\15\n(fn ARG)" t) (let ((loads (get 'expand-region 'custom-loads))) (if (member '"expand-region-custom" loads) nil (put 'expand-region 'custom-loads (cons '"expand-region-custom" loads)) (put 'tools 'custom-loads (cons 'expand-region (get 'tools 'custom-loads))))) (defvar expand-region-preferred-python-mode 'python "\15\nThe name of your preferred python mode.") (defvar expand-region-guess-python-mode t "\15\nIf expand-region should attempt to guess your preferred python mode.") (defvar expand-region-autocopy-register "" "\15\nRegister to copy most recent expand or contract to.\15\n\15\nActivated when set to a string of a single character (for example, \"e\").") (defvar expand-region-skip-whitespace t "\15\nIf expand-region should skip past whitespace on initial expansion.") (defvar expand-region-fast-keys-enabled t "\15\nIf expand-region should bind fast keys after initial expand/contract.") (defvar expand-region-contract-fast-key "-" "\15\nKey to use after an initial expand/contract to contract once more.") (defvar expand-region-reset-fast-key "0" "\15\nKey to use after an initial expand/contract to undo.") (defvar expand-region-exclude-text-mode-expansions '(html-mode nxml-mode) "\15\nList of modes derived from `text-mode' to exclude from text mode expansions.") (defvar expand-region-smart-cursor nil "\15\nDefines whether the cursor should be placed intelligently after expansion.\15\n\15\nIf set to t, and the cursor is already at the beginning of the new region,\15\nkeep it there; otherwise, put it at the end of the region.\15\n\15\nIf set to nil, always place the cursor at the beginning of the region.") (define-obsolete-variable-alias 'er/enable-subword-mode? 'expand-region-subword-enabled "\15\n2019-03-23") (defvar expand-region-subword-enabled nil "\15\nWhether expand-region should use subword expansions.") nil nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/embrace/embrace-autoloads.el") (load-true-file-name load-file-name)) (autoload 'embrace-delete "embrace" nil t) (autoload 'embrace-change "embrace" nil t) (autoload 'embrace-add "embrace" nil t) (autoload 'embrace-commander "embrace" nil t) (autoload 'embrace-LaTeX-mode-hook "embrace") (autoload 'embrace-org-mode-hook "embrace") (autoload 'embrace-ruby-mode-hook "embrace") (autoload 'embrace-emacs-lisp-mode-hook "embrace") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-embrace/evil-embrace-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-embrace-enable-evil-surround-integration "evil-embrace" nil t) (autoload 'evil-embrace-disable-evil-surround-integration "evil-embrace" nil t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-easymotion/evil-easymotion-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evilem--collect "evil-easymotion" "\15\nRepeatedly execute func, and collect the cursor positions into a list\15\n\15\n(fn FUNC &optional SCOPE ALL-WINDOWS INITIAL-POINT SORT-KEY COLLECT-POSTPROCESS INCLUDE-INVISIBLE)") (autoload 'evilem-motion-forward-word-begin "evil-easymotion" nil t) (autoload 'evilem-motion-forward-WORD-begin "evil-easymotion" nil t) (autoload 'evilem-motion-forward-word-end "evil-easymotion" nil t) (autoload 'evilem-motion-forward-WORD-end "evil-easymotion" nil t) (autoload 'evilem-motion-backward-word-begin "evil-easymotion" nil t) (autoload 'evilem-motion-backward-WORD-begin "evil-easymotion" nil t) (autoload 'evilem-motion-backward-word-end "evil-easymotion" nil t) (autoload 'evilem-motion-backward-WORD-end "evil-easymotion" nil t) (autoload 'evilem-motion-next-line "evil-easymotion" nil t) (autoload 'evilem-motion-previous-line "evil-easymotion" nil t) (autoload 'evilem-motion-next-visual-line "evil-easymotion" nil t) (autoload 'evilem-motion-previous-visual-line "evil-easymotion" nil t) (autoload 'evilem-motion-find-char-to "evil-easymotion" nil t) (autoload 'evilem-motion-find-char-to-backward "evil-easymotion" nil t) (autoload 'evilem-motion-find-char "evil-easymotion" nil t) (autoload 'evilem-motion-find-char-backward "evil-easymotion" nil t) (autoload 'evilem-motion-backward-section-begin "evil-easymotion" nil t) (autoload 'evilem-motion-backward-section-end "evil-easymotion" nil t) (autoload 'evilem-motion-forward-section-begin "evil-easymotion" nil t) (autoload 'evilem-motion-forward-section-end "evil-easymotion" nil t) (autoload 'evilem-motion-backward-sentence-begin "evil-easymotion" nil t) (autoload 'evilem-motion-forward-sentence-begin "evil-easymotion" nil t) (autoload 'evilem-motion-search-next "evil-easymotion" nil t) (autoload 'evilem-motion-search-previous "evil-easymotion" nil t) (autoload 'evilem-motion-search-word-forward "evil-easymotion" nil t) (autoload 'evilem-motion-search-word-backward "evil-easymotion" nil t) (autoload 'evilem-motion-previous-line-first-non-blank "evil-easymotion" nil t) (autoload 'evilem-motion-next-line-first-non-blank "evil-easymotion" nil t) (autoload 'evilem-default-keybindings "evil-easymotion" "\15\nDefine easymotions for all motions evil defines by default\15\n\15\n(fn PREFIX)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-args/evil-args-autoloads.el") (load-true-file-name load-file-name)) (autoload 'evil-backward-arg "evil-args" "\15\nMove the cursor backward COUNT arguments.\15\n\15\n(fn COUNT)" t) (autoload 'evil-forward-arg "evil-args" "\15\nMove the cursor forward COUNT arguments.\15\n\15\n(fn COUNT)" t) (autoload 'evil-inner-arg "evil-args") (autoload 'evil-outer-arg "evil-args") (autoload 'evil-jump-out-args "evil-args" "\15\nMove the cursor out of the nearest enclosing matching pairs.\15\n\15\n(fn COUNT)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/persp-mode/persp-mode-autoloads.el") (load-true-file-name load-file-name)) (autoload 'persp-def-auto-persp "persp-mode" "\15\n\15\n\15\n(fn NAME &rest KEYARGS &key BUFFER-NAME FILE-NAME MODE MODE-NAME MINOR-MODE MINOR-MODE-NAME PREDICATE HOOKS DYN-ENV GET-NAME GET-BUFFER GET-PERSP SWITCH PARAMETERS NOAUTO WEAK USER-DATA ON-MATCH AFTER-MATCH DONT-PICK-UP-BUFFERS DELETE)") (define-obsolete-function-alias 'def-auto-persp 'persp-def-auto-persp "persp-mode 2.9.6") (autoload 'persp-def-buffer-save/load "persp-mode" "\15\n\15\n\15\n(fn &rest KEYARGS &key BUFFER-NAME FILE-NAME MODE MODE-NAME MINOR-MODE MINOR-MODE-NAME PREDICATE TAG-SYMBOL SAVE-VARS SAVE-FUNCTION LOAD-FUNCTION AFTER-LOAD-FUNCTION MODE-RESTORE-FUNCTION APPEND)") (define-obsolete-function-alias 'def-persp-buffer-save/load 'persp-def-buffer-save/load "persp-mode 2.9.6") (defvar persp-mode nil "\15\nNon-nil if Persp mode is enabled.\15\nSee the `persp-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `persp-mode'.") (autoload 'persp-mode "persp-mode" "\15\nToggle the persp-mode.\15\n\15\nWhen active, keeps track of multiple \\='perspectives\\=',\15\nnamed collections of buffers and window configurations.\15\nHere is a keymap of this minor mode:\15\n\\{persp-mode-map}\15\n\15\nThis is a global minor mode.  If called interactively, toggle the `Persp\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='persp-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/vi-tilde-fringe/vi-tilde-fringe-autoloads.el") (load-true-file-name load-file-name)) (autoload 'vi-tilde-fringe-mode "vi-tilde-fringe" "\15\nBuffer-local minor mode to display tildes in the fringe when the line is\15\n\15\nempty.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Vi-Tilde-Fringe mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `vi-tilde-fringe-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-vi-tilde-fringe-mode 'globalized-minor-mode t) (defvar global-vi-tilde-fringe-mode nil "\15\nNon-nil if Global Vi-Tilde-Fringe mode is enabled.\15\nSee the `global-vi-tilde-fringe-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-vi-tilde-fringe-mode'.") (autoload 'global-vi-tilde-fringe-mode "vi-tilde-fringe" "\15\nToggle Vi-Tilde-Fringe mode in all buffers.\15\nWith prefix ARG, enable Global Vi-Tilde-Fringe mode if ARG is\15\npositive; otherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nVi-Tilde-Fringe mode is enabled in all buffers where\15\n`vi-tilde-fringe-mode--turn-on' would do it.\15\n\15\nSee `vi-tilde-fringe-mode' for more information on Vi-Tilde-Fringe\15\nmode.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/diff-hl/diff-hl-autoloads.el") (load-true-file-name load-file-name)) (autoload 'diff-hl-mode "diff-hl" "\15\nToggle VC diff highlighting.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Diff-Hl\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `diff-hl-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'turn-on-diff-hl-mode "diff-hl" "\15\nTurn on `diff-hl-mode' or `diff-hl-dir-mode' in a buffer if appropriate.") (autoload 'diff-hl--global-turn-on "diff-hl" "\15\nCall `turn-on-diff-hl-mode' if the current major mode is applicable.") (autoload 'diff-hl-set-reference-rev "diff-hl" "\15\nSet the reference revision globally to REV.\15\nWhen called interactively, REV read with completion.\15\n\15\nThe default value chosen using one of methods below:\15\n\15\n- In a log view buffer, it uses the revision of current entry.\15\nCall `vc-print-log' or `vc-print-root-log' first to open a log\15\nview buffer.\15\n- In a VC annotate buffer, it uses the revision of current line.\15\n- In other situations, it uses the symbol at point.\15\n\15\nNotice that this sets the reference revision globally, so in\15\nfiles from other repositories, `diff-hl-mode' will not highlight\15\nchanges correctly, until you run `diff-hl-reset-reference-rev'.\15\n\15\nAlso notice that this will disable `diff-hl-amend-mode' in\15\nbuffers that enables it, since `diff-hl-amend-mode' overrides its\15\neffect.\15\n\15\n(fn REV)" t) (autoload 'diff-hl-reset-reference-rev "diff-hl" "\15\nReset the reference revision globally to the most recent one." t) (put 'global-diff-hl-mode 'globalized-minor-mode t) (defvar global-diff-hl-mode nil "\15\nNon-nil if Global Diff-Hl mode is enabled.\15\nSee the `global-diff-hl-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-diff-hl-mode'.") (autoload 'global-diff-hl-mode "diff-hl" "\15\nToggle Diff-Hl mode in all buffers.\15\nWith prefix ARG, enable Global Diff-Hl mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nDiff-Hl mode is enabled in all buffers where `diff-hl--global-turn-on'\15\nwould do it.\15\n\15\nSee `diff-hl-mode' for more information on Diff-Hl mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'diff-hl-amend-mode "diff-hl-amend" "\15\nShow changes against the second-last revision in `diff-hl-mode'.\15\n\15\nMost useful with backends that support rewriting local commits,\15\nand most importantly, \"amending\" the most recent one.\15\nCurrently only supports Git, Mercurial and Bazaar.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Diff-Hl-Amend mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `diff-hl-amend-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-diff-hl-amend-mode 'globalized-minor-mode t) (defvar global-diff-hl-amend-mode nil "\15\nNon-nil if Global Diff-Hl-Amend mode is enabled.\15\nSee the `global-diff-hl-amend-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-diff-hl-amend-mode'.") (autoload 'global-diff-hl-amend-mode "diff-hl-amend" "\15\nToggle Diff-Hl-Amend mode in all buffers.\15\nWith prefix ARG, enable Global Diff-Hl-Amend mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nDiff-Hl-Amend mode is enabled in all buffers where\15\n`turn-on-diff-hl-amend-mode' would do it.\15\n\15\nSee `diff-hl-amend-mode' for more information on Diff-Hl-Amend mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'diff-hl-dired-mode "diff-hl-dired" "\15\nToggle VC diff highlighting on the side of a Dired window.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Diff-Hl-Dired mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `diff-hl-dired-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'diff-hl-dired-mode-unless-remote "diff-hl-dired") (defvar diff-hl-flydiff-mode nil "\15\nNon-nil if Diff-Hl-Flydiff mode is enabled.\15\nSee the `diff-hl-flydiff-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `diff-hl-flydiff-mode'.") (autoload 'diff-hl-flydiff-mode "diff-hl-flydiff" "\15\nPerform highlighting on-the-fly.\15\n\15\nThis is a global minor mode.  It alters how `diff-hl-mode' works.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Diff-Hl-Flydiff mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='diff-hl-flydiff-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'diff-hl-inline-popup-hide "diff-hl-inline-popup" "\15\nHide the current inline popup." t) (autoload 'diff-hl-inline-popup-show "diff-hl-inline-popup" "\15\nCreate a phantom overlay to show the inline popup, with some\15\ncontent LINES, and a HEADER and a FOOTER, at POINT.  KEYMAP is\15\nadded to the current keymaps.  CLOSE-HOOK is called when the popup\15\nis closed.\15\n\15\n(fn LINES &optional HEADER FOOTER KEYMAP CLOSE-HOOK POINT HEIGHT)") (defvar diff-hl-margin-mode nil "\15\nNon-nil if Diff-Hl-Margin mode is enabled.\15\nSee the `diff-hl-margin-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `diff-hl-margin-mode'.") (autoload 'diff-hl-margin-mode "diff-hl-margin" "\15\nToggle displaying `diff-hl-mode' highlights on the margin.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Diff-Hl-Margin mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='diff-hl-margin-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'diff-hl-margin-local-mode "diff-hl-margin" "\15\nToggle displaying `diff-hl-mode' highlights on the margin locally.\15\n\15\nYou probably shouldn't use this function directly.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Diff-Hl-Margin-Local mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `diff-hl-margin-local-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'diff-hl-show-hunk-inline-popup "diff-hl-show-hunk" "\15\nImplementation to show the hunk in a inline popup.\15\nBUFFER is a buffer with the hunk.\15\n\15\n(fn BUFFER &optional IGNORED-LINE)") (autoload 'diff-hl-show-hunk-previous "diff-hl-show-hunk" "\15\nGo to previous hunk/change and show it." t) (autoload 'diff-hl-show-hunk-next "diff-hl-show-hunk" "\15\nGo to next hunk/change and show it." t) (autoload 'diff-hl-show-hunk "diff-hl-show-hunk" "\15\nShow the VC diff hunk at point.\15\nThe backend is determined by `diff-hl-show-hunk-function'." t) (autoload 'diff-hl-show-hunk-mouse-mode "diff-hl-show-hunk" "\15\nEnable margin and fringe to show a posframe/popup with vc diffs when clicked.\15\n\15\nBy default, the popup shows only the current hunk, and\15\nthe line of the hunk that matches the current position is\15\nhighlighted.  The face, border and other visual preferences are\15\ncustomizable.  It can be also invoked with the command\15\n`diff-hl-show-hunk'\15\n\\{diff-hl-show-hunk-mouse-mode-map}\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Diff-Hl-Show-Hunk-Mouse mode' mode.  If the prefix argument is\15\npositive, enable the mode, and if it is zero or negative, disable the\15\nmode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `diff-hl-show-hunk-mouse-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-diff-hl-show-hunk-mouse-mode 'globalized-minor-mode t) (defvar global-diff-hl-show-hunk-mouse-mode nil "\15\nNon-nil if Global Diff-Hl-Show-Hunk-Mouse mode is enabled.\15\nSee the `global-diff-hl-show-hunk-mouse-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-diff-hl-show-hunk-mouse-mode'.") (autoload 'global-diff-hl-show-hunk-mouse-mode "diff-hl-show-hunk" "\15\nToggle Diff-Hl-Show-Hunk-Mouse mode in all buffers.\15\nWith prefix ARG, enable Global Diff-Hl-Show-Hunk-Mouse mode if ARG is\15\npositive; otherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nDiff-Hl-Show-Hunk-Mouse mode is enabled in all buffers where\15\n`diff-hl-show-hunk-mouse-mode' would do it.\15\n\15\nSee `diff-hl-show-hunk-mouse-mode' for more information on\15\nDiff-Hl-Show-Hunk-Mouse mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'diff-hl-show-hunk-posframe "diff-hl-show-hunk-posframe" "\15\nImplementation to show the hunk in a posframe.\15\n\15\n(fn BUFFER &optional LINE)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/evil-goggles/evil-goggles-autoloads.el") (load-true-file-name load-file-name)) (defvar evil-goggles-mode nil "\15\nNon-nil if Evil-Goggles mode is enabled.\15\nSee the `evil-goggles-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `evil-goggles-mode'.") (autoload 'evil-goggles-mode "evil-goggles" "\15\nevil-goggles global minor mode.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Evil-Goggles mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='evil-goggles-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/anzu/anzu-autoloads.el") (load-true-file-name load-file-name)) (autoload 'anzu-mode "anzu" "\15\nMinor mode which displays the current search's match count in the mode-line.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Anzu mode'\15\nmode.  If the prefix argument is positive, enable the mode, and if it is\15\nzero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `anzu-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-anzu-mode 'globalized-minor-mode t) (defvar global-anzu-mode nil "\15\nNon-nil if Global Anzu mode is enabled.\15\nSee the `global-anzu-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-anzu-mode'.") (autoload 'global-anzu-mode "anzu" "\15\nToggle Anzu mode in all buffers.\15\nWith prefix ARG, enable Global Anzu mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nAnzu mode is enabled in all buffers where `anzu--turn-on' would do\15\nit.\15\n\15\nSee `anzu-mode' for more information on Anzu mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'anzu-query-replace-at-cursor "anzu" "\15\nReplace the symbol at point." t) (autoload 'anzu-query-replace-at-cursor-thing "anzu" "\15\nReplace the thing at point, determined by variable `anzu-replace-at-cursor-thing'." t) (autoload 'anzu-query-replace "anzu" "\15\nAnzu version of `query-replace'.\15\n\15\n(fn ARG)" t) (autoload 'anzu-query-replace-regexp "anzu" "\15\nAnzu version of `query-replace-regexp'.\15\n\15\n(fn ARG)" t) (autoload 'anzu-replace-at-cursor-thing "anzu" "\15\nLike `anzu-query-replace-at-cursor-thing', but without the query." t) (autoload 'anzu-isearch-query-replace "anzu" "\15\nAnzu version of `isearch-query-replace'.\15\n\15\n(fn ARG)" t) (autoload 'anzu-isearch-query-replace-regexp "anzu" "\15\nAnzu version of `isearch-query-replace-regexp'.\15\n\15\n(fn ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/nerd-icons/nerd-icons-autoloads.el") (load-true-file-name load-file-name)) (autoload 'nerd-icons-install-fonts "nerd-icons" "\15\nHelper function to download and install the latests fonts based on OS.\15\nThe provided Nerd Font is Symbols Nerd Font Mono.\15\nWhen PFX is non-nil, ignore the prompt and just install\15\n\15\n(fn &optional PFX)" t) (autoload 'nerd-icons-insert "nerd-icons" "\15\nInteractive icon insertion function.\15\nWhen Prefix ARG is non-nil, insert the propertized icon.\15\nWhen GLYPH-SET is non-nil, limit the candidates to the icon set matching it.\15\n\15\n(fn &optional ARG GLYPH-SET)" t) (autoload 'nerd-icons-icon-for-dir "nerd-icons" "\15\nGet the formatted icon for DIR.\15\nARG-OVERRIDES should be a plist containining `:height',\15\n`:v-adjust' or `:face' properties like in the normal icon\15\ninserting functions.\15\n\15\n(fn DIR &rest ARG-OVERRIDES)") (autoload 'nerd-icons-icon-for-file "nerd-icons" "\15\nGet the formatted icon for FILE.\15\nARG-OVERRIDES should be a plist containining `:height',\15\n`:v-adjust' or `:face' properties like in the normal icon\15\ninserting functions.\15\n\15\n(fn FILE &rest ARG-OVERRIDES)") (autoload 'nerd-icons-icon-for-extension "nerd-icons" "\15\nGet the formatted icon for EXT.\15\nARG-OVERRIDES should be a plist containining `:height',\15\n`:v-adjust' or `:face' properties like in the normal icon\15\ninserting functions.\15\n\15\n(fn EXT &rest ARG-OVERRIDES)") (autoload 'nerd-icons-icon-for-mode "nerd-icons" "\15\nGet the formatted icon for MODE.\15\nARG-OVERRIDES should be a plist containining `:height',\15\n`:v-adjust' or `:face' properties like in the normal icon\15\ninserting functions.\15\n\15\n(fn MODE &rest ARG-OVERRIDES)") (autoload 'nerd-icons-icon-for-url "nerd-icons" "\15\nGet the formatted icon for URL.\15\nIf an icon for URL isn't found in `nerd-icons-url-alist', a globe is used.\15\nARG-OVERRIDES should be a plist containining `:height',\15\n`:v-adjust' or `:face' properties like in the normal icon\15\ninserting functions.\15\n\15\n(fn URL &rest ARG-OVERRIDES)") (autoload 'nerd-icons-icon-for-buffer "nerd-icons" "\15\nGet the formatted icon for the current buffer.\15\n\15\nThis function prioritises the use of the buffers file extension to\15\ndiscern the icon when its `major-mode' matches its auto mode,\15\notherwise it will use the buffers `major-mode' to decide its\15\nicon.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/doom-modeline/doom-modeline-autoloads.el") (load-true-file-name load-file-name)) (autoload 'doom-modeline-set-main-modeline "doom-modeline" "\15\nSet main mode-line.\15\nIf DEFAULT is non-nil, set the default mode-line for all buffers.\15\n\15\n(fn &optional DEFAULT)") (defvar doom-modeline-mode nil "\15\nNon-nil if Doom-Modeline mode is enabled.\15\nSee the `doom-modeline-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `doom-modeline-mode'.") (autoload 'doom-modeline-mode "doom-modeline" "\15\nToggle `doom-modeline' on or off.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Doom-Modeline mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='doom-modeline-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'doom-modeline-env-setup-python "doom-modeline-env") (autoload 'doom-modeline-env-setup-ruby "doom-modeline-env") (autoload 'doom-modeline-env-setup-perl "doom-modeline-env") (autoload 'doom-modeline-env-setup-go "doom-modeline-env") (autoload 'doom-modeline-env-setup-elixir "doom-modeline-env") (autoload 'doom-modeline-env-setup-rust "doom-modeline-env") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/hl-todo/hl-todo-autoloads.el") (load-true-file-name load-file-name)) (autoload 'hl-todo-mode "hl-todo" "\15\nHighlight TODO and similar keywords in comments and strings.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Hl-Todo\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `hl-todo-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-hl-todo-mode 'globalized-minor-mode t) (defvar global-hl-todo-mode nil "\15\nNon-nil if Global Hl-Todo mode is enabled.\15\nSee the `global-hl-todo-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-hl-todo-mode'.") (autoload 'global-hl-todo-mode "hl-todo" "\15\nToggle Hl-Todo mode in all buffers.\15\nWith prefix ARG, enable Global Hl-Todo mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nHl-Todo mode is enabled in all buffers where\15\n`hl-todo--turn-on-mode-if-desired' would do it.\15\n\15\nSee `hl-todo-mode' for more information on Hl-Todo mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'hl-todo-next "hl-todo" "\15\nJump to the next TODO or similar keyword.\15\nThe prefix argument ARG specifies how many keywords to move.\15\nA negative argument means move backward that many keywords.\15\n\15\n(fn ARG)" t) (autoload 'hl-todo-previous "hl-todo" "\15\nJump to the previous TODO or similar keyword.\15\nThe prefix argument ARG specifies how many keywords to move.\15\nA negative argument means move forward that many keywords.\15\n\15\n(fn ARG)" t) (autoload 'hl-todo-occur "hl-todo" "\15\nUse `occur' to find all TODO or similar keywords.\15\nThis actually finds a superset of the highlighted keywords,\15\nbecause it uses a regexp instead of a more sophisticated\15\nmatcher.  It also finds occurrences that are not within a\15\nstring or comment." t) (autoload 'hl-todo-rgrep "hl-todo" "\15\nUse `rgrep' to find all TODO or similar keywords.\15\nThis actually finds a superset of the highlighted keywords,\15\nbecause it uses a regexp instead of a more sophisticated\15\nmatcher.  It also finds occurrences that are not within a\15\nstring or comment.  See `rgrep' for the meaning of REGEXP,\15\nFILES, DIR and CONFIRM, except that the type of prefix\15\nargument does not matter; with any prefix you can edit the\15\nconstructed shell command line before it is executed.\15\nAlso see option `hl-todo-keyword-faces'.\15\n\15\n(fn REGEXP &optional FILES DIR CONFIRM)" t) (autoload 'hl-todo-flymake "hl-todo" "\15\nFlymake backend for `hl-todo-mode'.\15\nDiagnostics are reported to REPORT-FN.  Use `add-hook' to\15\nregister this function in `flymake-diagnostic-functions' before\15\nenabling `flymake-mode'.\15\n\15\n(fn REPORT-FN &rest PLIST)") (autoload 'hl-todo-insert "hl-todo" "\15\nRead a TODO or similar keyword and insert it at point.\15\n\15\nIf point is not inside a string or comment, then insert a new\15\ncomment.  If point is at the end of the line, then insert the\15\ncomment there, otherwise insert it as a new line before the\15\ncurrent line.  When called interactively the KEYWORD is read\15\nvia `completing-read'.\15\n\15\nIf `hl-todo-require-punctuation' is non-nil and\15\n`hl-todo-highlight-punctuation' contains a single character,\15\nthen append that character to the inserted string.\15\n\15\n(fn KEYWORD)" t) (autoload 'hl-todo-search-and-highlight "hl-todo" "\15\nHighlight TODO and similar keywords starting at point.\15\nIntended to be added to `magit-revision-wash-message-hook' and\15\n`magit-log-wash-summary-hook', but might be useful elsewhere too.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/solaire-mode/solaire-mode-autoloads.el") (load-true-file-name load-file-name)) (defface solaire-default-face '((t :inherit default)) "\15\nAlternative version of the `default' face." :group 'solaire-mode) (autoload 'solaire-mode "solaire-mode" "\15\nMake current buffer a different color so others can be grossly incandescent.\15\n\15\nRemaps faces in `solaire-mode-remap-alist', then runs `solaire-mode-hook', where\15\nadditional mode-specific fixes may live. Lastly, adjusts the fringes for the\15\ncurrent frame.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Solaire\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `solaire-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'solaire-global-mode 'globalized-minor-mode t) (defvar solaire-global-mode nil "\15\nNon-nil if Solaire-Global mode is enabled.\15\nSee the `solaire-global-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `solaire-global-mode'.") (autoload 'solaire-global-mode "solaire-mode" "\15\nToggle Solaire mode in all buffers.\15\nWith prefix ARG, enable Solaire-Global mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nSolaire mode is enabled in all buffers where `turn-on-solaire-mode'\15\nwould do it.\15\n\15\nSee `solaire-mode' for more information on Solaire mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'turn-on-solaire-mode "solaire-mode" "\15\nConditionally enable `solaire-mode' in the current buffer.\15\n\15\nDoes nothing if the current buffer doesn't satisfy the function in\15\n`solaire-mode-real-buffer-fn'.\15\n\15\n(fn &rest _)" t) (autoload 'turn-off-solaire-mode "solaire-mode" "\15\nDisable `solaire-mode' in the current buffer.\15\n\15\n(fn &rest _)" t) (autoload 'solaire-mode-reset "solaire-mode" "\15\nReset `solaire-mode' in all buffers where it is enabled.\15\n\15\nUse this in case solaire-mode has caused some sort of problem, e.g. after\15\nchanging themes.  are more prelevant in Emacs 25 and 26, but far less so in 27+;\15\nparticularly where the fringe is concerned.\15\n\15\n(fn &rest _)" t) (autoload 'solaire-mode-reset-buffer "solaire-mode" "\15\nReset `solaire-mode' incurrent buffer.\15\n\15\nSee `solaire-mode-reset' for details.") (defun solaire-mode--prepare-for-theme-a (theme &rest _) "\15\nPrepare solaire-mode for THEME.\15\nMeant to be used as a `load-theme' advice." (when (and (get theme 'theme-feature) (memq theme custom-enabled-themes)) (setq solaire-mode--supported-p (cl-loop for spec in (get theme 'theme-settings) if (eq (nth 1 spec) 'solaire-default-face) return t) solaire-mode--swapped-p nil solaire-mode--theme theme) (when (bound-and-true-p solaire-global-mode) (if solaire-mode--supported-p (solaire-mode-swap-faces-maybe) (solaire-global-mode -1))))) (advice-add #'load-theme :after #'solaire-mode--prepare-for-theme-a) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/doom-themes/doom-themes-autoloads.el") (load-true-file-name load-file-name)) (autoload 'doom-name-to-rgb "doom-themes" "\15\nRetrieves the hexidecimal string repesented the named COLOR (e.g. \"red\")\15\nfor FRAME (defaults to the current frame).\15\n\15\n(fn COLOR)") (autoload 'doom-blend "doom-themes" "\15\nBlend two colors (hexidecimal strings) together by a coefficient ALPHA (a\15\nfloat between 0 and 1)\15\n\15\n(fn COLOR1 COLOR2 ALPHA)") (autoload 'doom-darken "doom-themes" "\15\nDarken a COLOR (a hexidecimal string) by a coefficient ALPHA (a float between\15\n0 and 1).\15\n\15\n(fn COLOR ALPHA)") (autoload 'doom-lighten "doom-themes" "\15\nBrighten a COLOR (a hexidecimal string) by a coefficient ALPHA (a float\15\nbetween 0 and 1).\15\n\15\n(fn COLOR ALPHA)") (autoload 'doom-color "doom-themes" "\15\nRetrieve a specific color named NAME (a symbol) from the current theme.\15\n\15\n(fn NAME &optional TYPE)") (autoload 'doom-ref "doom-themes" "\15\nTODO\15\n\15\n(fn FACE PROP &optional CLASS)") (autoload 'doom-themes-set-faces "doom-themes" "\15\nCustomize THEME (a symbol) with FACES.\15\n\15\nIf THEME is nil, it applies to all themes you load. FACES is a list of Doom\15\ntheme face specs. These is a simplified spec. For example:\15\n\15\n  (doom-themes-set-faces \\='user\15\n    \\='(default :background red :foreground blue)\15\n    \\='(doom-modeline-bar :background (if -modeline-bright modeline-bg highlight))\15\n    \\='(doom-modeline-buffer-file :inherit \\='mode-line-buffer-id :weight \\='bold)\15\n    \\='(doom-modeline-buffer-path :inherit \\='mode-line-emphasis :weight \\='bold)\15\n    \\='(doom-modeline-buffer-project-root :foreground green :weight \\='bold))\15\n\15\n(fn THEME &rest FACES)") (function-put 'doom-themes-set-faces 'lisp-indent-function 'defun) (when load-file-name (add-to-list 'custom-theme-load-path (let* ((base (file-name-directory load-file-name)) (dir (expand-file-name "themes/" base))) (or (and (file-directory-p dir) dir) base)))) (autoload 'doom-themes-neotree-config "doom-themes-ext-neotree" "\15\nInstall doom-themes' neotree configuration.\15\n\15\nIncludes an Atom-esque icon theme and highlighting based on filetype.") (autoload 'doom-themes-org-config "doom-themes-ext-org" "\15\nLoad `doom-themes-ext-org'.") (autoload 'doom-themes-treemacs-config "doom-themes-ext-treemacs" "\15\nInstall doom-themes' treemacs configuration.\15\n\15\nIncludes an Atom-esque icon theme and highlighting based on filetype.") (autoload 'doom-themes-visual-bell-fn "doom-themes-ext-visual-bell" "\15\nBlink the mode-line red briefly. Set `ring-bell-function' to this to use it.") (autoload 'doom-themes-visual-bell-config "doom-themes-ext-visual-bell" "\15\nEnable flashing the mode-line on error.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/consult/consult-autoloads.el") (load-true-file-name load-file-name)) (autoload 'consult-completion-in-region "consult" "\15\nUse minibuffer completion as the UI for `completion-at-point'.\15\n\15\nThe arguments START, END, COLLECTION and PREDICATE and expected return\15\nvalue are as specified for `completion-in-region'.  Use this function as\15\na value for `completion-in-region-function'.\15\n\15\n(fn START END COLLECTION PREDICATE)") (autoload 'consult-outline "consult" "\15\nJump to an outline heading, obtained by matching against `outline-regexp'.\15\n\15\nThis command supports narrowing to a heading level and candidate\15\npreview.  The initial narrowing LEVEL can be given as prefix\15\nargument.  The symbol at point is added to the future history.\15\n\15\n(fn &optional LEVEL)" t) (autoload 'consult-mark "consult" "\15\nJump to a marker in MARKERS list (defaults to buffer-local `mark-ring').\15\n\15\nThe command supports preview of the currently selected marker position.\15\nThe symbol at point is added to the future history.\15\n\15\n(fn &optional MARKERS)" t) (autoload 'consult-global-mark "consult" "\15\nJump to a marker in MARKERS list (defaults to `global-mark-ring').\15\n\15\nThe command supports preview of the currently selected marker position.\15\nThe symbol at point is added to the future history.\15\n\15\n(fn &optional MARKERS)" t) (autoload 'consult-line "consult" "\15\nSearch for a matching line.\15\n\15\nDepending on the setting `consult-point-placement' the command\15\njumps to the beginning or the end of the first match on the line\15\nor the line beginning.  The default candidate is the non-empty\15\nline next to point.  This command obeys narrowing.  Optional\15\nINITIAL input can be provided.  The search starting point is\15\nchanged if the START prefix argument is set.  The symbol at point\15\nand the last `isearch-string' is added to the future history.\15\n\15\n(fn &optional INITIAL START)" t) (autoload 'consult-line-multi "consult" "\15\nSearch for a matching line in multiple buffers.\15\n\15\nBy default search across all project buffers.  If the prefix\15\nargument QUERY is non-nil, all buffers are searched.  Optional\15\nINITIAL input can be provided.  The symbol at point and the last\15\n`isearch-string' is added to the future history.  In order to\15\nsearch a subset of buffers, QUERY can be set to a plist according\15\nto `consult--buffer-query'.\15\n\15\n(fn QUERY &optional INITIAL)" t) (autoload 'consult-keep-lines "consult" "\15\nFilter a subset of the lines in the current buffer with live preview.\15\n\15\nThe filtered lines are kept and the other lines are deleted.  When\15\ncalled interactively, the lines selected are those that match the\15\nminibuffer input.  In order to match the inverse of the input, prefix\15\nthe input with `! '.  When called from Elisp, the filtering is performed\15\nby a FILTER function.  If the buffer is narrowed to a region, the\15\ncommand only acts on this region.  See also `consult-focus-lines' which\15\nuses overlays to display only matching lines, but does not modify the\15\nbuffer.\15\n\15\nFILTER is the filter function, called for each line.\15\nINITIAL is the initial input.\15\n\15\n(fn FILTER &optional INITIAL)" t) (autoload 'consult-focus-lines "consult" "\15\nShow only matching lines using overlays.\15\n\15\nIn contrast to `consult-keep-lines' the buffer is not modified.  The\15\nFILTER selects the lines which are shown.  When called interactively,\15\nthe lines selected are those that match the minibuffer input.  In order\15\nto match the inverse of the input, prefix the input with `! '.  With\15\noptional prefix argument SHOW reveal the hidden lines.  Alternatively\15\nrerun the command and exit the minibuffer directly without input to\15\nreveal the lines.  When called from Elisp, the filtering is performed by\15\na FILTER function.  If the buffer is narrowed to a region, the command\15\nonly acts on this region.\15\n\15\nFILTER is the filter function, called for each line.\15\nSHOW is the prefix argument, if non-nil reveal all hidden lines.\15\nINITIAL is the initial input.\15\n\15\n(fn FILTER &optional SHOW INITIAL)" t) (autoload 'consult-goto-line "consult" "\15\nRead line number and jump to the line with preview.\15\n\15\nEnter either a line number to jump to the first column of the\15\ngiven line or line:column in order to jump to a specific column.\15\nJump directly if a line number is given as prefix ARG.  The\15\ncommand respects narrowing and the settings\15\n`consult-goto-line-numbers' and `consult-line-numbers-widen'.\15\n\15\n(fn &optional ARG)" t) (autoload 'consult-recent-file "consult" "\15\nFind recent file using `completing-read'." t) (autoload 'consult-mode-command "consult" "\15\nRun a command from any of the given MODES.\15\n\15\nIf no MODES are specified, use currently active major and minor modes.\15\n\15\n(fn &rest MODES)" t) (autoload 'consult-yank-from-kill-ring "consult" "\15\nSelect STRING from the kill ring and insert it.\15\nWith prefix ARG, put point at beginning, and mark at end, like `yank' does.\15\n\15\nThis command behaves like `yank-from-kill-ring', which also offers a\15\n`completing-read' interface to the `kill-ring'.  Additionally the\15\nConsult version supports preview of the selected string.\15\n\15\n(fn STRING &optional ARG)" t) (autoload 'consult-yank-pop "consult" "\15\nIf there is a recent yank act like `yank-pop'.\15\n\15\nOtherwise select string from the kill ring and insert it.\15\nSee `yank-pop' for the meaning of ARG.\15\n\15\nThis command behaves like `yank-pop', which also offers a\15\n`completing-read' interface to the `kill-ring'.  Additionally the\15\nConsult version supports preview of the selected string.\15\n\15\n(fn &optional ARG)" t) (autoload 'consult-yank-replace "consult" "\15\nSelect STRING from the kill ring.\15\n\15\nIf there was no recent yank, insert the string.\15\nOtherwise replace the just-yanked string with the selected string.\15\n\15\n(fn STRING)" t) (autoload 'consult-bookmark "consult" "\15\nIf bookmark NAME exists, open it, otherwise create a new bookmark with NAME.\15\n\15\nThe command supports preview of file bookmarks and narrowing.  See the\15\nvariable `consult-bookmark-narrow' for the narrowing configuration.\15\n\15\n(fn NAME)" t) (autoload 'consult-complex-command "consult" "\15\nSelect and evaluate command from the command history.\15\n\15\nThis command can act as a drop-in replacement for `repeat-complex-command'." t) (autoload 'consult-history "consult" "\15\nInsert string from HISTORY of current buffer.\15\nIn order to select from a specific HISTORY, pass the history\15\nvariable as argument.  INDEX is the name of the index variable to\15\nupdate, if any.  BOL is the function which jumps to the beginning\15\nof the prompt.  See also `cape-history' from the Cape package.\15\n\15\n(fn &optional HISTORY INDEX BOL)" t) (autoload 'consult-isearch-history "consult" "\15\nRead a search string with completion from the Isearch history.\15\n\15\nThis replaces the current search string if Isearch is active, and\15\nstarts a new Isearch session otherwise." t) (autoload 'consult-minor-mode-menu "consult" "\15\nEnable or disable minor mode.\15\n\15\nThis is an alternative to `minor-mode-menu-from-indicator'." t) (autoload 'consult-theme "consult" "\15\nDisable current themes and enable THEME from `consult-themes'.\15\n\15\nThe command supports previewing the currently selected theme.\15\n\15\n(fn THEME)" t) (autoload 'consult-buffer "consult" "\15\nEnhanced `switch-to-buffer' command with support for virtual buffers.\15\n\15\nThe command supports recent files, bookmarks, views and project files as\15\nvirtual buffers.  Buffers are previewed.  Narrowing to buffers (b), files (f),\15\nbookmarks (m) and project files (p) is supported via the corresponding\15\nkeys.  In order to determine the project-specific files and buffers, the\15\n`consult-project-function' is used.  The virtual buffer SOURCES\15\ndefault to `consult-buffer-sources'.  See `consult--multi' for the\15\nconfiguration of the virtual buffer sources.\15\n\15\n(fn &optional SOURCES)" t) (autoload 'consult-project-buffer "consult" "\15\nEnhanced `project-switch-to-buffer' command with support for virtual buffers.\15\nThe command may prompt you for a project directory if it is invoked from\15\noutside a project.  See `consult-buffer' for more details." t) (autoload 'consult-buffer-other-window "consult" "\15\nVariant of `consult-buffer', switching to a buffer in another window." t) (autoload 'consult-buffer-other-frame "consult" "\15\nVariant of `consult-buffer', switching to a buffer in another frame." t) (autoload 'consult-buffer-other-tab "consult" "\15\nVariant of `consult-buffer', switching to a buffer in another tab." t) (autoload 'consult-grep "consult" "\15\nSearch with `grep' for files in DIR where the content matches a regexp.\15\n\15\nThe initial input is given by the INITIAL argument.  DIR can be nil, a\15\ndirectory string or a list of file/directory paths.  If `consult-grep'\15\nis called interactively with a prefix argument, the user can specify the\15\ndirectories or files to search in.  Multiple directories or files must\15\nbe separated by comma in the minibuffer, since they are read via\15\n`completing-read-multiple'.  By default the project directory is used if\15\n`consult-project-function' is defined and returns non-nil.  Otherwise\15\nthe `default-directory' is searched.  If the command is invoked with a\15\ndouble prefix argument (twice `C-u') the user is asked for a project, if\15\nnot yet inside a project, or the current project is searched.\15\n\15\nThe input string is split, the first part of the string (grep input) is\15\npassed to the asynchronous grep process and the second part of the\15\nstring is passed to the completion-style filtering.\15\n\15\nThe input string is split at a punctuation character, which is given as\15\nthe first character of the input string.  The format is similar to\15\nPerl-style regular expressions, e.g., /regexp/.  Furthermore command\15\nline options can be passed to grep, specified behind --.  The overall\15\nprompt input has the form `#async-input -- grep-opts#filter-string'.\15\n\15\nNote that the grep input string is transformed from Emacs regular\15\nexpressions to Posix regular expressions.  Always enter Emacs regular\15\nexpressions at the prompt.  `consult-grep' behaves like builtin Emacs\15\nsearch commands, e.g., Isearch, which take Emacs regular expressions.\15\nFurthermore the asynchronous input split into words, each word must\15\nmatch separately and in any order.  See `consult--regexp-compiler' for\15\nthe inner workings.  In order to disable transformations of the grep\15\ninput, adjust `consult--regexp-compiler' accordingly.\15\n\15\nHere we give a few example inputs:\15\n\15\n#alpha beta         : Search for alpha and beta in any order.\15\n#alpha.*beta        : Search for alpha before beta.\15\n#\\(alpha\\|beta\\) : Search for alpha or beta (Note Emacs syntax!)\15\n#word -- -C3        : Search for word, include 3 lines as context\15\n#first#second       : Search for first, quick filter for second.\15\n\15\nThe symbol at point is added to the future history.\15\n\15\n(fn &optional DIR INITIAL)" t) (autoload 'consult-git-grep "consult" "\15\nSearch with `git grep' for files in DIR with INITIAL input.\15\nSee `consult-grep' for details.\15\n\15\n(fn &optional DIR INITIAL)" t) (autoload 'consult-ripgrep "consult" "\15\nSearch with `rg' for files in DIR with INITIAL input.\15\nSee `consult-grep' for details.\15\n\15\n(fn &optional DIR INITIAL)" t) (autoload 'consult-find "consult" "\15\nSearch for files with `find' in DIR.\15\nThe file names must match the input regexp.  INITIAL is the\15\ninitial minibuffer input.  See `consult-grep' for details\15\nregarding the asynchronous search and the arguments.\15\n\15\n(fn &optional DIR INITIAL)" t) (autoload 'consult-fd "consult" "\15\nSearch for files with `fd' in DIR.\15\nThe file names must match the input regexp.  INITIAL is the\15\ninitial minibuffer input.  See `consult-grep' for details\15\nregarding the asynchronous search and the arguments.\15\n\15\n(fn &optional DIR INITIAL)" t) (autoload 'consult-locate "consult" "\15\nSearch with `locate' for files which match input given INITIAL input.\15\n\15\nThe input is treated literally such that locate can take advantage of\15\nthe locate database index.  Regular expressions would often force a slow\15\nlinear search through the entire database.  The locate process is started\15\nasynchronously, similar to `consult-grep'.  See `consult-grep' for more\15\ndetails regarding the asynchronous search.\15\n\15\n(fn &optional INITIAL)" t) (autoload 'consult-man "consult" "\15\nSearch for man page given INITIAL input.\15\n\15\nThe input string is not preprocessed and passed literally to the\15\nunderlying man commands.  The man process is started asynchronously,\15\nsimilar to `consult-grep'.  See `consult-grep' for more details regarding\15\nthe asynchronous search.\15\n\15\n(fn &optional INITIAL)" t) (autoload 'consult-compile-error "consult-compile" "\15\nJump to a compilation error in the current buffer.\15\n\15\nThis command collects entries from compilation buffers and grep buffers\15\nrelated to the current buffer.  The command supports preview of the\15\ncurrently selected error.  With prefix ARG, jump to the error message in\15\nthe compilation buffer, instead of to the actual location of the error.\15\n\15\n(fn &optional ARG)" t) (autoload 'consult-flymake "consult-flymake" "\15\nJump to Flymake diagnostic.\15\nWhen PROJECT is non-nil then prompt with diagnostics from all\15\nbuffers in the current project instead of just the current buffer.\15\n\15\n(fn &optional PROJECT)" t) (autoload 'consult-imenu "consult-imenu" "\15\nSelect item from flattened `imenu' using `completing-read' with preview.\15\n\15\nThe command supports preview and narrowing.  See the variable\15\n`consult-imenu-config', which configures the narrowing.\15\nThe symbol at point is added to the future history.\15\n\15\nSee also `consult-imenu-multi'." t) (autoload 'consult-imenu-multi "consult-imenu" "\15\nSelect item from the imenus of all buffers from the same project.\15\n\15\nIn order to determine the buffers belonging to the same project, the\15\n`consult-project-function' is used.  Only the buffers with the\15\nsame major mode as the current buffer are used.  See also\15\n`consult-imenu' for more details.  In order to search a subset of buffers,\15\nQUERY can be set to a plist according to `consult--buffer-query'.\15\n\15\n(fn &optional QUERY)" t) (autoload 'consult-info "consult-info" "\15\nFull text search through info MANUALS.\15\n\15\n(fn &rest MANUALS)" t) (defun consult-info-define (name &rest manuals) "\15\nDefine `consult-info-NAME' command to search through MANUALS.\15\nMANUALS is a list of a strings. NAME can be a symbol or a string. If\15\nNAME is a string, it is added to the MANUALS list. Return name of\15\ndefined command as symbol." (let ((cmd (intern (format "consult-info-%s" name)))) (when (stringp name) (push name manuals)) (defalias cmd (lambda nil (interactive) (apply #'consult-info manuals)) (format "Search via `consult-info' through the manual%s %s:\n\n%s" (if (cdr manuals) "s" "") (mapconcat (lambda (m) (format "\"%s\"" m)) manuals ", ") (mapconcat (lambda (m) (format "  * Info node `(%s)'" m)) manuals "\n"))) cmd)) (autoload 'consult-kmacro "consult-kmacro" "\15\nRun a chosen keyboard macro.\15\n\15\nWith prefix ARG, run the macro that many times.\15\nMacros containing mouse clicks are omitted.\15\n\15\n(fn ARG)" t) (autoload 'consult-org-heading "consult-org" "\15\nJump to an Org heading.\15\n\15\nMATCH and SCOPE are as in `org-map-entries' and determine which\15\nentries are offered.  By default, all entries of the current\15\nbuffer are offered.\15\n\15\n(fn &optional MATCH SCOPE)" t) (autoload 'consult-org-agenda "consult-org" "\15\nJump to an Org agenda heading.\15\n\15\nBy default, all agenda entries are offered.  MATCH is as in\15\n`org-map-entries' and can used to refine this.\15\n\15\n(fn &optional MATCH)" t) (autoload 'consult-register-window "consult-register" "\15\nEnhanced drop-in replacement for `register-preview'.\15\n\15\nBUFFER is the window buffer.\15\nSHOW-EMPTY must be t if the window should be shown for an empty register list.\15\nOptional argument PRED specifies the types of register to show.\15\n\15\n(fn BUFFER &optional SHOW-EMPTY PRED)") (autoload 'consult-register-format "consult-register" "\15\nEnhanced preview of register REG.\15\nThis function can be used as `register-preview-function'.\15\nIf COMPLETION is non-nil format the register for completion.\15\n\15\n(fn REG &optional COMPLETION)") (autoload 'consult-register "consult-register" "\15\nLoad register and either jump to location or insert the stored text.\15\n\15\nThis command is useful to search the register contents.  For quick access\15\nto registers it is still recommended to use the register functions\15\n`consult-register-load' and `consult-register-store' or the built-in\15\nbuilt-in register access functions.  The command supports narrowing, see\15\n`consult-register--narrow'.  Marker positions are previewed.  See\15\n`jump-to-register' and `insert-register' for the meaning of prefix ARG.\15\n\15\n(fn &optional ARG)" t) (autoload 'consult-register-load "consult-register" "\15\nDo what I mean with a REG.\15\n\15\nFor a window configuration, restore it.  For a number or text, insert it.\15\nFor a location, jump to it.  See `jump-to-register' and `insert-register'\15\nfor the meaning of prefix ARG.\15\n\15\n(fn REG &optional ARG)" t) (autoload 'consult-register-store "consult-register" "\15\nStore register dependent on current context, showing an action menu.\15\n\15\nWith an active region, store/append/prepend the contents, optionally\15\ndeleting the region when a prefix ARG is given.  With a numeric prefix\15\nARG, store or add the number.  Otherwise store point, frameset, window or\15\nkmacro.\15\n\15\n(fn ARG)" t) (autoload 'consult-xref "consult-xref" "\15\nShow xrefs with preview in the minibuffer.\15\n\15\nThis function can be used for `xref-show-xrefs-function'.\15\nSee `xref-show-xrefs-function' for the description of the\15\nFETCHER and ALIST arguments.\15\n\15\n(fn FETCHER &optional ALIST)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/consult-yasnippet/consult-yasnippet-autoloads.el") (load-true-file-name load-file-name)) (autoload 'consult-yasnippet-visit-snippet-file "consult-yasnippet" "\15\nVisit the snippet file associated with TEMPLATE.\15\nWhen called interactively this command previews snippet completions in\15\nthe current buffer, and then opens the selected snippets template file\15\nusing `yas--visit-snippet-file-1'.\15\n\15\n(fn TEMPLATE)" t) (autoload 'consult-yasnippet "consult-yasnippet" "\15\nInteractively select and expand a yasnippet template.\15\nThis command presents a completing read interface containing all currently\15\navailable snippet expansions, with live previews for each snippet. Once\15\nselected a chosen snippet will be expanded at point using\15\n`yas-expand-snippet'.\15\n\15\nWith ARG select snippets from all snippet tables, not just the current one.\15\n\15\n(fn ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/wgrep/wgrep-autoloads.el") (load-true-file-name load-file-name)) (autoload 'wgrep-setup "wgrep" "\15\nSetup wgrep preparation.") (add-hook 'grep-setup-hook 'wgrep-setup) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/marginalia/marginalia-autoloads.el") (load-true-file-name load-file-name)) (defvar marginalia-mode nil "\15\nNon-nil if Marginalia mode is enabled.\15\nSee the `marginalia-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `marginalia-mode'.") (autoload 'marginalia-mode "marginalia" "\15\nAnnotate completion candidates with richer information.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Marginalia mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='marginalia-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'marginalia-cycle "marginalia" "\15\nCycle between annotators in `marginalia-annotators'." t) (function-put 'marginalia-cycle 'completion-predicate #'(lambda (&rest _) (> (minibuffer-depth) 1))) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/embark/embark-autoloads.el") (load-true-file-name load-file-name)) (defun embark--record-this-command nil "\15\nRecord command which opened the minibuffer.\15\nWe record this because it will be the default action.\15\nThis function is meant to be added to `minibuffer-setup-hook'." (setq-local embark--command this-command)) (add-hook 'minibuffer-setup-hook #'embark--record-this-command) (autoload 'embark-eldoc-first-target "embark" "\15\nEldoc function reporting the first Embark target at point.\15\nThis function uses the eldoc REPORT callback and is meant to be\15\nadded to `eldoc-documentation-functions'.\15\n\15\n(fn REPORT &rest _)") (autoload 'embark-eldoc-target-types "embark" "\15\nEldoc function reporting the types of all Embark targets at point.\15\nThis function uses the eldoc REPORT callback and is meant to be\15\nadded to `eldoc-documentation-functions'.\15\n\15\n(fn REPORT &rest _)") (autoload 'embark-bindings-in-keymap "embark" "\15\nExplore command key bindings in KEYMAP with `completing-read'.\15\nThe selected command will be executed.  Interactively, prompt the\15\nuser for a KEYMAP variable.\15\n\15\n(fn KEYMAP)" t) (autoload 'embark-bindings "embark" "\15\nExplore current command key bindings with `completing-read'.\15\nThe selected command will be executed.\15\n\15\nThis shows key bindings from minor mode maps and the local\15\nmap (usually set by the major mode), but also less common keymaps\15\nsuch as those from a text property or overlay, or the overriding\15\nmaps: `overriding-terminal-local-map' and `overriding-local-map'.\15\n\15\nAdditionally, if GLOBAL is non-nil (interactively, if called with\15\na prefix argument), this command includes global key bindings.\15\n\15\n(fn GLOBAL)" t) (autoload 'embark-bindings-at-point "embark" "\15\nExplore all key bindings at point with `completing-read'.\15\nThe selected command will be executed.\15\n\15\nThis command lists key bindings found in keymaps specified by the\15\ntext properties `keymap' or `local-map', from either buffer text\15\nor an overlay.  These are not widely used in Emacs, and when they\15\nare used can be somewhat hard to discover.  Examples of locations\15\nthat have such a keymap are links and images in `eww' buffers,\15\nattachment links in `gnus' article buffers, and the stash line\15\nin a `vc-dir' buffer." t) (autoload 'embark-prefix-help-command "embark" "\15\nPrompt for and run a command bound in the prefix used for this command.\15\nThe prefix described consists of all but the last event of the\15\nkey sequence that ran this command.  This function is intended to\15\nbe used as a value for `prefix-help-command'.\15\n\15\nIn addition to using completion to select a command, you can also\15\ntype @ and the key binding (without the prefix)." t) (autoload 'embark-act "embark" "\15\nPrompt the user for an action and perform it.\15\nThe targets of the action are chosen by `embark-target-finders'.\15\nBy default, if called from a minibuffer the target is the top\15\ncompletion candidate.  When called from a non-minibuffer buffer\15\nthere can multiple targets and you can cycle among them by using\15\n`embark-cycle' (which is bound by default to the same key\15\nbinding `embark-act' is, but see `embark-cycle-key').\15\n\15\nThis command uses `embark-prompter' to ask the user to specify an\15\naction, and calls it injecting the target at the first minibuffer\15\nprompt.\15\n\15\nIf you call this from the minibuffer, it can optionally quit the\15\nminibuffer.  The variable `embark-quit-after-action' controls\15\nwhether calling `embark-act' with nil ARG quits the minibuffer,\15\nand if ARG is non-nil it will do the opposite.  Interactively,\15\nARG is the prefix argument.\15\n\15\nIf instead you call this from outside the minibuffer, the first\15\nARG targets are skipped over (if ARG is negative the skipping is\15\ndone by cycling backwards) and cycling starts from the following\15\ntarget.\15\n\15\n(fn &optional ARG)" t) (autoload 'embark-act-all "embark" "\15\nPrompt the user for an action and perform it on each candidate.\15\nThe candidates are chosen by `embark-candidate-collectors'.  By\15\ndefault, if `embark-select' has been used to select some\15\ncandidates, then `embark-act-all' will act on those candidates;\15\notherwise, if the selection is empty and `embark-act-all' is\15\ncalled from a minibuffer, then the candidates are the completion\15\ncandidates.\15\n\15\nThis command uses `embark-prompter' to ask the user to specify an\15\naction, and calls it injecting the target at the first minibuffer\15\nprompt.\15\n\15\nIf you call this from the minibuffer, it can optionally quit the\15\nminibuffer.  The variable `embark-quit-after-action' controls\15\nwhether calling `embark-act' with nil ARG quits the minibuffer,\15\nand if ARG is non-nil it will do the opposite.  Interactively,\15\nARG is the prefix argument.\15\n\15\n(fn &optional ARG)" t) (autoload 'embark-dwim "embark" "\15\nRun the default action on the current target.\15\nThe target of the action is chosen by `embark-target-finders'.\15\n\15\nIf the target comes from minibuffer completion, then the default\15\naction is the command that opened the minibuffer in the first\15\nplace, unless overridden by `embark-default-action-overrides'.\15\n\15\nFor targets that do not come from minibuffer completion\15\n(typically some thing at point in a regular buffer) and whose\15\ntype is not listed in `embark-default-action-overrides', the\15\ndefault action is given by whatever binding RET has in the action\15\nkeymap for the target's type.\15\n\15\nSee `embark-act' for the meaning of the prefix ARG.\15\n\15\n(fn &optional ARG)" t) (autoload 'embark-become "embark" "\15\nMake current command become a different command.\15\nTake the current minibuffer input as initial input for new\15\ncommand.  The new command can be run normally using key bindings or\15\n\\[execute-extended-command], but if the current command is found in a keymap in\15\n`embark-become-keymaps', that keymap is activated to provide\15\nconvenient access to the other commands in it.\15\n\15\nIf FULL is non-nil (interactively, if called with a prefix\15\nargument), the entire minibuffer contents are used as the initial\15\ninput of the new command.  By default only the part of the\15\nminibuffer contents between the current completion boundaries is\15\ntaken.  What this means is fairly technical, but (1) usually\15\nthere is no difference: the completion boundaries include the\15\nentire minibuffer contents, and (2) the most common case where\15\nthese notions differ is file completion, in which case the\15\ncompletion boundaries single out the path component containing\15\npoint.\15\n\15\n(fn &optional FULL)" t) (autoload 'embark-collect "embark" "\15\nCreate an Embark Collect buffer.\15\n\15\nTo control the display, add an entry to `display-buffer-alist'\15\nwith key \"Embark Collect\".\15\n\15\nIn Embark Collect buffers `revert-buffer' is remapped to\15\n`embark-rerun-collect-or-export', which has slightly unusual\15\nbehavior if the buffer was obtained by running `embark-collect'\15\nfrom within a minibuffer completion session.  In that case\15\nrerunning just restarts the completion session, that is, the\15\ncommand that opened the minibuffer is run again and the\15\nminibuffer contents restored.  You can then interact normally with\15\nthe command, perhaps editing the minibuffer contents, and, if you\15\nwish, you can rerun `embark-collect' to get an updated buffer." t) (autoload 'embark-live "embark" "\15\nCreate a live-updating Embark Collect buffer.\15\n\15\nTo control the display, add an entry to `display-buffer-alist'\15\nwith key \"Embark Live\"." t) (autoload 'embark-export "embark" "\15\nCreate a type-specific buffer to manage current candidates.\15\nThe variable `embark-exporters-alist' controls how to make the\15\nbuffer for each type of completion.\15\n\15\nIn Embark Export buffers `revert-buffer' is remapped to\15\n`embark-rerun-collect-or-export', which has slightly unusual\15\nbehavior if the buffer was obtained by running `embark-export'\15\nfrom within a minibuffer completion session.  In that case\15\nreverting just restarts the completion session, that is, the\15\ncommand that opened the minibuffer is run again and the\15\nminibuffer contents restored.  You can then interact normally\15\nwith the command, perhaps editing the minibuffer contents, and,\15\nif you wish, you can rerun `embark-export' to get an updated\15\nbuffer." t) (autoload 'embark-select "embark" "\15\nAdd or remove the target from the current buffer's selection.\15\nYou can act on all selected targets at once with `embark-act-all'.\15\nWhen called from outside `embark-act' this command will select\15\nthe first target at point." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/consult-flycheck/consult-flycheck-autoloads.el") (load-true-file-name load-file-name)) (autoload 'consult-flycheck "consult-flycheck" "\15\nJump to flycheck error." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/consult-dir/consult-dir-autoloads.el") (load-true-file-name load-file-name)) (autoload 'consult-dir-jump-file "consult-dir" "\15\nJump to file from the directory in the minibuffer prompt." t) (autoload 'consult-dir "consult-dir" "\15\nChoose a directory and act on it.\15\n\15\nThe action taken on the directory is the value of\15\n`consult-dir-default-command'. The default is to call\15\n`find-file' starting at this directory.\15\n\15\nWhen called from the minibuffer, insert the directory into the\15\nminibuffer prompt instead. Existing minibuffer contents will be\15\nshadowed or deleted depending on the value of\15\n`consult-dir-shadow-filenames'.\15\n\15\nThe list of sources for directory paths is\15\n`consult-dir-sources', which can be customized." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/orderless/orderless-autoloads.el") (load-true-file-name load-file-name)) (autoload 'orderless-all-completions "orderless" "\15\nSplit STRING into components and find entries TABLE matching all.\15\nThe predicate PRED is used to constrain the entries in TABLE.  The\15\nmatching portions of each candidate are highlighted.\15\nThis function is part of the `orderless' completion style.\15\n\15\n(fn STRING TABLE PRED POINT)") (autoload 'orderless-try-completion "orderless" "\15\nComplete STRING to unique matching entry in TABLE.\15\nThis uses `orderless-all-completions' to find matches for STRING\15\nin TABLE among entries satisfying PRED.  If there is only one\15\nmatch, it completes to that match.  If there are no matches, it\15\nreturns nil.  In any other case it \"completes\" STRING to\15\nitself, without moving POINT.\15\nThis function is part of the `orderless' completion style.\15\n\15\n(fn STRING TABLE PRED POINT)") (add-to-list 'completion-styles-alist '(orderless orderless-try-completion orderless-all-completions "Completion of multiple components, in any order.")) (autoload 'orderless-ivy-re-builder "orderless" "\15\nConvert STR into regexps for use with ivy.\15\nThis function is for integration of orderless with ivy, use it as\15\na value in `ivy-re-builders-alist'.\15\n\15\n(fn STR)") (autoload 'orderless-kwd-dispatch "orderless-kwd" "\15\nMatch COMPONENT against the keywords in `orderless-kwd-alist'.\15\n\15\n(fn COMPONENT INDEX TOTAL)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/vertico/vertico-autoloads.el") (load-true-file-name load-file-name)) (defvar vertico-mode nil "\15\nNon-nil if Vertico mode is enabled.\15\nSee the `vertico-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `vertico-mode'.") (autoload 'vertico-mode "vertico" "\15\nVERTical Interactive COmpletion.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Vertico mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='vertico-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (defvar vertico-buffer-mode nil "\15\nNon-nil if Vertico-Buffer mode is enabled.\15\nSee the `vertico-buffer-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `vertico-buffer-mode'.") (autoload 'vertico-buffer-mode "vertico-buffer" "\15\nDisplay Vertico like a regular buffer in a large window.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Vertico-Buffer mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='vertico-buffer-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'vertico-directory-enter "vertico-directory" "\15\nEnter directory or exit completion with current candidate.\15\nExit with current input if prefix ARG is given.\15\n\15\n(fn &optional ARG)" t) (autoload 'vertico-directory-up "vertico-directory" "\15\nDelete N names before point.\15\n\15\n(fn &optional N)" t) (autoload 'vertico-directory-delete-char "vertico-directory" "\15\nDelete N directories or chars before point.\15\n\15\n(fn N)" t) (autoload 'vertico-directory-delete-word "vertico-directory" "\15\nDelete N directories or words before point.\15\n\15\n(fn N)" t) (autoload 'vertico-directory-tidy "vertico-directory" "\15\nTidy shadowed file name, see `rfn-eshadow-overlay'.") (defvar vertico-flat-mode nil "\15\nNon-nil if Vertico-Flat mode is enabled.\15\nSee the `vertico-flat-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `vertico-flat-mode'.") (autoload 'vertico-flat-mode "vertico-flat" "\15\nFlat, horizontal display for Vertico.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Vertico-Flat mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='vertico-flat-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (defvar vertico-grid-mode nil "\15\nNon-nil if Vertico-Grid mode is enabled.\15\nSee the `vertico-grid-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `vertico-grid-mode'.") (autoload 'vertico-grid-mode "vertico-grid" "\15\nGrid display for Vertico.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Vertico-Grid mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='vertico-grid-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (defvar vertico-indexed-mode nil "\15\nNon-nil if Vertico-Indexed mode is enabled.\15\nSee the `vertico-indexed-mode' command\15\nfor a description of this minor mode.") (autoload 'vertico-indexed-mode "vertico-indexed" "\15\nPrefix candidates with indices.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Vertico-Indexed mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='vertico-indexed-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (defvar vertico-mouse-mode nil "\15\nNon-nil if Vertico-Mouse mode is enabled.\15\nSee the `vertico-mouse-mode' command\15\nfor a description of this minor mode.") (autoload 'vertico-mouse-mode "vertico-mouse" "\15\nMouse support for Vertico.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Vertico-Mouse mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='vertico-mouse-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (defvar vertico-multiform-mode nil "\15\nNon-nil if Vertico-Multiform mode is enabled.\15\nSee the `vertico-multiform-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `vertico-multiform-mode'.") (autoload 'vertico-multiform-mode "vertico-multiform" "\15\nConfigure Vertico in various forms per command.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Vertico-Multiform mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='vertico-multiform-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'vertico-quick-jump "vertico-quick" "\15\nJump to candidate using quick keys." t) (autoload 'vertico-quick-exit "vertico-quick" "\15\nExit with candidate using quick keys." t) (autoload 'vertico-quick-insert "vertico-quick" "\15\nInsert candidate using quick keys." t) (autoload 'vertico-repeat-save "vertico-repeat" "\15\nSave Vertico session for `vertico-repeat'.\15\nThis function must be registered as `minibuffer-setup-hook'.") (autoload 'vertico-repeat-next "vertico-repeat" "\15\nRepeat Nth next Vertico completion session.\15\nThis command must be called from an existing Vertico session\15\nafter `vertico-repeat-previous'.\15\n\15\n(fn N)" t) (autoload 'vertico-repeat-previous "vertico-repeat" "\15\nRepeat Nth previous Vertico completion session.\15\nIf called from an existing Vertico session, restore the input and\15\nselected candidate for the current command.\15\n\15\n(fn N)" t) (autoload 'vertico-repeat-select "vertico-repeat" "\15\nSelect a Vertico session from the session history and repeat it.\15\nIf called from an existing Vertico session, you can select among\15\nprevious sessions for the current command." t) (autoload 'vertico-repeat "vertico-repeat" "\15\nRepeat last Vertico session.\15\nIf prefix ARG is non-nil, offer completion menu to select from session history.\15\n\15\n(fn &optional ARG)" t) (defvar vertico-reverse-mode nil "\15\nNon-nil if Vertico-Reverse mode is enabled.\15\nSee the `vertico-reverse-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `vertico-reverse-mode'.") (autoload 'vertico-reverse-mode "vertico-reverse" "\15\nReverse the Vertico display.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Vertico-Reverse mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='vertico-reverse-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'vertico-sort-history-length-alpha "vertico-sort") (autoload 'vertico-sort-history-alpha "vertico-sort") (autoload 'vertico-sort-length-alpha "vertico-sort") (autoload 'vertico-sort-alpha "vertico-sort") (autoload 'vertico-suspend "vertico-suspend" "\15\nSuspend the current completion session.\15\nIf the command is invoked from within the Vertico minibuffer, the\15\ncurrent session is suspended.  If the command is invoked from\15\noutside the minibuffer, the active minibuffer is either selected\15\nor the latest completion session is restored." t) (defvar vertico-unobtrusive-mode nil "\15\nNon-nil if Vertico-Unobtrusive mode is enabled.\15\nSee the `vertico-unobtrusive-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `vertico-unobtrusive-mode'.") (autoload 'vertico-unobtrusive-mode "vertico-unobtrusive" "\15\nUnobtrusive display for Vertico.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Vertico-Unobtrusive mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='vertico-unobtrusive-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/yasnippet-capf/yasnippet-capf-autoloads.el") (load-true-file-name load-file-name)) (autoload 'yasnippet-capf "yasnippet-capf" "\15\nComplete with yasnippet at point.\15\nIf INTERACTIVE is nil the function acts like a Capf.\15\n\15\n(fn &optional INTERACTIVE)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/cape/cape-autoloads.el") (load-true-file-name load-file-name)) (autoload 'cape-history "cape" "\15\nComplete from Eshell, Comint or minibuffer history.\15\nSee also `consult-history' for a more flexible variant based on\15\n`completing-read'.  If INTERACTIVE is nil the function acts like a Capf.\15\n\15\n(fn &optional INTERACTIVE)" t) (autoload 'cape-file "cape" "\15\nComplete file name at point.\15\nSee the user option `cape-file-directory-must-exist'.\15\nIf INTERACTIVE is nil the function acts like a Capf.\15\n\15\n(fn &optional INTERACTIVE)" t) (autoload 'cape-elisp-symbol "cape" "\15\nComplete Elisp symbol at point.\15\nIf INTERACTIVE is nil the function acts like a Capf.\15\n\15\n(fn &optional INTERACTIVE)" t) (autoload 'cape-elisp-block "cape" "\15\nComplete Elisp in Org or Markdown code block.\15\nThis Capf is particularly useful for literate Emacs configurations.\15\nIf INTERACTIVE is nil the function acts like a Capf.\15\n\15\n(fn &optional INTERACTIVE)" t) (autoload 'cape-dabbrev "cape" "\15\nComplete with Dabbrev at point.\15\n\15\nIf INTERACTIVE is nil the function acts like a Capf.  In case you\15\nobserve a performance issue with auto-completion and `cape-dabbrev'\15\nit is strongly recommended to disable scanning in other buffers.\15\nSee the user option `cape-dabbrev-buffer-function'.\15\n\15\n(fn &optional INTERACTIVE)" t) (autoload 'cape-dict "cape" "\15\nComplete word from dictionary at point.\15\nThis completion function works best if the dictionary is sorted\15\nby frequency.  See the custom option `cape-dict-file'.  If\15\nINTERACTIVE is nil the function acts like a Capf.\15\n\15\n(fn &optional INTERACTIVE)" t) (autoload 'cape-abbrev "cape" "\15\nComplete abbreviation at point.\15\nIf INTERACTIVE is nil the function acts like a Capf.\15\n\15\n(fn &optional INTERACTIVE)" t) (autoload 'cape-line "cape" "\15\nComplete current line from other lines.\15\nThe buffers returned by `cape-line-buffer-function' are scanned for lines.\15\nIf INTERACTIVE is nil the function acts like a Capf.\15\n\15\n(fn &optional INTERACTIVE)" t) (autoload 'cape-company-to-capf "cape" "\15\nConvert Company BACKEND function to Capf.\15\nVALID is a function taking the old and new input string.  It should\15\nreturn nil if the cached candidates became invalid.  The default value\15\nfor VALID is `string-prefix-p' such that the candidates are only fetched\15\nagain if the input prefix changed.\15\n\15\n(fn BACKEND &optional VALID)") (autoload 'cape-interactive "cape" "\15\nComplete interactively with the given CAPFS.\15\n\15\n(fn &rest CAPFS)") (autoload 'cape-capf-interactive "cape" "\15\nCreate interactive completion function from CAPF.\15\n\15\n(fn CAPF)") (autoload 'cape-wrap-super "cape" "\15\nCall CAPFS and return merged completion result.\15\nThe CAPFS list can contain the keyword `:with' to mark the Capfs\15\nafterwards as auxiliary.  One of the non-auxiliary Capfs before `:with'\15\nmust return non-nil for the super Capf to set in and return a non-nil\15\nresult.  Such behavior is useful when listing multiple super Capfs in\15\nthe `completion-at-point-functions':\15\n\15\n  (setq completion-at-point-functions\15\n        (list (cape-capf-super \\='eglot-completion-at-point\15\n                               :with \\='tempel-complete)\15\n              (cape-capf-super \\='cape-dabbrev\15\n                               :with \\='tempel-complete)))\15\n\15\n(fn &rest CAPFS)") (autoload 'cape-wrap-debug "cape" "\15\nCall CAPF and return a completion table which prints trace messages.\15\nIf CAPF is an anonymous lambda, pass the Capf NAME explicitly for\15\nmeaningful debugging output.\15\n\15\n(fn CAPF &optional NAME)") (autoload 'cape-wrap-buster "cape" "\15\nCall CAPF and return a completion table with cache busting.\15\nThis function can be used as an advice around an existing Capf.\15\nThe cache is busted when the input changes.  The argument VALID\15\ncan be a function taking the old and new input string.  It should\15\nreturn nil if the new input requires that the completion table is\15\nrefreshed.  The default value for VALID is `equal', such that the\15\ncompletion table is refreshed on every input change.\15\n\15\n(fn CAPF &optional VALID)") (autoload 'cape-wrap-passthrough "cape" "\15\nCall CAPF and make sure that no completion style filtering takes place.\15\n\15\n(fn CAPF)") (autoload 'cape-wrap-properties "cape" "\15\nCall CAPF and strip or add completion PROPERTIES.\15\nCompletion properties include for example :exclusive, :category,\15\n:annotation-function, :display-sort-function and various :company-*\15\nextensions.  The :strip flag means to strip all completion properties.\15\n\15\n(fn CAPF &rest PROPERTIES)") (autoload 'cape-wrap-nonexclusive "cape" "\15\nCall CAPF and ensure that it is marked as non-exclusive.\15\nThis function can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF)") (autoload 'cape-wrap-sort "cape" "\15\nCall CAPF and add SORT function.\15\nThis function can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF SORT)") (autoload 'cape-wrap-predicate "cape" "\15\nCall CAPF and add an additional candidate PREDICATE.\15\nThe PREDICATE is passed the candidate symbol or string.\15\n\15\n(fn CAPF PREDICATE)") (autoload 'cape-wrap-silent "cape" "\15\nCall CAPF and silence it (no messages, no errors).\15\nThis function can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF)") (autoload 'cape-wrap-case-fold "cape" "\15\nCall CAPF and return a case-insensitive completion table.\15\nIf NOFOLD is non-nil return a case sensitive table instead.  This\15\nfunction can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF &optional NOFOLD)") (autoload 'cape-wrap-noninterruptible "cape" "\15\nCall CAPF and return a non-interruptible completion table.\15\nThis function can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF)") (autoload 'cape-wrap-prefix-length "cape" "\15\nCall CAPF and ensure that prefix length is greater or equal than LENGTH.\15\nIf the prefix is long enough, enforce auto completion.\15\n\15\n(fn CAPF LENGTH)") (autoload 'cape-wrap-inside-faces "cape" "\15\nCall CAPF only if inside FACES.\15\nThis function can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF &rest FACES)") (autoload 'cape-wrap-inside-code "cape" "\15\nCall CAPF only if inside code, not inside a comment or string.\15\nThis function can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF)") (autoload 'cape-wrap-inside-comment "cape" "\15\nCall CAPF only if inside comment.\15\nThis function can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF)") (autoload 'cape-wrap-inside-string "cape" "\15\nCall CAPF only if inside string.\15\nThis function can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF)") (autoload 'cape-wrap-purify "cape" "\15\nCall CAPF and ensure that it does not illegally modify the buffer.\15\nThis function can be used as an advice around an existing\15\nCapf.  It has been introduced mainly to fix the broken\15\n`pcomplete-completions-at-point' function in Emacs versions < 29.\15\n\15\n(fn CAPF)") (autoload 'cape-wrap-accept-all "cape" "\15\nCall CAPF and return a completion table which accepts every input.\15\nThis function can be used as an advice around an existing Capf.\15\n\15\n(fn CAPF)") (autoload 'cape-capf-accept-all "cape") (autoload 'cape-capf-buster "cape") (autoload 'cape-capf-case-fold "cape") (autoload 'cape-capf-debug "cape") (autoload 'cape-capf-inside-code "cape") (autoload 'cape-capf-inside-comment "cape") (autoload 'cape-capf-inside-faces "cape") (autoload 'cape-capf-inside-string "cape") (autoload 'cape-capf-nonexclusive "cape") (autoload 'cape-capf-noninterruptible "cape") (autoload 'cape-capf-passthrough "cape") (autoload 'cape-capf-predicate "cape") (autoload 'cape-capf-prefix-length "cape") (autoload 'cape-capf-properties "cape") (autoload 'cape-capf-purify "cape") (autoload 'cape-capf-silent "cape") (autoload 'cape-capf-super "cape") (autoload 'cape-prefix-map "cape" nil t 'keymap) (autoload 'cape-tex "cape-char" nil t) (autoload 'cape-sgml "cape-char" nil t) (autoload 'cape-rfc1345 "cape-char" nil t) (when (> emacs-major-version 28) (autoload 'cape-emoji "cape-char" nil t)) (autoload 'cape-keyword "cape-keyword" "\15\nComplete programming language keyword at point.\15\nSee the variable `cape-keyword-list'.\15\nIf INTERACTIVE is nil the function acts like a capf.\15\n\15\n(fn &optional INTERACTIVE)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/corfu/corfu-autoloads.el") (load-true-file-name load-file-name)) (autoload 'corfu-mode "corfu" "\15\nCOmpletion in Region FUnction.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Corfu mode'\15\nmode.  If the prefix argument is positive, enable the mode, and if it is\15\nzero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `corfu-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-corfu-mode 'globalized-minor-mode t) (defvar global-corfu-mode nil "\15\nNon-nil if Global Corfu mode is enabled.\15\nSee the `global-corfu-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-corfu-mode'.") (autoload 'global-corfu-mode "corfu" "\15\nToggle Corfu mode in all buffers.\15\nWith prefix ARG, enable Global Corfu mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nCorfu mode is enabled in all buffers where `corfu--on' would do it.\15\n\15\nSee `corfu-mode' for more information on Corfu mode.\15\n\15\n(fn &optional ARG)" t) (defvar corfu-echo-mode nil "\15\nNon-nil if Corfu-Echo mode is enabled.\15\nSee the `corfu-echo-mode' command\15\nfor a description of this minor mode.") (autoload 'corfu-echo-mode "corfu-echo" "\15\nShow candidate documentation in echo area.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Corfu-Echo mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='corfu-echo-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (defvar corfu-history-mode nil "\15\nNon-nil if Corfu-History mode is enabled.\15\nSee the `corfu-history-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `corfu-history-mode'.") (autoload 'corfu-history-mode "corfu-history" "\15\nUpdate Corfu history and sort completions by history.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Corfu-History mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='corfu-history-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (defvar corfu-indexed-mode nil "\15\nNon-nil if Corfu-Indexed mode is enabled.\15\nSee the `corfu-indexed-mode' command\15\nfor a description of this minor mode.") (autoload 'corfu-indexed-mode "corfu-indexed" "\15\nPrefix candidates with indices.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Corfu-Indexed mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='corfu-indexed-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'corfu-info-documentation "corfu-info" "\15\nShow documentation of current candidate.\15\nIf called with a prefix ARG, the buffer is persistent.\15\n\15\n(fn &optional ARG)" t) (autoload 'corfu-info-location "corfu-info" "\15\nShow location of current candidate.\15\nIf called with a prefix ARG, the buffer is persistent.\15\n\15\n(fn &optional ARG)" t) (defvar corfu-popupinfo-mode nil "\15\nNon-nil if Corfu-Popupinfo mode is enabled.\15\nSee the `corfu-popupinfo-mode' command\15\nfor a description of this minor mode.") (autoload 'corfu-popupinfo-mode "corfu-popupinfo" "\15\nCorfu info popup minor mode.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Corfu-Popupinfo mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='corfu-popupinfo-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'corfu-quick-jump "corfu-quick" "\15\nJump to candidate using quick keys." t) (autoload 'corfu-quick-insert "corfu-quick" "\15\nInsert candidate using quick keys." t) (autoload 'corfu-quick-complete "corfu-quick" "\15\nComplete candidate using quick keys." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/which-key/which-key-autoloads.el") (load-true-file-name load-file-name)) (defvar which-key-mode nil "\15\nNon-nil if Which-Key mode is enabled.\15\nSee the `which-key-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `which-key-mode'.") (autoload 'which-key-mode "which-key" "\15\nToggle `which-key-mode'.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the\15\n`Which-Key mode' mode.  If the prefix argument is positive, enable the\15\nmode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='which-key-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'which-key-setup-side-window-right "which-key" "\15\nSet up side-window on right." t) (autoload 'which-key-setup-side-window-right-bottom "which-key" "\15\nSet up side-window on right if space allows.\15\nOtherwise, use bottom." t) (autoload 'which-key-setup-side-window-bottom "which-key" "\15\nSet up side-window that opens on bottom." t) (autoload 'which-key-setup-minibuffer "which-key" "\15\nSet up minibuffer display.\15\nDo not use this setup if you use the paging commands.  Instead use\15\n`which-key-setup-side-window-bottom', which is nearly identical\15\nbut more functional." t) (autoload 'which-key-add-keymap-based-replacements "which-key" "\15\nReplace the description of KEY using REPLACEMENT in KEYMAP.\15\nKEY should take a format suitable for use in `kbd'.  REPLACEMENT\15\nshould be a cons cell of the form (STRING . COMMAND) for each\15\nREPLACEMENT, where STRING is the replacement string and COMMAND\15\nis a symbol corresponding to the intended command to be\15\nreplaced.  COMMAND can be nil if the binding corresponds to a key\15\nprefix.  An example is\15\n\15\n(which-key-add-keymap-based-replacements global-map\15\n  \"C-x w\" \\='(\"Save as\" . write-file)).\15\n\15\nFor backwards compatibility, REPLACEMENT can also be a string,\15\nbut the above format is preferred, and the option to use a string\15\nfor REPLACEMENT will eventually be removed.\15\n\15\n(fn KEYMAP KEY REPLACEMENT &rest MORE)") (function-put 'which-key-add-keymap-based-replacements 'lisp-indent-function 'defun) (autoload 'which-key-add-key-based-replacements "which-key" "\15\nReplace the description of KEY-SEQUENCE with REPLACEMENT.\15\nKEY-SEQUENCE is a string suitable for use in `kbd'.\15\nREPLACEMENT may either be a string, as in\15\n\15\n(which-key-add-key-based-replacements \"C-x 1\" \"maximize\")\15\n\15\na cons of two strings as in\15\n\15\n(which-key-add-key-based-replacements \"C-x 8\"\15\n                                        \\='(\"unicode\" . \"Unicode keys\"))\15\n\15\nor a function that takes a (KEY . BINDING) cons and returns a\15\nreplacement.\15\n\15\nIn the second case, the second string is used to provide a longer\15\nname for the keys under a prefix.\15\n\15\nMORE allows you to specifcy additional KEY REPLACEMENT pairs.  All\15\nreplacements are added to `which-key-replacement-alist'.\15\n\15\n(fn KEY-SEQUENCE REPLACEMENT &rest MORE)") (autoload 'which-key-add-major-mode-key-based-replacements "which-key" "\15\nFunctions like `which-key-add-key-based-replacements'.\15\nThe difference is that MODE specifies the `major-mode' that must\15\nbe active for KEY-SEQUENCE and REPLACEMENT (MORE contains\15\naddition KEY-SEQUENCE REPLACEMENT pairs) to apply.\15\n\15\n(fn MODE KEY-SEQUENCE REPLACEMENT &rest MORE)") (function-put 'which-key-add-major-mode-key-based-replacements 'lisp-indent-function 'defun) (autoload 'which-key-reload-key-sequence "which-key" "\15\nSimulate entering the key sequence KEY-SEQ.\15\nKEY-SEQ should be a list of events as produced by\15\n`listify-key-sequence'.  If nil, KEY-SEQ defaults to\15\n`which-key--current-key-list'.  Any prefix arguments that were\15\nused are reapplied to the new key sequence.\15\n\15\n(fn &optional KEY-SEQ)") (autoload 'which-key-show-standard-help "which-key" "\15\nCall the command in `which-key--prefix-help-cmd-backup'.\15\nUsually this is `describe-prefix-bindings'.\15\n\15\n(fn &optional _)" t) (autoload 'which-key-show-next-page-no-cycle "which-key" "\15\nShow next page of keys or `which-key-show-standard-help'." t) (autoload 'which-key-show-previous-page-no-cycle "which-key" "\15\nShow previous page of keys if one exists." t) (autoload 'which-key-show-next-page-cycle "which-key" "\15\nShow the next page of keys, cycling from end to beginning.\15\n\15\n(fn &optional _)" t) (autoload 'which-key-show-previous-page-cycle "which-key" "\15\nShow the previous page of keys, cycling from beginning to end.\15\n\15\n(fn &optional _)" t) (autoload 'which-key-show-top-level "which-key" "\15\nShow top-level bindings.\15\n\15\n(fn &optional _)" t) (autoload 'which-key-show-major-mode "which-key" "\15\nShow top-level bindings in the map of the current major mode.\15\nThis function will also detect evil bindings made using\15\n`evil-define-key' in this map.  These bindings will depend on the\15\ncurrent evil state.\15\n\15\n(fn &optional ALL)" t) (autoload 'which-key-show-full-major-mode "which-key" "\15\nShow all bindings in the map of the current major mode.\15\nThis function will also detect evil bindings made using\15\n`evil-define-key' in this map.  These bindings will depend on the\15\ncurrent evil state." t) (autoload 'which-key-dump-bindings "which-key" "\15\nDump bindings from PREFIX into buffer named BUFFER-NAME.\15\nPREFIX should be a string suitable for `kbd'.\15\n\15\n(fn PREFIX BUFFER-NAME)" t) (autoload 'which-key-undo-key "which-key" "\15\nUndo last keypress and force which-key update.\15\n\15\n(fn &optional _)" t) (autoload 'which-key-C-h-dispatch "which-key" "\15\nDispatch \\`C-h' commands by looking up key in `which-key-C-h-map'.\15\nThis command is always accessible (from any prefix) if\15\n`which-key-use-C-h-commands' is non nil." t) (autoload 'which-key-show-keymap "which-key" "\15\nShow the top-level bindings in KEYMAP using which-key.\15\nKEYMAP is selected interactively from all available keymaps.\15\n\15\nIf NO-PAGING is non-nil, which-key will not intercept subsequent\15\nkeypresses for the paging functionality.\15\n\15\n(fn KEYMAP &optional NO-PAGING)" t) (autoload 'which-key-show-full-keymap "which-key" "\15\nShow all bindings in KEYMAP using which-key.\15\nKEYMAP is selected interactively from all available keymaps.\15\n\15\n(fn KEYMAP)" t) (autoload 'which-key-show-minor-mode-keymap "which-key" "\15\nShow the top-level bindings in KEYMAP using which-key.\15\nKEYMAP is selected interactively by mode in\15\n`minor-mode-map-alist'.\15\n\15\n(fn &optional ALL)" t) (autoload 'which-key-show-full-minor-mode-keymap "which-key" "\15\nShow all bindings in KEYMAP using which-key.\15\nKEYMAP is selected interactively by mode in\15\n`minor-mode-map-alist'." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/general/general-autoloads.el") (load-true-file-name load-file-name)) (autoload 'general-define-key "general" "\15\nThe primary key definition function provided by general.el.\15\n\15\nDefine MAPS, optionally using DEFINER, in the keymap(s) corresponding to STATES\15\nand KEYMAPS.\15\n\15\nMAPS consists of paired keys (vectors or strings; also see\15\n`general-implicit-kbd') and definitions (those mentioned in `define-key''s\15\ndocstring and general.el's \"extended\" definitions). All pairs (when not\15\nignored) will be recorded and can be later displayed with\15\n`general-describe-keybindings'.\15\n\15\nIf DEFINER is specified, a custom key definer will be used to bind MAPS. See\15\ngeneral.el's documentation/README for more information.\15\n\15\nUnlike with normal key definitions functions, the keymaps in KEYMAPS should be\15\nquoted (this allows using the keymap name for other purposes, e.g. deferring\15\nkeybindings if the keymap symbol is not bound, optionally inferring the\15\ncorresponding major mode for a symbol by removing \"-map\" for :which-key,\15\neasily storing the keymap name for use with `general-describe-keybindings',\15\netc.). Note that general.el provides other key definer macros that do not\15\nrequire quoting keymaps.\15\n\15\nSTATES corresponds to the evil state(s) to bind the keys in. Non-evil users\15\nshould not set STATES. When STATES is non-nil, `evil-define-key*' will be\15\nused (the evil auxiliary keymaps corresponding STATES and KEYMAPS will be used);\15\notherwise `define-key' will be used (unless DEFINER is specified). KEYMAPS\15\ndefaults to 'global. There is also 'local, which create buffer-local\15\nkeybindings for both evil and non-evil keybindings. There are other special,\15\nuser-alterable \"shorthand\" symbols for keymaps and states (see\15\n`general-keymap-aliases' and `general-state-aliases').\15\n\15\nNote that STATES and KEYMAPS can either be lists or single symbols. If any\15\nkeymap does not exist, those keybindings will be deferred until the keymap does\15\nexist, so using `eval-after-load' is not necessary with this function.\15\n\15\nPREFIX corresponds to a key to prefix keys in MAPS with and defaults to none. To\15\nbind/unbind a key specified with PREFIX, \"\" can be specified as a key in\15\nMAPS (e.g. ...:prefix \"SPC\" \"\" nil... will unbind space).\15\n\15\nThe keywords in this paragraph are only useful for evil users. If\15\nNON-NORMAL-PREFIX is specified, this prefix will be used instead of PREFIX for\15\nstates in `general-non-normal-states' (e.g. the emacs and insert states). This\15\nargument will only have an effect if one of these states is in STATES or if\15\ncorresponding global keymap (e.g. `evil-insert-state-map') is in KEYMAPS.\15\nAlternatively, GLOBAL-PREFIX can be used with PREFIX and/or NON-NORMAL-PREFIX to\15\nbind keys in all states under the specified prefix. Like with NON-NORMAL-PREFIX,\15\nGLOBAL-PREFIX will prevent PREFIX from applying to `general-non-normal-states'.\15\nINFIX can be used to append a string to all of the specified prefixes. This is\15\npotentially useful when you are using GLOBAL-PREFIX and/or NON-NORMAL-PREFIX so\15\nthat you can sandwich keys in between all the prefixes and the specified keys in\15\nMAPS. This may be particularly useful if you are using default prefixes in a\15\nwrapper function/macro so that you can add to them without needing to re-specify\15\nall of them. If none of the other prefix keyword arguments are specified, INFIX\15\nwill have no effect.\15\n\15\nIf PREFIX-COMMAND or PREFIX-MAP is specified, a prefix command and/or keymap\15\nwill be created. PREFIX-NAME can be additionally specified to set the keymap\15\nmenu name/prompt. If PREFIX-COMMAND is specified, `define-prefix-command' will\15\nbe used. Otherwise, only a prefix keymap will be created. Previously created\15\nprefix commands/keymaps will never be redefined/cleared. All prefixes (including\15\nthe INFIX key, if specified) will then be bound to PREFIX-COMMAND or PREFIX-MAP.\15\nIf the user did not specify any PREFIX or manually specify any KEYMAPS, general\15\nwill bind all MAPS in the prefix keymap corresponding to either PREFIX-MAP or\15\nPREFIX-COMMAND instead of in the default keymap.\15\n\15\nPREDICATE corresponds to a predicate to check to determine whether a definition\15\nshould be active (e.g. \":predicate '(eobp)\"). Definitions created with a\15\npredicate will only be active when the predicate is true. When the predicate is\15\nfalse, key lookup will continue to search for a match in lower-precedence\15\nkeymaps.\15\n\15\nIn addition to the normal definitions supported by `define-key', general.el also\15\nprovides \"extended\" definitions, which are plists containing the normal\15\ndefinition as well as other keywords. For example, PREDICATE can be specified\15\nglobally or locally in an extended definition. New global (~general-define-key~)\15\nand local (extended definition) keywords can be added by the user. See\15\n`general-extended-def-keywords' and general.el's documentation/README for more\15\ninformation.\15\n\15\nPACKAGE is the global version of the extended definition keyword that specifies\15\nthe package a keymap is defined in (used for \"autoloading\" keymaps)\15\n\15\nPROPERTIES, REPEAT, and JUMP are the global versions of the extended definition\15\nkeywords used for adding evil command properties to commands.\15\n\15\nMAJOR-MODES, WK-MATCH-KEYS, WK-MATCH-BINDINGS, and WK-FULL-KEYS are the\15\ncorresponding global versions of which-key extended definition keywords. They\15\nwill only have an effect for extended definitions that specify :which-key or\15\n:wk. See the section on extended definitions in the general.el\15\ndocumentation/README for more information.\15\n\15\nLISPY-PLIST and WORF-PLIST are the global versions of extended definition\15\nkeywords that are used for each corresponding custom DEFINER.\15\n\15\n(fn &rest MAPS &key DEFINER (STATES general-default-states) (KEYMAPS general-default-keymaps KEYMAPS-SPECIFIED-P) (PREFIX general-default-prefix) (NON-NORMAL-PREFIX general-default-non-normal-prefix) (GLOBAL-PREFIX general-default-global-prefix) INFIX PREFIX-COMMAND PREFIX-MAP PREFIX-NAME PREDICATE PACKAGE PROPERTIES REPEAT JUMP MAJOR-MODES (WK-MATCH-KEYS t) (WK-MATCH-BINDING t) (WK-FULL-KEYS t) LISPY-PLIST WORF-PLIST &allow-other-keys)") (autoload 'general-emacs-define-key "general" "\15\nA wrapper for `general-define-key' that is similar to `define-key'.\15\nIt has a positional argument for KEYMAPS (that will not be overridden by a later\15\n:keymaps argument). Besides this, it acts the same as `general-define-key', and\15\nARGS can contain keyword arguments in addition to keybindings. This can\15\nbasically act as a drop-in replacement for `define-key', and unlike with\15\n`general-define-key', KEYMAPS does not need to be quoted.\15\n\15\n(fn KEYMAPS &rest ARGS)" nil t) (function-put 'general-emacs-define-key 'lisp-indent-function 1) (autoload 'general-evil-define-key "general" "\15\nA wrapper for `general-define-key' that is similar to `evil-define-key'.\15\nIt has positional arguments for STATES and KEYMAPS (that will not be overridden\15\nby a later :keymaps or :states argument). Besides this, it acts the same as\15\n`general-define-key', and ARGS can contain keyword arguments in addition to\15\nkeybindings. This can basically act as a drop-in replacement for\15\n`evil-define-key', and unlike with `general-define-key', KEYMAPS does not need\15\nto be quoted.\15\n\15\n(fn STATES KEYMAPS &rest ARGS)" nil t) (function-put 'general-evil-define-key 'lisp-indent-function 2) (autoload 'general-def "general" "\15\nGeneral definer that takes a variable number of positional arguments in ARGS.\15\nThis macro will act as `general-define-key', `general-emacs-define-key', or\15\n`general-evil-define-key' based on how many of the initial arguments do not\15\ncorrespond to keybindings. All quoted and non-quoted lists and symbols before\15\nthe first string, vector, or keyword are considered to be positional arguments.\15\nThis means that you cannot use a function or variable for a key that starts\15\nimmediately after the positional arguments. If you need to do this, you should\15\nuse one of the definers that `general-def' dispatches to or explicitly separate\15\nthe positional arguments from the maps with a bogus keyword pair like\15\n\":start-maps t\"\15\n\15\n(fn &rest ARGS)" nil t) (function-put 'general-def 'lisp-indent-function 'defun) (autoload 'general-create-definer "general" "\15\nA helper macro to create wrappers for `general-def'.\15\nThis can be used to create key definers that will use a certain keymap, evil\15\nstate, prefix key, etc. by default. NAME is the wrapper name and DEFAULTS are\15\nthe default arguments. WRAPPING can also be optionally specified to use a\15\ndifferent definer than `general-def'. It should not be quoted.\15\n\15\n(fn NAME &rest DEFAULTS &key WRAPPING &allow-other-keys)" nil t) (function-put 'general-create-definer 'lisp-indent-function 'defun) (autoload 'general-defs "general" "\15\nA wrapper that splits into multiple `general-def's.\15\nEach consecutive grouping of positional argument followed by keyword/argument\15\npairs (having only one or the other is fine) marks the start of a new section.\15\nEach section corresponds to one use of `general-def'. This means that settings\15\nonly apply to the keybindings that directly follow.\15\n\15\nSince positional arguments can appear at any point, unqouted symbols are always\15\nconsidered to be positional arguments (e.g. a keymap). This means that variables\15\ncan never be used for keys with `general-defs'. Variables can still be used for\15\ndefinitions or as arguments to keywords.\15\n\15\n(fn &rest ARGS)" nil t) (function-put 'general-defs 'lisp-indent-function 'defun) (autoload 'general-unbind "general" "\15\nA wrapper for `general-def' to unbind multiple keys simultaneously.\15\nInsert after all keys in ARGS before passing ARGS to `general-def.' \":with\15\n #'func\" can optionally specified to use a custom function instead (e.g.\15\n `ignore').\15\n\15\n(fn &rest ARGS)" nil t) (function-put 'general-unbind 'lisp-indent-function 'defun) (autoload 'general-describe-keybindings "general" "\15\nShow all keys that have been bound with general in an org buffer.\15\nAny local keybindings will be shown first followed by global keybindings.\15\nWith a non-nil prefix ARG only show bindings in active maps.\15\n\15\n(fn &optional ARG)" t) (autoload 'general-key "general" "\15\nAct as KEY's definition in the current context.\15\nThis uses an extended menu item's capability of dynamically computing a\15\ndefinition. It is recommended over `general-simulate-key' wherever possible. See\15\nthe docstring of `general-simulate-key' and the readme for information about the\15\nbenefits and downsides of `general-key'.\15\n\15\nKEY should be a string given in `kbd' notation and should correspond to a single\15\ndefinition (as opposed to a sequence of commands). When STATE is specified, look\15\nup KEY with STATE as the current evil state. When specified, DOCSTRING will be\15\nthe menu item's name/description.\15\n\15\nLet can be used to bind variables around key lookup. For example:\15\n(general-key \"some key\"\15\n  :let ((some-var some-val)))\15\n\15\nSETUP and TEARDOWN can be used to run certain functions before and after key\15\nlookup. For example, something similar to using :state 'emacs would be:\15\n(general-key \"some key\"\15\n  :setup (evil-local-mode -1)\15\n  :teardown (evil-local-mode))\15\n\15\nACCEPT-DEFAULT, NO-REMAP, and POSITION are passed to `key-binding'.\15\n\15\n(fn KEY &key STATE DOCSTRING LET SETUP TEARDOWN ACCEPT-DEFAULT NO-REMAP POSITION)" nil t) (function-put 'general-key 'lisp-indent-function 1) (autoload 'general-simulate-keys "general" "\15\nDeprecated. Please use `general-simulate-key' instead.\15\n\15\n(fn KEYS &optional STATE KEYMAP (LOOKUP t) DOCSTRING NAME)" nil t) (autoload 'general-simulate-key "general" "\15\nCreate and return a command that simulates KEYS in STATE and KEYMAP.\15\n\15\n`general-key' should be prefered over this whenever possible as it is simpler\15\nand has saner functionality in many cases because it does not rely on\15\n`unread-command-events' (e.g. \"C-h k\" will show the docstring of the command\15\nto be simulated ; see the readme for more information). The main downsides of\15\n`general-key' are that it cannot simulate a command followed by keys or\15\nsubsequent commands, and which-key does not currently work well with it when\15\nsimulating a prefix key/incomplete key sequence.\15\n\15\nKEYS should be a string given in `kbd' notation. It can also be a list of a\15\nsingle command followed by a string of the key(s) to simulate after calling that\15\ncommand. STATE should only be specified by evil users and should be a quoted\15\nevil state. KEYMAP should not be quoted. Both STATE and KEYMAP aliases are\15\nsupported (but they have to be set when the macro is expanded). When neither\15\nSTATE or KEYMAP are specified, the key(s) will be simulated in the current\15\ncontext.\15\n\15\nIf NAME is specified, it will replace the automatically generated function name.\15\nNAME should not be quoted. If DOCSTRING is specified, it will replace the\15\nautomatically generated docstring.\15\n\15\nNormally the generated function will look up KEY in the correct context to try\15\nto match a command. To prevent this lookup, LOOKUP can be specified as nil.\15\nGenerally, you will want to keep LOOKUP non-nil because this will allow checking\15\nthe evil repeat property of matched commands to determine whether or not they\15\nshould be recorded. See the docstring for `general--simulate-keys' for more\15\ninformation about LOOKUP.\15\n\15\nWhen a WHICH-KEY description is specified, it will replace the command name in\15\nthe which-key popup.\15\n\15\nWhen a command name is specified and that command has been remapped (i.e. [remap\15\ncommand] is currently bound), the remapped version will be used instead of the\15\noriginal command unless REMAP is specified as nil (it is true by default).\15\n\15\nThe advantages of this over a keyboard macro are as follows:\15\n- Prefix arguments are supported\15\n- The user can control the context in which the keys are simulated\15\n- The user can simulate both a named command and keys\15\n- The user can simulate an incomplete key sequence (e.g. for a keymap)\15\n\15\n(fn KEYS &key STATE KEYMAP NAME DOCSTRING (LOOKUP t) WHICH-KEY (REMAP t))" nil t) (function-put 'general-simulate-key 'lisp-indent-function 'defun) (autoload 'general-key-dispatch "general" "\15\nCreate and return a command that runs FALLBACK-COMMAND or a command in MAPS.\15\nMAPS consists of <key> <command> pairs. If a key in MAPS is matched, the\15\ncorresponding command will be run. Otherwise FALLBACK-COMMAND will be run with\15\nthe unmatched keys. So, for example, if \"ab\" was pressed, and \"ab\" is not\15\none of the key sequences from MAPS, the FALLBACK-COMMAND will be run followed by\15\nthe simulated keypresses of \"ab\". Prefix arguments will still work regardless\15\nof which command is run. This is useful for binding under non-prefix keys. For\15\nexample, this can be used to redefine a sequence like \"cw\" or \"cow\" in evil\15\nbut still have \"c\" work as `evil-change'. If TIMEOUT is specified,\15\nFALLBACK-COMMAND will also be run in the case that the user does not press the\15\nnext key within the TIMEOUT (e.g. 0.5).\15\n\15\nNAME and DOCSTRING are optional keyword arguments. They can be used to replace\15\nthe automatically generated name and docstring for the created function. By\15\ndefault, `cl-gensym' is used to prevent name clashes (e.g. allows the user to\15\ncreate multiple different commands using `self-insert-command' as the\15\nFALLBACK-COMMAND without explicitly specifying NAME to manually prevent\15\nclashes).\15\n\15\nWhen INHERIT-KEYMAP is specified, all the keybindings from that keymap will be\15\ninherited in MAPS.\15\n\15\nWhen a WHICH-KEY description is specified, it will replace the command name in\15\nthe which-key popup.\15\n\15\nWhen command to be executed has been remapped (i.e. [remap command] is currently\15\nbound), the remapped version will be used instead of the original command unless\15\nREMAP is specified as nil (it is true by default).\15\n\15\n(fn FALLBACK-COMMAND &rest MAPS &key TIMEOUT INHERIT-KEYMAP NAME DOCSTRING WHICH-KEY (REMAP t) &allow-other-keys)" nil t) (function-put 'general-key-dispatch 'lisp-indent-function 1) (autoload 'general-predicate-dispatch "general" "\15\n\15\n\15\n(fn FALLBACK-DEF &rest DEFS &key DOCSTRING &allow-other-keys)" nil t) (function-put 'general-predicate-dispatch 'lisp-indent-function 1) (autoload 'general-translate-key "general" "\15\nTranslate keys in the keymap(s) corresponding to STATES and KEYMAPS.\15\nSTATES should be the name of an evil state, a list of states, or nil. KEYMAPS\15\nshould be a symbol corresponding to the keymap to make the translations in or a\15\nlist of keymap names. Keymap and state aliases are supported (as well as 'local\15\nand 'global for KEYMAPS).\15\n\15\nMAPS corresponds to a list of translations (key replacement pairs). For example,\15\nspecifying \"a\" \"b\" will bind \"a\" to \"b\"'s definition in the keymap.\15\nSpecifying nil as a replacement will unbind a key.\15\n\15\nIf DESTRUCTIVE is non-nil, the keymap will be destructively altered without\15\ncreating a backup. If DESTRUCTIVE is nil, store a backup of the keymap on the\15\ninitial invocation, and for future invocations always look up keys in the\15\noriginal/backup keymap. On the other hand, if DESTRUCTIVE is non-nil, calling\15\nthis function multiple times with \"a\" \"b\" \"b\" \"a\", for example, would\15\ncontinue to swap and unswap the definitions of these keys. This means that when\15\nDESTRUCTIVE is non-nil, all related swaps/cycles should be done in the same\15\ninvocation.\15\n\15\nIf both MAPS and DESCTRUCTIVE are nil, only create the backup keymap.\15\n\15\n(fn STATES KEYMAPS &rest MAPS &key DESTRUCTIVE &allow-other-keys)") (function-put 'general-translate-key 'lisp-indent-function 'defun) (autoload 'general-swap-key "general" "\15\nWrapper around `general-translate-key' for swapping keys.\15\nSTATES, KEYMAPS, and ARGS are passed to `general-translate-key'. ARGS should\15\nconsist of key swaps (e.g. \"a\" \"b\" is equivalent to \"a\" \"b\" \"b\" \"a\"\15\nwith `general-translate-key') and optionally keyword arguments for\15\n`general-translate-key'.\15\n\15\n(fn STATES KEYMAPS &rest ARGS)" nil t) (function-put 'general-swap-key 'lisp-indent-function 'defun) (autoload 'general-auto-unbind-keys "general" "\15\nAdvise `define-key' to automatically unbind keys when necessary.\15\nThis will prevent errors when a sub-sequence of a key is already bound (e.g. the\15\nuser attempts to bind \"SPC a\" when \"SPC\" is bound, resulting in a \"Key\15\nsequnce starts with non-prefix key\" error). When UNDO is non-nil, remove\15\nadvice.\15\n\15\n(fn &optional UNDO)") (autoload 'general-add-hook "general" "\15\nA drop-in replacement for `add-hook'.\15\nUnlike `add-hook', HOOKS and FUNCTIONS can be single items or lists. APPEND and\15\nLOCAL are passed directly to `add-hook'. When TRANSIENT is non-nil, each\15\nfunction will remove itself from the hook it is in after it is run once. If\15\nTRANSIENT is a function, call it on the return value in order to determine\15\nwhether to remove a function from the hook. For example, if TRANSIENT is\15\n#'identity, remove each function only if it returns non-nil. TRANSIENT could\15\nalternatively check something external and ignore the function's return value.\15\n\15\n(fn HOOKS FUNCTIONS &optional APPEND LOCAL TRANSIENT)") (autoload 'general-remove-hook "general" "\15\nA drop-in replacement for `remove-hook'.\15\nUnlike `remove-hook', HOOKS and FUNCTIONS can be single items or lists. LOCAL is\15\npassed directly to `remove-hook'.\15\n\15\n(fn HOOKS FUNCTIONS &optional LOCAL)") (autoload 'general-advice-add "general" "\15\nA drop-in replacement for `advice-add'.\15\nSYMBOLS, WHERE, FUNCTIONS, and PROPS correspond to the arguments for\15\n`advice-add'. Unlike `advice-add', SYMBOLS and FUNCTIONS can be single items or\15\nlists. When TRANSIENT is non-nil, each function will remove itself as advice\15\nafter it is run once. If TRANSIENT is a function, call it on the return value in\15\norder to determine whether to remove a function as advice. For example, if\15\nTRANSIENT is #'identity, remove each function only if it returns non-nil.\15\nTRANSIENT could alternatively check something external and ignore the function's\15\nreturn value.\15\n\15\n(fn SYMBOLS WHERE FUNCTIONS &optional PROPS TRANSIENT)") (autoload 'general-add-advice "general") (autoload 'general-advice-remove "general" "\15\nA drop-in replacement for `advice-remove'.\15\nUnlike `advice-remove', SYMBOLS and FUNCTIONS can be single items or lists.\15\n\15\n(fn SYMBOLS FUNCTIONS)") (autoload 'general-remove-advice "general") (autoload 'general-evil-setup "general" "\15\nSet up some basic equivalents for vim mapping functions.\15\nThis creates global key definition functions for the evil states.\15\nSpecifying SHORT-NAMES as non-nil will create non-prefixed function\15\naliases such as `nmap' for `general-nmap'.\15\n\15\n(fn &optional SHORT-NAMES _)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/xref/xref-autoloads.el") (load-true-file-name load-file-name)) (autoload 'xref-find-backend "xref") (define-obsolete-function-alias 'xref-pop-marker-stack #'xref-go-back "29.1") (autoload 'xref-go-back "xref" "\15\nGo back to the previous position in xref history.\15\nTo undo, use \\[xref-go-forward]." t) (autoload 'xref-go-forward "xref" "\15\nGo to the point where a previous \\[xref-go-back] was invoked." t) (autoload 'xref-marker-stack-empty-p "xref" "\15\nWhether the xref back-history is empty.") (autoload 'xref-forward-history-empty-p "xref" "\15\nWhether the xref forward-history is empty.") (autoload 'xref-show-xrefs "xref" "\15\nDisplay some Xref values produced by FETCHER using DISPLAY-ACTION.\15\nThe meanings of both arguments are the same as documented in\15\n`xref-show-xrefs-function'.\15\n\15\n(fn FETCHER DISPLAY-ACTION)") (autoload 'xref-find-definitions "xref" "\15\nFind the definition of the identifier at point.\15\nWith prefix argument or when there's no identifier at point,\15\nprompt for it.\15\n\15\nIf sufficient information is available to determine a unique\15\ndefinition for IDENTIFIER, display it in the selected window.\15\nOtherwise, display the list of the possible definitions in a\15\nbuffer where the user can select from the list.\15\n\15\nUse \\[xref-go-back] to return back to where you invoked this command.\15\n\15\n(fn IDENTIFIER)" t) (autoload 'xref-find-definitions-other-window "xref" "\15\nLike `xref-find-definitions' but switch to the other window.\15\n\15\n(fn IDENTIFIER)" t) (autoload 'xref-find-definitions-other-frame "xref" "\15\nLike `xref-find-definitions' but switch to the other frame.\15\n\15\n(fn IDENTIFIER)" t) (autoload 'xref-find-references "xref" "\15\nFind references to the identifier at point.\15\nThis command might prompt for the identifier as needed, perhaps\15\noffering the symbol at point as the default.\15\nWith prefix argument, or if `xref-prompt-for-identifier' is t,\15\nalways prompt for the identifier.  If `xref-prompt-for-identifier'\15\nis nil, prompt only if there's no usable symbol at point.\15\n\15\n(fn IDENTIFIER)" t) (autoload 'xref-find-definitions-at-mouse "xref" "\15\nFind the definition of identifier at or around mouse click.\15\nThis command is intended to be bound to a mouse event.\15\n\15\n(fn EVENT)" t) (autoload 'xref-find-references-at-mouse "xref" "\15\nFind references to the identifier at or around mouse click.\15\nThis command is intended to be bound to a mouse event.\15\n\15\n(fn EVENT)" t) (autoload 'xref-find-apropos "xref" "\15\nFind all meaningful symbols that match PATTERN.\15\nThe argument has the same meaning as in `apropos'.\15\nSee `tags-apropos-additional-actions' for how to augment the\15\noutput of this command when the backend is etags.\15\n\15\n(fn PATTERN)" t) (define-key esc-map "." #'xref-find-definitions) (define-key esc-map "," #'xref-go-back) (define-key esc-map [67108908] #'xref-go-forward) (define-key esc-map "?" #'xref-find-references) (define-key esc-map [67108910] #'xref-find-apropos) (define-key ctl-x-4-map "." #'xref-find-definitions-other-window) (define-key ctl-x-5-map "." #'xref-find-definitions-other-frame) (autoload 'xref-references-in-directory "xref" "\15\nFind all references to SYMBOL in directory DIR.\15\nReturn a list of xref values.\15\n\15\nThis function uses the Semantic Symbol Reference API, see\15\n`semantic-symref-tool-alist' for details on which tools are used,\15\nand when.\15\n\15\n(fn SYMBOL DIR)") (autoload 'xref-matches-in-directory "xref" "\15\nFind all matches for REGEXP in directory DIR.\15\nReturn a list of xref values.\15\nOnly files matching some of FILES and none of IGNORES are searched.\15\nFILES is a string with glob patterns separated by spaces.\15\nIGNORES is a list of glob patterns for files to ignore.\15\n\15\n(fn REGEXP FILES DIR IGNORES)") (autoload 'xref-matches-in-files "xref" "\15\nFind all matches for REGEXP in FILES.\15\nReturn a list of xref values.\15\nFILES must be a list of absolute file names.\15\n\15\nSee `xref-search-program' and `xref-search-program-alist' for how\15\nto control which program to use when looking for matches.\15\n\15\n(fn REGEXP FILES)") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/project/project-autoloads.el") (load-true-file-name load-file-name)) (autoload 'project-current "project" "\15\nReturn the project instance in DIRECTORY, defaulting to `default-directory'.\15\n\15\nWhen no project is found in that directory, the result depends on\15\nthe value of MAYBE-PROMPT: if it is nil or omitted, return nil,\15\nelse prompt the user for the project to use.  To prompt for a\15\nproject, call the function specified by `project-prompter', which\15\nreturns the directory in which to look for the project.  If no\15\nproject is found in that directory, return a \"transient\"\15\nproject instance.  When MAYBE-PROMPT is a string, it's passed to the\15\nprompter function as an argument.\15\n\15\nThe \"transient\" project instance is a special kind of value\15\nwhich denotes a project rooted in that directory and includes all\15\nthe files under the directory except for those that match entries\15\nin `vc-directory-exclusion-list' or `grep-find-ignored-files'.\15\n\15\nSee the doc string of `project-find-functions' for the general form\15\nof the project instance object.\15\n\15\n(fn &optional MAYBE-PROMPT DIRECTORY)") (put 'project-vc-ignores 'safe-local-variable (lambda (val) (and (listp val) (not (memq nil (mapcar #'stringp val)))))) (put 'project-vc-merge-submodules 'safe-local-variable #'booleanp) (put 'project-vc-include-untracked 'safe-local-variable #'booleanp) (put 'project-vc-name 'safe-local-variable #'stringp) (put 'project-vc-extra-root-markers 'safe-local-variable (lambda (val) (and (listp val) (not (memq nil (mapcar #'stringp val)))))) (defvar project-prefix-map (let ((map (make-sparse-keymap))) (define-key map "!" 'project-shell-command) (define-key map "&" 'project-async-shell-command) (define-key map "f" 'project-find-file) (define-key map "F" 'project-or-external-find-file) (define-key map "b" 'project-switch-to-buffer) (define-key map "s" 'project-shell) (define-key map "d" 'project-find-dir) (define-key map "D" 'project-dired) (define-key map "v" 'project-vc-dir) (define-key map "c" 'project-compile) (define-key map "e" 'project-eshell) (define-key map "k" 'project-kill-buffers) (define-key map "p" 'project-switch-project) (define-key map "g" 'project-find-regexp) (define-key map "G" 'project-or-external-find-regexp) (define-key map "r" 'project-query-replace-regexp) (define-key map "x" 'project-execute-extended-command) (define-key map "o" 'project-any-command) (define-key map "\2" 'project-list-buffers) (define-key map "\30s" 'project-save-some-buffers) map) "\15\nKeymap for project commands.") (define-key ctl-x-map "p" project-prefix-map) (autoload 'project-other-window-command "project" "\15\nRun project command, displaying resultant buffer in another window.\15\n\15\nThe following commands are available:\15\n\15\n\\{project-prefix-map}\15\n\\{project-other-window-map}" t) (define-key ctl-x-4-map "p" #'project-other-window-command) (autoload 'project-other-frame-command "project" "\15\nRun project command, displaying resultant buffer in another frame.\15\n\15\nThe following commands are available:\15\n\15\n\\{project-prefix-map}\15\n\\{project-other-frame-map}" t) (define-key ctl-x-5-map "p" #'project-other-frame-command) (autoload 'project-other-tab-command "project" "\15\nRun project command, displaying resultant buffer in a new tab.\15\n\15\nThe following commands are available:\15\n\15\n\\{project-prefix-map}" t) (when (bound-and-true-p tab-prefix-map) (define-key tab-prefix-map "p" #'project-other-tab-command)) (autoload 'project-find-regexp "project" "\15\nFind all matches for REGEXP in the current project's roots.\15\nWith \\[universal-argument] prefix, you can specify the directory\15\nto search in, and the file name pattern to search for.  The\15\npattern may use abbreviations defined in `grep-files-aliases',\15\ne.g. entering `ch' is equivalent to `*.[ch]'.  As whitespace\15\ntriggers completion when entering a pattern, including it\15\nrequires quoting, e.g. `\\[quoted-insert]<space>'.\15\n\15\n(fn REGEXP)" t) (autoload 'project-or-external-find-regexp "project" "\15\nFind all matches for REGEXP in the project roots or external roots.\15\n\15\n(fn REGEXP)" t) (autoload 'project-root-find-file "project" "\15\nEdit file FILENAME.\15\n\15\nInteractively, prompt for FILENAME, defaulting to the root directory of\15\nthe current project.\15\n\15\n(fn FILENAME)" t) (function-put 'project-root-find-file 'interactive-only 'find-file) (autoload 'project-find-file "project" "\15\nVisit a file (with completion) in the current project.\15\n\15\nThe filename at point (determined by `thing-at-point'), if any,\15\nis available as part of \"future history\".  If none, the current\15\nbuffer's file name is used.\15\n\15\nIf INCLUDE-ALL is non-nil, or with prefix argument when called\15\ninteractively, include all files under the project root, except\15\nfor VCS directories listed in `vc-directory-exclusion-list'.\15\n\15\n(fn &optional INCLUDE-ALL)" t) (autoload 'project-or-external-find-file "project" "\15\nVisit a file (with completion) in the current project or external roots.\15\n\15\nThe filename at point (determined by `thing-at-point'), if any,\15\nis available as part of \"future history\".  If none, the current\15\nbuffer's file name is used.\15\n\15\nIf INCLUDE-ALL is non-nil, or with prefix argument when called\15\ninteractively, include all files under the project root, except\15\nfor VCS directories listed in `vc-directory-exclusion-list'.\15\n\15\n(fn &optional INCLUDE-ALL)" t) (autoload 'project-find-matching-file "project" "\15\nVisit the file that matches the current one, in another project.\15\nIt will skip to the same line number as well.\15\nA matching file has the same file name relative to the project root.\15\nWhen called during switching to another project, this command will\15\ndetect it and use the override.  Otherwise, it prompts for the project\15\nto use from the known list." t) (autoload 'project-find-dir "project" "\15\nStart Dired in a directory inside the current project.\15\n\15\nThe current buffer's `default-directory' is available as part of\15\n\"future history\"." t) (autoload 'project-dired "project" "\15\nStart Dired in the current project's root." t) (autoload 'project-vc-dir "project" "\15\nRun VC-Dir in the current project's root." t) (autoload 'project-customize-dirlocals "project" "\15\nRun `customize-dirlocals' in current project's root." t) (autoload 'project-shell "project" "\15\nStart an inferior shell in the current project's root directory.\15\nIf a buffer already exists for running a shell in the project's root,\15\nswitch to it.  Otherwise, create a new shell buffer.\15\nWith \\[universal-argument] prefix arg, create a new inferior shell buffer even\15\nif one already exists." t) (autoload 'project-eshell "project" "\15\nStart Eshell in the current project's root directory.\15\nIf a buffer already exists for running Eshell in the project's root,\15\nswitch to it.  Otherwise, create a new Eshell buffer.\15\nWith \\[universal-argument] prefix arg, create a new Eshell buffer even\15\nif one already exists." t) (autoload 'project-async-shell-command "project" "\15\nRun `async-shell-command' in the current project's root directory." t) (function-put 'project-async-shell-command 'interactive-only 'async-shell-command) (autoload 'project-shell-command "project" "\15\nRun `shell-command' in the current project's root directory." t) (function-put 'project-shell-command 'interactive-only 'shell-command) (autoload 'project-search "project" "\15\nSearch for REGEXP in all the files of the project.\15\nStops when a match is found.\15\nTo continue searching for the next match, use the\15\ncommand \\[fileloop-continue].\15\n\15\n(fn REGEXP)" t) (autoload 'project-query-replace-regexp "project" "\15\nQuery-replace REGEXP in all the files of the project.\15\nStops when a match is found and prompts for whether to replace it.\15\nAt that prompt, the user must type a character saying what to do\15\nwith the match.  Type SPC or `y' to replace the match,\15\nDEL or `n' to skip and go to the next match.  For more directions,\15\ntype \\[help-command] at that time.\15\nIf you exit the `query-replace', you can later continue the\15\n`query-replace' loop using the command \\[fileloop-continue].\15\n\15\n(fn FROM TO)" t) (autoload 'project-compile "project" "\15\nRun `compile' in the project root." t) (function-put 'project-compile 'interactive-only 'compile) (autoload 'project-recompile "project" "\15\nRun `recompile' in the project root with an appropriate buffer.\15\n\15\n(fn &optional EDIT-COMMAND)" t) (function-put 'project-recompile 'interactive-only 'recompile) (autoload 'project-switch-to-buffer "project" "\15\nDisplay buffer BUFFER-OR-NAME in the selected window.\15\nWhen called interactively, prompts for a buffer belonging to the\15\ncurrent project.  Two buffers belong to the same project if their\15\nproject instances, as reported by `project-current' in each\15\nbuffer, are identical.\15\n\15\n(fn BUFFER-OR-NAME)" t) (autoload 'project-display-buffer "project" "\15\nDisplay BUFFER-OR-NAME in some window, without selecting it.\15\nWhen called interactively, prompts for a buffer belonging to the\15\ncurrent project.  Two buffers belong to the same project if their\15\nproject instances, as reported by `project-current' in each\15\nbuffer, are identical.\15\n\15\nThis function uses `display-buffer' as a subroutine, which see\15\nfor how it is determined where the buffer will be displayed.\15\n\15\n(fn BUFFER-OR-NAME)" t) (autoload 'project-display-buffer-other-frame "project" "\15\nDisplay BUFFER-OR-NAME preferably in another frame.\15\nWhen called interactively, prompts for a buffer belonging to the\15\ncurrent project.  Two buffers belong to the same project if their\15\nproject instances, as reported by `project-current' in each\15\nbuffer, are identical.\15\n\15\nThis function uses `display-buffer-other-frame' as a subroutine,\15\nwhich see for how it is determined where the buffer will be\15\ndisplayed.\15\n\15\n(fn BUFFER-OR-NAME)" t) (autoload 'project-list-buffers "project" "\15\nDisplay a list of project buffers.\15\nThe list is displayed in a buffer named \"*Buffer List*\".\15\n\15\nBy default, all project buffers are listed except those whose names\15\nstart with a space (which are for internal use).  With prefix argument\15\nARG, show only buffers that are visiting files.\15\n\15\n(fn &optional ARG)" t) (put 'project-kill-buffers-display-buffer-list 'safe-local-variable #'booleanp) (autoload 'project-kill-buffers "project" "\15\nKill the buffers belonging to the current project.\15\nTwo buffers belong to the same project if their project\15\ninstances, as reported by `project-current' in each buffer, are\15\nidentical.  Only the buffers that match a condition in\15\n`project-kill-buffer-conditions' will be killed.  If NO-CONFIRM\15\nis non-nil, the command will not ask the user for confirmation.\15\nNO-CONFIRM is always nil when the command is invoked\15\ninteractively.\15\n\15\nIf PROJECT is non-nil, kill buffers for that project instead.\15\n\15\nAlso see the `project-kill-buffers-display-buffer-list' variable.\15\n\15\n(fn &optional NO-CONFIRM PROJECT)" t) (autoload 'project-save-some-buffers "project" "\15\nLike `save-some-buffers', but only for this project's buffers.\15\n\15\n(fn ARG)" t) (autoload 'project-remember-project "project" "\15\nAdd project PR to the front of the project list.\15\nIf project PR satisfies `project-list-exclude', then nothing is done.\15\nSave the result in `project-list-file' if the list of projects\15\nhas changed, and NO-WRITE is nil.\15\n\15\n(fn PR &optional NO-WRITE)" t) (autoload 'project-forget-project "project" "\15\nRemove directory PROJECT-ROOT from the project list.\15\nPROJECT-ROOT is the root directory of a known project listed in\15\nthe project list.\15\n\15\n(fn PROJECT-ROOT)" t) (autoload 'project-known-project-roots "project" "\15\nReturn the list of root directories of all known projects.") (autoload 'project-execute-extended-command "project" "\15\nExecute an extended command in project root." t) (function-put 'project-execute-extended-command 'interactive-only 'command-execute) (autoload 'project-any-command "project" "\15\nRun the next command in the current project.\15\n\15\nIf the command name starts with `project-', or its symbol has\15\nproperty `project-aware', it gets passed the project to use\15\nwith the variable `project-current-directory-override'.\15\nOtherwise, `default-directory' is temporarily set to the current\15\nproject's root.\15\n\15\nIf OVERRIDING-MAP is non-nil, it will be used as\15\n`overriding-terminal-local-map' to provide shorter bindings\15\nfrom that map which will take priority over the global ones.\15\n\15\n(fn &optional OVERRIDING-MAP PROMPT-FORMAT)" t) (autoload 'project-prefix-or-any-command "project" "\15\nRun the next command in the current project.\15\nWorks like `project-any-command', but also mixes in the shorter\15\nbindings from `project-prefix-map'." t) (autoload 'project-switch-project "project" "\15\n\"Switch\" to another project by running an Emacs command.\15\nThe available commands are presented as a dispatch menu\15\nmade from `project-switch-commands'.\15\n\15\nWhen called in a program, it will use the project corresponding\15\nto directory DIR.\15\n\15\n(fn DIR)" t) (autoload 'project-uniquify-dirname-transform "project" "\15\nUniquify name of directory DIRNAME using `project-name', if in a project.\15\n\15\nIf you set `uniquify-dirname-transform' to this function,\15\nslash-separated components from `project-name' will be appended to\15\nthe buffer's directory name when buffers from two different projects\15\nwould otherwise have the same name.\15\n\15\n(fn DIRNAME)") (defvar project-mode-line nil "\15\nWhether to show current project name and Project menu on the mode line.\15\nThis feature requires the presence of the following item in\15\n`mode-line-format': `(project-mode-line project-mode-line-format)'; it\15\nis part of the default mode line beginning with Emacs 30.") nil nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/projectile/projectile-autoloads.el") (load-true-file-name load-file-name)) (autoload 'projectile-version "projectile" "\15\nGet the Projectile version as string.\15\n\15\nIf called interactively or if SHOW-VERSION is non-nil, show the\15\nversion in the echo area and the messages buffer.\15\n\15\nThe returned string includes both, the version from package.el\15\nand the library version, if both a present and different.\15\n\15\nIf the version number could not be determined, signal an error,\15\nif called interactively, or if SHOW-VERSION is non-nil, otherwise\15\njust return nil.\15\n\15\n(fn &optional SHOW-VERSION)" t) (autoload 'projectile-invalidate-cache "projectile" "\15\nRemove the current project's files from `projectile-projects-cache'.\15\n\15\nWith a prefix argument PROMPT prompts for the name of the project whose cache\15\nto invalidate.\15\n\15\nThe global (project-independent) cache for checking which project a file\15\nbelongs to, is also cleared. Therefore this function is still useful even\15\nwhen not operating on a specific project, and as such only the global cache\15\nis cleared when there is no current project (unless you give a prefix\15\nargument).\15\n\15\n(fn PROMPT)" t) (autoload 'projectile-purge-file-from-cache "projectile" "\15\nPurge FILE from the cache of the current project.\15\n\15\n(fn FILE)" t) (autoload 'projectile-purge-dir-from-cache "projectile" "\15\nPurge DIR from the cache of the current project.\15\n\15\n(fn DIR)" t) (autoload 'projectile-cache-current-file "projectile" "\15\nAdd the currently visited file to the cache." t) (autoload 'projectile-discover-projects-in-directory "projectile" "\15\nDiscover any projects in DIRECTORY and add them to the projectile cache.\15\n\15\nIf DEPTH is non-nil recursively descend exactly DEPTH levels below DIRECTORY and\15\ndiscover projects there.\15\n\15\n(fn DIRECTORY &optional DEPTH)" t) (autoload 'projectile-discover-projects-in-search-path "projectile" "\15\nDiscover projects in `projectile-project-search-path'.\15\nInvoked automatically when `projectile-mode' is enabled." t) (autoload 'projectile-switch-to-buffer "projectile" "\15\nSwitch to a project buffer." t) (autoload 'projectile-switch-to-buffer-other-window "projectile" "\15\nSwitch to a project buffer and show it in another window." t) (autoload 'projectile-switch-to-buffer-other-frame "projectile" "\15\nSwitch to a project buffer and show it in another frame." t) (autoload 'projectile-display-buffer "projectile" "\15\nDisplay a project buffer in another window without selecting it." t) (autoload 'projectile-project-buffers-other-buffer "projectile" "\15\nSwitch to the most recently selected buffer project buffer.\15\nOnly buffers not visible in windows are returned." t) (autoload 'projectile-multi-occur "projectile" "\15\nDo a `multi-occur' in the project's buffers.\15\nWith a prefix argument, show NLINES of context.\15\n\15\n(fn &optional NLINES)" t) (autoload 'projectile-find-other-file "projectile" "\15\nSwitch between files with the same name but different extensions.\15\nWith FLEX-MATCHING, match any file that contains the base name of current file.\15\nOther file extensions can be customized with the variable\15\n`projectile-other-file-alist'.\15\n\15\n(fn &optional FLEX-MATCHING)" t) (autoload 'projectile-find-other-file-other-window "projectile" "\15\nSwitch between files with different extensions in other window.\15\nSwitch between files with the same name but different extensions in other\15\nwindow.  With FLEX-MATCHING, match any file that contains the base name of\15\ncurrent file.  Other file extensions can be customized with the variable\15\n`projectile-other-file-alist'.\15\n\15\n(fn &optional FLEX-MATCHING)" t) (autoload 'projectile-find-other-file-other-frame "projectile" "\15\nSwitch between files with different extensions in other frame.\15\nSwitch between files with the same name but different extensions in other frame.\15\nWith FLEX-MATCHING, match any file that contains the base name of current\15\nfile.  Other file extensions can be customized with the variable\15\n`projectile-other-file-alist'.\15\n\15\n(fn &optional FLEX-MATCHING)" t) (autoload 'projectile-find-file-dwim "projectile" "\15\nJump to a project's files using completion based on context.\15\n\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\nIf point is on a filename, Projectile first tries to search for that\15\nfile in project:\15\n\15\n- If it finds just a file, it switches to that file instantly.  This works\15\neven if the filename is incomplete, but there's only a single file in the\15\ncurrent project that matches the filename at point.  For example, if\15\nthere's only a single file named \"projectile/projectile.el\" but the\15\ncurrent filename is \"projectile/proj\" (incomplete),\15\n`projectile-find-file-dwim' still switches to \"projectile/projectile.el\"\15\nimmediately because this is the only filename that matches.\15\n\15\n- If it finds a list of files, the list is displayed for selecting.  A list\15\nof files is displayed when a filename appears more than one in the project\15\nor the filename at point is a prefix of more than two files in a project.\15\nFor example, if `projectile-find-file-dwim' is executed on a filepath like\15\n\"projectile/\", it lists the content of that directory.  If it is executed\15\non a partial filename like \"projectile/a\", a list of files with character\15\n\"a\" in that directory is presented.\15\n\15\n- If it finds nothing, display a list of all files in project for selecting.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-find-file-dwim-other-window "projectile" "\15\nJump to a project's files using completion based on context in other window.\15\n\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\nIf point is on a filename, Projectile first tries to search for that\15\nfile in project:\15\n\15\n- If it finds just a file, it switches to that file instantly.  This works\15\neven if the filename is incomplete, but there's only a single file in the\15\ncurrent project that matches the filename at point.  For example, if\15\nthere's only a single file named \"projectile/projectile.el\" but the\15\ncurrent filename is \"projectile/proj\" (incomplete),\15\n`projectile-find-file-dwim-other-window' still switches to\15\n\"projectile/projectile.el\" immediately because this is the only filename\15\nthat matches.\15\n\15\n- If it finds a list of files, the list is displayed for selecting.  A list\15\nof files is displayed when a filename appears more than one in the project\15\nor the filename at point is a prefix of more than two files in a project.\15\nFor example, if `projectile-find-file-dwim-other-window' is executed on a\15\nfilepath like \"projectile/\", it lists the content of that directory.  If\15\nit is executed on a partial filename like \"projectile/a\", a list of files\15\nwith character \"a\" in that directory is presented.\15\n\15\n- If it finds nothing, display a list of all files in project for selecting.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-find-file-dwim-other-frame "projectile" "\15\nJump to a project's files using completion based on context in other frame.\15\n\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\nIf point is on a filename, Projectile first tries to search for that\15\nfile in project:\15\n\15\n- If it finds just a file, it switches to that file instantly.  This works\15\neven if the filename is incomplete, but there's only a single file in the\15\ncurrent project that matches the filename at point.  For example, if\15\nthere's only a single file named \"projectile/projectile.el\" but the\15\ncurrent filename is \"projectile/proj\" (incomplete),\15\n`projectile-find-file-dwim-other-frame' still switches to\15\n\"projectile/projectile.el\" immediately because this is the only filename\15\nthat matches.\15\n\15\n- If it finds a list of files, the list is displayed for selecting.  A list\15\nof files is displayed when a filename appears more than one in the project\15\nor the filename at point is a prefix of more than two files in a project.\15\nFor example, if `projectile-find-file-dwim-other-frame' is executed on a\15\nfilepath like \"projectile/\", it lists the content of that directory.  If\15\nit is executed on a partial filename like \"projectile/a\", a list of files\15\nwith character \"a\" in that directory is presented.\15\n\15\n- If it finds nothing, display a list of all files in project for selecting.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-find-file "projectile" "\15\nJump to a project's file using completion.\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-find-file-other-window "projectile" "\15\nJump to a project's file using completion and show it in another window.\15\n\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-find-file-other-frame "projectile" "\15\nJump to a project's file using completion and show it in another frame.\15\n\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-toggle-project-read-only "projectile" "\15\nToggle project read only." t) (autoload 'projectile-add-dir-local-variable "projectile" "\15\nRun `add-dir-local-variable' with .dir-locals.el in root of project.\15\n\15\nParameters MODE VARIABLE VALUE are passed directly to `add-dir-local-variable'.\15\n\15\n(fn MODE VARIABLE VALUE)") (autoload 'projectile-delete-dir-local-variable "projectile" "\15\nRun `delete-dir-local-variable' with .dir-locals.el in root of project.\15\n\15\nParameters MODE VARIABLE VALUE are passed directly to\15\n`delete-dir-local-variable'.\15\n\15\n(fn MODE VARIABLE)") (autoload 'projectile-find-dir "projectile" "\15\nJump to a project's directory using completion.\15\n\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-find-dir-other-window "projectile" "\15\nJump to a project's directory in other window using completion.\15\n\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-find-dir-other-frame "projectile" "\15\nJump to a project's directory in other frame using completion.\15\n\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-find-test-file "projectile" "\15\nJump to a project's test file using completion.\15\n\15\nWith a prefix arg INVALIDATE-CACHE invalidates the cache first.\15\n\15\n(fn &optional INVALIDATE-CACHE)" t) (autoload 'projectile-find-related-file-other-window "projectile" "\15\nOpen related file in other window." t) (autoload 'projectile-find-related-file-other-frame "projectile" "\15\nOpen related file in other frame." t) (autoload 'projectile-find-related-file "projectile" "\15\nOpen related file." t) (autoload 'projectile-related-files-fn-groups "projectile" "\15\nGenerate a related-files-fn which relates as KIND for files in each of GROUPS.\15\n\15\n(fn KIND GROUPS)") (autoload 'projectile-related-files-fn-extensions "projectile" "\15\nGenerate a related-files-fn which relates as KIND for files having EXTENSIONS.\15\n\15\n(fn KIND EXTENSIONS)") (autoload 'projectile-related-files-fn-test-with-prefix "projectile" "\15\nGenerate a related-files-fn which relates tests and impl.\15\nUse files with EXTENSION based on TEST-PREFIX.\15\n\15\n(fn EXTENSION TEST-PREFIX)") (autoload 'projectile-related-files-fn-test-with-suffix "projectile" "\15\nGenerate a related-files-fn which relates tests and impl.\15\nUse files with EXTENSION based on TEST-SUFFIX.\15\n\15\n(fn EXTENSION TEST-SUFFIX)") (autoload 'projectile-project-info "projectile" "\15\nDisplay info for current project." t) (autoload 'projectile-find-implementation-or-test-other-window "projectile" "\15\nOpen matching implementation or test file in other window.\15\n\15\nSee the documentation of `projectile--find-matching-file' and\15\n`projectile--find-matching-test' for how implementation and test files\15\nare determined." t) (autoload 'projectile-find-implementation-or-test-other-frame "projectile" "\15\nOpen matching implementation or test file in other frame.\15\n\15\nSee the documentation of `projectile--find-matching-file' and\15\n`projectile--find-matching-test' for how implementation and test files\15\nare determined." t) (autoload 'projectile-toggle-between-implementation-and-test "projectile" "\15\nToggle between an implementation file and its test file.\15\n\15\n\15\nSee the documentation of `projectile--find-matching-file' and\15\n`projectile--find-matching-test' for how implementation and test files\15\nare determined." t) (autoload 'projectile-grep "projectile" "\15\nPerform rgrep in the project.\15\n\15\nWith a prefix ARG asks for files (globbing-aware) which to grep in.\15\nWith prefix ARG of `-' (such as `M--'), default the files (without prompt),\15\nto `projectile-grep-default-files'.\15\n\15\nWith REGEXP given, don't query the user for a regexp.\15\n\15\n(fn &optional REGEXP ARG)" t) (autoload 'projectile-ag "projectile" "\15\nRun an ag search with SEARCH-TERM in the project.\15\n\15\nWith an optional prefix argument ARG SEARCH-TERM is interpreted as a\15\nregular expression.\15\n\15\n(fn SEARCH-TERM &optional ARG)" t) (autoload 'projectile-ripgrep "projectile" "\15\nRun a ripgrep (rg) search with `SEARCH-TERM' at current project root.\15\n\15\nWith an optional prefix argument ARG SEARCH-TERM is interpreted as a\15\nregular expression.\15\n\15\nThis command depends on of the Emacs packages ripgrep or rg being\15\ninstalled to work.\15\n\15\n(fn SEARCH-TERM &optional ARG)" t) (autoload 'projectile-regenerate-tags "projectile" "\15\nRegenerate the project's [e|g]tags." t) (autoload 'projectile-find-tag "projectile" "\15\nFind tag in project." t) (autoload 'projectile-run-command-in-root "projectile" "\15\nInvoke `execute-extended-command' in the project's root." t) (autoload 'projectile-run-shell-command-in-root "projectile" "\15\nInvoke `shell-command' in the project's root.\15\n\15\n(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER)" t) (autoload 'projectile-run-async-shell-command-in-root "projectile" "\15\nInvoke `async-shell-command' in the project's root.\15\n\15\n(fn COMMAND &optional OUTPUT-BUFFER ERROR-BUFFER)" t) (autoload 'projectile-run-gdb "projectile" "\15\nInvoke `gdb' in the project's root." t) (autoload 'projectile-run-shell "projectile" "\15\nInvoke `shell' in the project's root.\15\n\15\nSwitch to the project specific shell buffer if it already exists.\15\n\15\nUse a prefix argument ARG to indicate creation of a new process instead.\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-run-eshell "projectile" "\15\nInvoke `eshell' in the project's root.\15\n\15\nSwitch to the project specific eshell buffer if it already exists.\15\n\15\nUse a prefix argument ARG to indicate creation of a new process instead.\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-run-ielm "projectile" "\15\nInvoke `ielm' in the project's root.\15\n\15\nSwitch to the project specific ielm buffer if it already exists.\15\n\15\nUse a prefix argument ARG to indicate creation of a new process instead.\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-run-term "projectile" "\15\nInvoke `term' in the project's root.\15\n\15\nSwitch to the project specific term buffer if it already exists.\15\n\15\nUse a prefix argument ARG to indicate creation of a new process instead.\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-run-vterm "projectile" "\15\nInvoke `vterm' in the project's root.\15\n\15\nSwitch to the project specific term buffer if it already exists.\15\n\15\nUse a prefix argument ARG to indicate creation of a new process instead.\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-run-vterm-other-window "projectile" "\15\nInvoke `vterm' in the project's root.\15\n\15\nSwitch to the project specific term buffer if it already exists.\15\n\15\nUse a prefix argument ARG to indicate creation of a new process instead.\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-replace "projectile" "\15\nReplace literal string in project using non-regexp `tags-query-replace'.\15\n\15\nWith a prefix argument ARG prompts you for a directory and file name patterns\15\non which to run the replacement.\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-replace-regexp "projectile" "\15\nReplace a regexp in the project using `tags-query-replace'.\15\n\15\nWith a prefix argument ARG prompts you for a directory on which\15\nto run the replacement.\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-kill-buffers "projectile" "\15\nKill project buffers.\15\n\15\nThe buffer are killed according to the value of\15\n`projectile-kill-buffers-filter'." t) (autoload 'projectile-save-project-buffers "projectile" "\15\nSave all project buffers." t) (autoload 'projectile-dired "projectile" "\15\nOpen `dired' at the root of the project." t) (autoload 'projectile-dired-other-window "projectile" "\15\nOpen `dired'  at the root of the project in another window." t) (autoload 'projectile-dired-other-frame "projectile" "\15\nOpen `dired' at the root of the project in another frame." t) (autoload 'projectile-vc "projectile" "\15\nOpen `vc-dir' at the root of the project.\15\n\15\nFor git projects `magit-status-internal' is used if available.\15\nFor hg projects `monky-status' is used if available.\15\n\15\nIf PROJECT-ROOT is given, it is opened instead of the project\15\nroot directory of the current buffer file.  If interactively\15\ncalled with a prefix argument, the user is prompted for a project\15\ndirectory to open.\15\n\15\n(fn &optional PROJECT-ROOT)" t) (autoload 'projectile-recentf "projectile" "\15\nShow a list of recently visited files in a project." t) (autoload 'projectile-configure-project "projectile" "\15\nRun project configure command.\15\n\15\nNormally you'll be prompted for a compilation command, unless\15\nvariable `compilation-read-command'.  You can force the prompt\15\nwith a prefix ARG.\15\n\15\n(fn ARG)" t) (autoload 'projectile-compile-project "projectile" "\15\nRun project compilation command.\15\n\15\nNormally you'll be prompted for a compilation command, unless\15\nvariable `compilation-read-command'.  You can force the prompt\15\nwith a prefix ARG.  Per project default command can be set through\15\n`projectile-project-compilation-cmd'.\15\n\15\n(fn ARG)" t) (autoload 'projectile-test-project "projectile" "\15\nRun project test command.\15\n\15\nNormally you'll be prompted for a compilation command, unless\15\nvariable `compilation-read-command'.  You can force the prompt\15\nwith a prefix ARG.\15\n\15\n(fn ARG)" t) (autoload 'projectile-install-project "projectile" "\15\nRun project install command.\15\n\15\nNormally you'll be prompted for a compilation command, unless\15\nvariable `compilation-read-command'.  You can force the prompt\15\nwith a prefix ARG.\15\n\15\n(fn ARG)" t) (autoload 'projectile-package-project "projectile" "\15\nRun project package command.\15\n\15\nNormally you'll be prompted for a compilation command, unless\15\nvariable `compilation-read-command'.  You can force the prompt\15\nwith a prefix ARG.\15\n\15\n(fn ARG)" t) (autoload 'projectile-run-project "projectile" "\15\nRun project run command.\15\n\15\nNormally you'll be prompted for a compilation command, unless\15\nvariable `compilation-read-command'.  You can force the prompt\15\nwith a prefix ARG.\15\n\15\n(fn ARG)" t) (autoload 'projectile-repeat-last-command "projectile" "\15\nRun last projectile external command.\15\n\15\nExternal commands are: `projectile-configure-project',\15\n`projectile-compile-project', `projectile-test-project',\15\n`projectile-install-project', `projectile-package-project',\15\nand `projectile-run-project'.\15\n\15\nIf the prefix argument SHOW-PROMPT is non nil, the command can be edited.\15\n\15\n(fn SHOW-PROMPT)" t) (autoload 'projectile-switch-project "projectile" "\15\nSwitch to a project we have visited before.\15\nInvokes the command referenced by `projectile-switch-project-action' on switch.\15\nWith a prefix ARG invokes `projectile-commander' instead of\15\n`projectile-switch-project-action.'\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-switch-open-project "projectile" "\15\nSwitch to a project we have currently opened.\15\nInvokes the command referenced by `projectile-switch-project-action' on switch.\15\nWith a prefix ARG invokes `projectile-commander' instead of\15\n`projectile-switch-project-action.'\15\n\15\n(fn &optional ARG)" t) (autoload 'projectile-find-file-in-directory "projectile" "\15\nJump to a file in a (maybe regular) DIRECTORY.\15\n\15\nThis command will first prompt for the directory the file is in.\15\n\15\n(fn &optional DIRECTORY)" t) (autoload 'projectile-find-file-in-known-projects "projectile" "\15\nJump to a file in any of the known projects." t) (autoload 'projectile-cleanup-known-projects "projectile" "\15\nRemove known projects that don't exist anymore." t) (autoload 'projectile-clear-known-projects "projectile" "\15\nClear both `projectile-known-projects' and `projectile-known-projects-file'." t) (autoload 'projectile-reset-known-projects "projectile" "\15\nClear known projects and rediscover." t) (autoload 'projectile-remove-known-project "projectile" "\15\nRemove PROJECT from the list of known projects.\15\n\15\n(fn &optional PROJECT)" t) (autoload 'projectile-remove-current-project-from-known-projects "projectile" "\15\nRemove the current project from the list of known projects." t) (autoload 'projectile-add-known-project "projectile" "\15\nAdd PROJECT-ROOT to the list of known projects.\15\n\15\n(fn PROJECT-ROOT)" t) (autoload 'projectile-ibuffer "projectile" "\15\nOpen an IBuffer window showing all buffers in the current project.\15\n\15\nLet user choose another project when PROMPT-FOR-PROJECT is supplied.\15\n\15\n(fn PROMPT-FOR-PROJECT)" t) (autoload 'projectile-commander "projectile" "\15\nExecute a Projectile command with a single letter.\15\nThe user is prompted for a single character indicating the action to invoke.\15\nThe `?' character describes then\15\navailable actions.\15\n\15\nSee `def-projectile-commander-method' for defining new methods." t) (autoload 'projectile-browse-dirty-projects "projectile" "\15\nBrowse dirty version controlled projects.\15\n\15\nWith a prefix argument, or if CACHED is non-nil, try to use the cached\15\ndirty project list.\15\n\15\n(fn &optional CACHED)" t) (autoload 'projectile-edit-dir-locals "projectile" "\15\nEdit or create a .dir-locals.el file of the project." t) (autoload 'project-projectile "projectile" "\15\nReturn Projectile project of form ('projectile . root-dir) for DIR.\15\n\15\n(fn DIR)") (defvar projectile-mode nil "\15\nNon-nil if Projectile mode is enabled.\15\nSee the `projectile-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `projectile-mode'.") (autoload 'projectile-mode "projectile" "\15\nMinor mode to assist project management and navigation.\15\n\15\nWhen called interactively, toggle `projectile-mode'.  With prefix\15\nARG, enable `projectile-mode' if ARG is positive, otherwise disable\15\nit.\15\n\15\nWhen called from Lisp, enable `projectile-mode' if ARG is omitted,\15\nnil or positive.  If ARG is `toggle', toggle `projectile-mode'.\15\nOtherwise behave as if called interactively.\15\n\15\n\\{projectile-mode-map}\15\n\15\n(fn &optional ARG)" t) (define-obsolete-function-alias 'projectile-global-mode 'projectile-mode "1.0") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/ws-butler/ws-butler-autoloads.el") (load-true-file-name load-file-name)) (autoload 'ws-butler-mode "ws-butler" "\15\nWhitespace cleanup without obtrusive whitespace removal.\15\n\15\nWhitespaces at end-of-line and end-of-buffer are trimmed upon save, but\15\nonly for lines modified by you.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Ws-Butler\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `ws-butler-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'ws-butler-global-mode 'globalized-minor-mode t) (defvar ws-butler-global-mode nil "\15\nNon-nil if Ws-Butler-Global mode is enabled.\15\nSee the `ws-butler-global-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `ws-butler-global-mode'.") (autoload 'ws-butler-global-mode "ws-butler" "\15\nToggle Ws-Butler mode in all buffers.\15\nWith prefix ARG, enable Ws-Butler-Global mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nWs-Butler mode is enabled in all buffers where\15\n`ws-butler--global-mode-turn-on' would do it.\15\n\15\nSee `ws-butler-mode' for more information on Ws-Butler mode.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/smartparens/smartparens-autoloads.el") (load-true-file-name load-file-name)) (autoload 'sp-cheat-sheet "smartparens" "\15\nGenerate a cheat sheet of all the smartparens interactive functions.\15\n\15\nWithout a prefix argument, print only the short documentation and examples.\15\n\15\nWith non-nil prefix argument ARG, show the full documentation for each function.\15\n\15\nYou can follow the links to the function or variable help page.\15\nTo get back to the full list, use \\[help-go-back].\15\n\15\nYou can use `beginning-of-defun' and `end-of-defun' to jump to\15\nthe previous/next entry.\15\n\15\nExamples are fontified using the `font-lock-string-face' for\15\nbetter orientation.\15\n\15\n(fn &optional ARG)" t) (defvar smartparens-mode-map (make-sparse-keymap) "\15\nKeymap used for `smartparens-mode'.") (autoload 'sp-use-paredit-bindings "smartparens" "\15\nInitiate `smartparens-mode-map' with `sp-paredit-bindings'." t) (autoload 'sp-use-smartparens-bindings "smartparens" "\15\nInitiate `smartparens-mode-map' with `sp-smartparens-bindings'." t) (autoload 'smartparens-mode "smartparens" "\15\nToggle smartparens mode.\15\n\15\nYou can enable pre-set bindings by customizing\15\n`sp-base-key-bindings' variable.  The current content of\15\n`smartparens-mode-map' is:\15\n\15\n \\{smartparens-mode-map}\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Smartparens\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `smartparens-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'smartparens-strict-mode "smartparens" "\15\nToggle the strict smartparens mode.\15\n\15\nWhen strict mode is active, `delete-char', `kill-word' and their\15\nbackward variants will skip over the pair delimiters in order to\15\nkeep the structure always valid (the same way as `paredit-mode'\15\ndoes).  This is accomplished by remapping them to\15\n`sp-delete-char' and `sp-kill-word'.  There is also function\15\n`sp-kill-symbol' that deletes symbols instead of words, otherwise\15\nworking exactly the same (it is not bound to any key by default).\15\n\15\nWhen strict mode is active, this is indicated with \"/s\"\15\nafter the smartparens indicator in the mode list.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Smartparens-Strict mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `smartparens-strict-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'smartparens-global-strict-mode 'globalized-minor-mode t) (defvar smartparens-global-strict-mode nil "\15\nNon-nil if Smartparens-Global-Strict mode is enabled.\15\nSee the `smartparens-global-strict-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `smartparens-global-strict-mode'.") (autoload 'smartparens-global-strict-mode "smartparens" "\15\nToggle Smartparens-Strict mode in all buffers.\15\nWith prefix ARG, enable Smartparens-Global-Strict mode if ARG is\15\npositive; otherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nSmartparens-Strict mode is enabled in all buffers where\15\n`turn-on-smartparens-strict-mode' would do it.\15\n\15\nSee `smartparens-strict-mode' for more information on\15\nSmartparens-Strict mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'turn-on-smartparens-strict-mode "smartparens" "\15\nTurn on `smartparens-strict-mode'." t) (autoload 'turn-off-smartparens-strict-mode "smartparens" "\15\nTurn off `smartparens-strict-mode'." t) (put 'smartparens-global-mode 'globalized-minor-mode t) (defvar smartparens-global-mode nil "\15\nNon-nil if Smartparens-Global mode is enabled.\15\nSee the `smartparens-global-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `smartparens-global-mode'.") (autoload 'smartparens-global-mode "smartparens" "\15\nToggle Smartparens mode in all buffers.\15\nWith prefix ARG, enable Smartparens-Global mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nSmartparens mode is enabled in all buffers where\15\n`turn-on-smartparens-mode' would do it.\15\n\15\nSee `smartparens-mode' for more information on Smartparens mode.\15\n\15\n(fn &optional ARG)" t) (autoload 'turn-on-smartparens-mode "smartparens" "\15\nTurn on `smartparens-mode'.\15\n\15\nThis function is used to turn on `smartparens-global-mode'.\15\n\15\nBy default `smartparens-global-mode' ignores buffers with\15\n`mode-class' set to special, but only if they are also not comint\15\nbuffers.\15\n\15\nAdditionally, buffers on `sp-ignore-modes-list' are ignored.\15\n\15\nYou can still turn on smartparens in these mode manually (or\15\nin mode's startup-hook etc.) by calling `smartparens-mode'." t) (autoload 'turn-off-smartparens-mode "smartparens" "\15\nTurn off `smartparens-mode'." t) (autoload 'show-smartparens-mode "smartparens" "\15\nToggle visualization of matching pairs.  When enabled, any\15\n\15\nmatching pair is highlighted after `sp-show-pair-delay' seconds\15\nof Emacs idle time if the point is immediately in front or after\15\na pair.  This mode works similarly to `show-paren-mode', but\15\nsupport custom pairs.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Show-Smartparens mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `show-smartparens-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'show-smartparens-global-mode 'globalized-minor-mode t) (defvar show-smartparens-global-mode nil "\15\nNon-nil if Show-Smartparens-Global mode is enabled.\15\nSee the `show-smartparens-global-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `show-smartparens-global-mode'.") (autoload 'show-smartparens-global-mode "smartparens" "\15\nToggle Show-Smartparens mode in all buffers.\15\nWith prefix ARG, enable Show-Smartparens-Global mode if ARG is\15\npositive; otherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nShow-Smartparens mode is enabled in all buffers where\15\n`turn-on-show-smartparens-mode' would do it.\15\n\15\nSee `show-smartparens-mode' for more information on Show-Smartparens\15\nmode.\15\n\15\n(fn &optional ARG)" t) (autoload 'turn-on-show-smartparens-mode "smartparens" "\15\nTurn on `show-smartparens-mode'.\15\n\15\nThis function is used to turn on `show-smartparens-global-mode'.\15\n\15\nMajor modes on `sp-ignore-modes-list' are ignored when turning on\15\nthe globalized mode.\15\n\15\nYou can still turn on `show-smartparens-mode' manually by calling\15\n\\[show-smartparens-mode.]" t) (autoload 'turn-off-show-smartparens-mode "smartparens" "\15\nTurn off `show-smartparens-mode'." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/dtrt-indent/dtrt-indent-autoloads.el") (load-true-file-name load-file-name)) (autoload 'dtrt-indent-mode "dtrt-indent" "\15\nToggle dtrt-indent mode.\15\n\15\nWith no argument, this command toggles the mode.  Non-null prefix\15\nargument turns on the mode.  Null prefix argument turns off the\15\nmode.\15\n\15\nWhen dtrt-indent mode is enabled, the proper indentation offset\15\nand `indent-tabs-mode' will be guessed for newly opened files and\15\nadjusted transparently.\15\n\15\nThis is a minor mode.  If called interactively, toggle the `Dtrt-Indent\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `dtrt-indent-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'dtrt-indent-global-mode 'globalized-minor-mode t) (defvar dtrt-indent-global-mode nil "\15\nNon-nil if Dtrt-Indent-Global mode is enabled.\15\nSee the `dtrt-indent-global-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `dtrt-indent-global-mode'.") (autoload 'dtrt-indent-global-mode "dtrt-indent" "\15\nToggle Dtrt-Indent mode in all buffers.\15\nWith prefix ARG, enable Dtrt-Indent-Global mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nDtrt-Indent mode is enabled in all buffers where `dtrt-indent--mode'\15\nwould do it.\15\n\15\nSee `dtrt-indent-mode' for more information on Dtrt-Indent mode.\15\n\15\n(fn &optional ARG)" t) (defvar dtrt-indent-mode nil "\15\nToggle adaptive indentation mode.\15\nSetting this variable directly does not take effect;\15\nuse either \\[customize] or the function `dtrt-indent-mode'.") nil nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/better-jumper/better-jumper-autoloads.el") (load-true-file-name load-file-name)) (autoload 'better-jumper-set-jump "better-jumper" "\15\nSet jump point at POS.\15\nPOS defaults to point.\15\n\15\n(fn &optional POS)" t) (autoload 'better-jumper-jump-backward "better-jumper" "\15\nJump backward COUNT positions to previous location in jump list.\15\nIf COUNT is nil then defaults to 1.\15\n\15\n(fn &optional COUNT)" t) (autoload 'better-jumper-jump-forward "better-jumper" "\15\nJump forward COUNT positions to location in jump list.\15\nIf COUNT is nil then defaults to 1.\15\n\15\n(fn &optional COUNT)" t) (autoload 'better-jumper-jump-newest "better-jumper" "\15\nJump forward to newest entry in jump list." t) (autoload 'better-jumper-clear-jumps "better-jumper" "\15\nClears jump list for WINDOW-OR-BUFFER.\15\nWINDOW-OR-BUFFER should be either a window or buffer depending on the\15\ncontext and will default to current context if not provided.\15\n\15\n(fn &optional WINDOW-OR-BUFFER)" t) (autoload 'better-jumper-get-jumps "better-jumper" "\15\nGet jumps for WINDOW-OR-BUFFER.\15\nWINDOW-OR-BUFFER should be either a window or buffer depending on the\15\ncontext and will default to current context if not provided.\15\n\15\n(fn &optional WINDOW-OR-BUFFER)") (autoload 'better-jumper-set-jumps "better-jumper" "\15\nSet jumps to JUMPS for WINDOW-OR-BUFFER.\15\nWINDOW-OR-BUFFER should be either a window or buffer depending on the\15\ncontext and will default to current context if not provided.\15\n\15\n(fn JUMPS &optional WINDOW-OR-BUFFER)") (autoload 'turn-on-better-jumper-mode "better-jumper" "\15\nEnable better-jumper-mode in the current buffer.") (autoload 'turn-off-better-jumper-mode "better-jumper" "\15\nDisable `better-jumper-local-mode' in the current buffer.") (autoload 'better-jumper-local-mode "better-jumper" "\15\nbetter-jumper minor mode.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`better-jumper-Local mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `better-jumper-local-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'better-jumper-mode 'globalized-minor-mode t) (defvar better-jumper-mode nil "\15\nNon-nil if Better-Jumper mode is enabled.\15\nSee the `better-jumper-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `better-jumper-mode'.") (autoload 'better-jumper-mode "better-jumper" "\15\nToggle Better-Jumper-Local mode in all buffers.\15\nWith prefix ARG, enable Better-Jumper mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nBetter-Jumper-Local mode is enabled in all buffers where\15\n`turn-on-better-jumper-mode' would do it.\15\n\15\nSee `better-jumper-local-mode' for more information on\15\nBetter-Jumper-Local mode.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/restart-emacs/restart-emacs-autoloads.el") (load-true-file-name load-file-name)) (autoload 'restart-emacs-handle-command-line-args "restart-emacs" "\15\nHandle the --restart-emacs-desktop command line argument.\15\n\15\nThe value of the argument is the desktop file from which the frames should be\15\nrestored.  IGNORED are ignored.\15\n\15\n(fn &rest IGNORED)") (add-to-list 'command-switch-alist '("--restart-emacs-desktop" . restart-emacs-handle-command-line-args)) (autoload 'restart-emacs "restart-emacs" "\15\nRestart Emacs.\15\n\15\nWhen called interactively ARGS is interpreted as follows\15\n\15\n- with a single `universal-argument' (`C-u') Emacs is restarted\15\n  with `--debug-init' flag\15\n- with two `universal-argument' (`C-u') Emacs is restarted with\15\n  `-Q' flag\15\n- with three `universal-argument' (`C-u') the user prompted for\15\n  the arguments\15\n\15\nWhen called non-interactively ARGS should be a list of arguments\15\nwith which Emacs should be restarted.\15\n\15\n(fn &optional ARGS)" t) (autoload 'restart-emacs-start-new-emacs "restart-emacs" "\15\nStart a new instance of Emacs.\15\n\15\nWhen called interactively ARGS is interpreted as follows\15\n\15\n- with a single `universal-argument' (`C-u') the new Emacs is started\15\n  with `--debug-init' flag\15\n- with two `universal-argument' (`C-u') the new Emacs is started with\15\n  `-Q' flag\15\n- with three `universal-argument' (`C-u') the user prompted for\15\n  the arguments\15\n\15\nWhen called non-interactively ARGS should be a list of arguments\15\nwith which the new Emacs should be started.\15\n\15\n(fn &optional ARGS)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/rainbow-delimiters/rainbow-delimiters-autoloads.el") (load-true-file-name load-file-name)) (autoload 'rainbow-delimiters-mode "rainbow-delimiters" "\15\nHighlight nested parentheses, brackets, and braces according to their depth.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Rainbow-Delimiters mode' mode.  If the prefix argument is positive,\15\nenable the mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `rainbow-delimiters-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (autoload 'rainbow-delimiters-mode-enable "rainbow-delimiters" "\15\nEnable `rainbow-delimiters-mode'.") (autoload 'rainbow-delimiters-mode-disable "rainbow-delimiters" "\15\nDisable `rainbow-delimiters-mode'.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/highlight-numbers/highlight-numbers-autoloads.el") (load-true-file-name load-file-name)) (autoload 'highlight-numbers-mode "highlight-numbers" "\15\nMinor mode for highlighting numeric literals in source code.\15\n\15\nToggle Highlight Numbers mode on or off.\15\n\15\nWith a prefix argument ARG, enable Highlight Numbers mode if ARG is\15\npositive, and disable it otherwise. If called from Lisp, enable\15\nthe mode if ARG is omitted or nil, and toggle it if ARG is `toggle'.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/hide-mode-line/hide-mode-line-autoloads.el") (load-true-file-name load-file-name)) (autoload 'hide-mode-line-mode "hide-mode-line" "\15\nMinor mode to hide the mode-line in the current buffer.\15\n\15\nThis is a minor mode.  If called interactively, toggle the\15\n`Hide-Mode-Line mode' mode.  If the prefix argument is positive, enable\15\nthe mode, and if it is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate the variable `hide-mode-line-mode'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) (put 'global-hide-mode-line-mode 'globalized-minor-mode t) (defvar global-hide-mode-line-mode nil "\15\nNon-nil if Global Hide-Mode-Line mode is enabled.\15\nSee the `global-hide-mode-line-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `global-hide-mode-line-mode'.") (autoload 'global-hide-mode-line-mode "hide-mode-line" "\15\nToggle Hide-Mode-Line mode in all buffers.\15\nWith prefix ARG, enable Global Hide-Mode-Line mode if ARG is positive;\15\notherwise, disable it.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.\15\nEnable the mode if ARG is nil, omitted, or is a positive number.\15\nDisable the mode if ARG is a negative number.\15\n\15\nHide-Mode-Line mode is enabled in all buffers where\15\n`turn-on-hide-mode-line-mode' would do it.\15\n\15\nSee `hide-mode-line-mode' for more information on Hide-Mode-Line\15\nmode.\15\n\15\n(fn &optional ARG)" t) (autoload 'turn-on-hide-mode-line-mode "hide-mode-line" "\15\nTurn on `hide-mode-line-mode'.\15\nUnless in `fundamental-mode' or `hide-mode-line-excluded-modes'.") (autoload 'turn-off-hide-mode-line-mode "hide-mode-line" "\15\nTurn off `hide-mode-line-mode'.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/straight/straight-autoloads.el") (load-true-file-name load-file-name)) (autoload 'straight-remove-unused-repos "straight" "\15\nRemove unused repositories from the repos and build directories.\15\nA repo is considered \"unused\" if it was not explicitly requested via\15\n`straight-use-package' during the current Emacs session.\15\nIf FORCE is non-nil do not prompt before deleting repos.\15\n\15\n(fn &optional FORCE)" t) (autoload 'straight-get-recipe "straight" "\15\nInteractively select a recipe from one of the recipe repositories.\15\nAll recipe repositories in `straight-recipe-repositories' will\15\nfirst be cloned. After the recipe is selected, it will be copied\15\nto the kill ring. With a prefix argument, first prompt for a\15\nrecipe repository to search. Only that repository will be\15\ncloned.\15\n\15\nFrom Lisp code, SOURCES should be a subset of the symbols in\15\n`straight-recipe-repositories'. Only those recipe repositories\15\nare cloned and searched. If it is nil or omitted, then the value\15\nof `straight-recipe-repositories' is used. If SOURCES is the\15\nsymbol `interactive', then the user is prompted to select a\15\nrecipe repository, and a list containing that recipe repository\15\nis used for the value of SOURCES. ACTION may be `copy' (copy\15\nrecipe to the kill ring), `insert' (insert at point), or nil (no\15\naction, just return it).\15\n\15\nOptional arg FILTER must be a unary function.\15\nIt takes a package name as its sole argument.\15\nIf it returns nil the candidate is excluded.\15\n\15\n(fn &optional SOURCES ACTION FILTER)" t) (autoload 'straight-visit-package-website "straight" "\15\nVisit the package RECIPE's website.\15\n\15\n(fn RECIPE)" t) (autoload 'straight-visit-package "straight" "\15\nOpen PACKAGE's local repository directory.\15\nWhen BUILD is non-nil visit PACKAGE's build directory.\15\n\15\n(fn PACKAGE &optional BUILD)" t) (autoload 'straight-use-package "straight" "\15\nRegister, clone, build, and activate a package and its dependencies.\15\nThis is the main entry point to the functionality of straight.el.\15\n\15\nMELPA-STYLE-RECIPE is either a symbol naming a package, or a list\15\nwhose car is a symbol naming a package and whose cdr is a\15\nproperty list containing e.g. `:type', `:local-repo', `:files',\15\nand VC backend specific keywords.\15\n\15\nFirst, the package recipe is registered with straight.el. If\15\nNO-CLONE is a function, then it is called with two arguments: the\15\npackage name as a string, and a boolean value indicating whether\15\nthe local repository for the package is available. In that case,\15\nthe return value of the function is used as the value of NO-CLONE\15\ninstead. In any case, if NO-CLONE is non-nil, then processing\15\nstops here.\15\n\15\nOtherwise, the repository is cloned, if it is missing. If\15\nNO-BUILD is a function, then it is called with one argument: the\15\npackage name as a string. In that case, the return value of the\15\nfunction is used as the value of NO-BUILD instead. In any case,\15\nif NO-BUILD is non-nil, then processing halts here. Otherwise,\15\nthe package is built and activated. Note that if the package\15\nrecipe has a nil `:build' entry, then NO-BUILD is ignored\15\nand processing always stops before building and activation\15\noccurs.\15\n\15\nCAUSE is a string explaining the reason why\15\n`straight-use-package' has been called. It is for internal use\15\nonly, and is used to construct progress messages. INTERACTIVE is\15\nnon-nil if the function has been called interactively. It is for\15\ninternal use only, and is used to determine whether to show a\15\nhint about how to install the package permanently.\15\n\15\nReturn non-nil when package is initially installed, nil otherwise.\15\n\15\n(fn MELPA-STYLE-RECIPE &optional NO-CLONE NO-BUILD CAUSE INTERACTIVE)" t) (autoload 'straight-register-package "straight" "\15\nRegister a package without cloning, building, or activating it.\15\nThis function is equivalent to calling `straight-use-package'\15\nwith a non-nil argument for NO-CLONE. It is provided for\15\nconvenience. MELPA-STYLE-RECIPE is as for\15\n`straight-use-package'.\15\n\15\n(fn MELPA-STYLE-RECIPE)") (autoload 'straight-use-package-no-build "straight" "\15\nRegister and clone a package without building it.\15\nThis function is equivalent to calling `straight-use-package'\15\nwith nil for NO-CLONE but a non-nil argument for NO-BUILD. It is\15\nprovided for convenience. MELPA-STYLE-RECIPE is as for\15\n`straight-use-package'.\15\n\15\n(fn MELPA-STYLE-RECIPE)") (autoload 'straight-use-package-lazy "straight" "\15\nRegister, build, and activate a package if it is already cloned.\15\nThis function is equivalent to calling `straight-use-package'\15\nwith symbol `lazy' for NO-CLONE. It is provided for convenience.\15\nMELPA-STYLE-RECIPE is as for `straight-use-package'.\15\n\15\n(fn MELPA-STYLE-RECIPE)") (autoload 'straight-use-recipes "straight" "\15\nRegister a recipe repository using MELPA-STYLE-RECIPE.\15\nThis registers the recipe and builds it if it is already cloned.\15\nNote that you probably want the recipe for a recipe repository to\15\ninclude a nil `:build' property, to unconditionally\15\ninhibit the build phase.\15\n\15\nThis function also adds the recipe repository to\15\n`straight-recipe-repositories', at the end of the list.\15\n\15\nExisting recipe repositories are not searched for a recipe for the\15\nrecipe repository you are trying to register, because that is strange\15\nand confusing. If you explicitly want this behavior, you can use the\15\n`straight-use-package' API directly.\15\n\15\n(fn MELPA-STYLE-RECIPE)") (autoload 'straight-override-recipe "straight" "\15\nRegister MELPA-STYLE-RECIPE as a recipe override.\15\nThis puts it in `straight-recipe-overrides', depending on the\15\nvalue of `straight-current-profile'.\15\n\15\n(fn MELPA-STYLE-RECIPE)") (autoload 'straight-check-package "straight" "\15\nRebuild a PACKAGE if it has been modified.\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'. See also `straight-rebuild-package' and\15\n`straight-check-all'.\15\n\15\n(fn PACKAGE)" t) (autoload 'straight-check-all "straight" "\15\nRebuild any packages that have been modified.\15\nSee also `straight-rebuild-all' and `straight-check-package'.\15\nThis function should not be called during init." t) (autoload 'straight-rebuild-package "straight" "\15\nRebuild a PACKAGE.\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'. With prefix argument RECURSIVE, rebuild\15\nall dependencies as well. See also `straight-check-package' and\15\n`straight-rebuild-all'.\15\n\15\n(fn PACKAGE &optional RECURSIVE)" t) (autoload 'straight-rebuild-all "straight" "\15\nRebuild all packages.\15\nSee also `straight-check-all' and `straight-rebuild-package'." t) (autoload 'straight-prune-build-cache "straight" "\15\nPrune the build cache.\15\nThis means that only packages that were built in the last init\15\nrun and subsequent interactive session will remain; other\15\npackages will have their build mtime information and any cached\15\nautoloads discarded.") (autoload 'straight-prune-build-directory "straight" "\15\nPrune the build directory.\15\nThis means that only packages that were built in the last init\15\nrun and subsequent interactive session will remain; other\15\npackages will have their build directories deleted.") (autoload 'straight-prune-build "straight" "\15\nPrune the build cache and build directory.\15\nThis means that only packages that were built in the last init\15\nrun and subsequent interactive session will remain; other\15\npackages will have their build mtime information discarded and\15\ntheir build directories deleted." t) (autoload 'straight-normalize-package "straight" "\15\nNormalize a PACKAGE's local repository to its recipe's configuration.\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'.\15\n\15\n(fn PACKAGE)" t) (autoload 'straight-normalize-all "straight" "\15\nNormalize all packages. See `straight-normalize-package'.\15\nReturn a list of recipes for packages that were not successfully\15\nnormalized. If multiple packages come from the same local\15\nrepository, only one is normalized.\15\n\15\nPREDICATE, if provided, filters the packages that are normalized.\15\nIt is called with the package name as a string, and should return\15\nnon-nil if the package should actually be normalized.\15\n\15\n(fn &optional PREDICATE)" t) (autoload 'straight-fetch-package "straight" "\15\nTry to fetch a PACKAGE from the primary remote.\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\15\nfetch not just from primary remote but also from upstream (for\15\nforked packages).\15\n\15\n(fn PACKAGE &optional FROM-UPSTREAM)" t) (autoload 'straight-fetch-package-and-deps "straight" "\15\nTry to fetch a PACKAGE and its (transitive) dependencies.\15\nPACKAGE, its dependencies, their dependencies, etc. are fetched\15\nfrom their primary remotes.\15\n\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\15\nfetch not just from primary remote but also from upstream (for\15\nforked packages).\15\n\15\n(fn PACKAGE &optional FROM-UPSTREAM)" t) (autoload 'straight-fetch-all "straight" "\15\nTry to fetch all packages from their primary remotes.\15\nWith prefix argument FROM-UPSTREAM, fetch not just from primary\15\nremotes but also from upstreams (for forked packages).\15\n\15\nReturn a list of recipes for packages that were not successfully\15\nfetched. If multiple packages come from the same local\15\nrepository, only one is fetched.\15\n\15\nPREDICATE, if provided, filters the packages that are fetched. It\15\nis called with the package name as a string, and should return\15\nnon-nil if the package should actually be fetched.\15\n\15\n(fn &optional FROM-UPSTREAM PREDICATE)" t) (autoload 'straight-merge-package "straight" "\15\nTry to merge a PACKAGE from the primary remote.\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\15\nmerge not just from primary remote but also from upstream (for\15\nforked packages).\15\n\15\n(fn PACKAGE &optional FROM-UPSTREAM)" t) (autoload 'straight-merge-package-and-deps "straight" "\15\nTry to merge a PACKAGE and its (transitive) dependencies.\15\nPACKAGE, its dependencies, their dependencies, etc. are merged\15\nfrom their primary remotes.\15\n\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\15\nmerge not just from primary remote but also from upstream (for\15\nforked packages).\15\n\15\n(fn PACKAGE &optional FROM-UPSTREAM)" t) (autoload 'straight-merge-all "straight" "\15\nTry to merge all packages from their primary remotes.\15\nWith prefix argument FROM-UPSTREAM, merge not just from primary\15\nremotes but also from upstreams (for forked packages).\15\n\15\nReturn a list of recipes for packages that were not successfully\15\nmerged. If multiple packages come from the same local\15\nrepository, only one is merged.\15\n\15\nPREDICATE, if provided, filters the packages that are merged. It\15\nis called with the package name as a string, and should return\15\nnon-nil if the package should actually be merged.\15\n\15\n(fn &optional FROM-UPSTREAM PREDICATE)" t) (autoload 'straight-pull-package "straight" "\15\nTry to pull a PACKAGE from the primary remote.\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'. With prefix argument FROM-UPSTREAM, pull\15\nnot just from primary remote but also from upstream (for forked\15\npackages).\15\n\15\n(fn PACKAGE &optional FROM-UPSTREAM)" t) (autoload 'straight-pull-package-and-deps "straight" "\15\nTry to pull a PACKAGE and its (transitive) dependencies.\15\nPACKAGE, its dependencies, their dependencies, etc. are pulled\15\nfrom their primary remotes.\15\n\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'. With prefix argument FROM-UPSTREAM,\15\npull not just from primary remote but also from upstream (for\15\nforked packages).\15\n\15\n(fn PACKAGE &optional FROM-UPSTREAM)" t) (autoload 'straight-pull-all "straight" "\15\nTry to pull all packages from their primary remotes.\15\nWith prefix argument FROM-UPSTREAM, pull not just from primary\15\nremotes but also from upstreams (for forked packages).\15\n\15\nReturn a list of recipes for packages that were not successfully\15\npulled. If multiple packages come from the same local repository,\15\nonly one is pulled.\15\n\15\nPREDICATE, if provided, filters the packages that are pulled. It\15\nis called with the package name as a string, and should return\15\nnon-nil if the package should actually be pulled.\15\n\15\n(fn &optional FROM-UPSTREAM PREDICATE)" t) (autoload 'straight-push-package "straight" "\15\nPush a PACKAGE to its primary remote, if necessary.\15\nPACKAGE is a string naming a package. Interactively, select\15\nPACKAGE from the known packages in the current Emacs session\15\nusing `completing-read'.\15\n\15\n(fn PACKAGE)" t) (autoload 'straight-push-all "straight" "\15\nTry to push all packages to their primary remotes.\15\n\15\nReturn a list of recipes for packages that were not successfully\15\npushed. If multiple packages come from the same local repository,\15\nonly one is pushed.\15\n\15\nPREDICATE, if provided, filters the packages that are normalized.\15\nIt is called with the package name as a string, and should return\15\nnon-nil if the package should actually be normalized.\15\n\15\n(fn &optional PREDICATE)" t) (autoload 'straight-freeze-versions "straight" "\15\nWrite version lockfiles for currently activated packages.\15\nThis implies first pushing all packages that have unpushed local\15\nchanges. If the package management system has been used since the\15\nlast time the init-file was reloaded, offer to fix the situation\15\nby reloading the init-file again. If FORCE is\15\nnon-nil (interactively, if a prefix argument is provided), skip\15\nall checks and write the lockfile anyway.\15\n\15\nCurrently, writing version lockfiles requires cloning all lazily\15\ninstalled packages. Hopefully, this inconvenient requirement will\15\nbe removed in the future.\15\n\15\nMultiple lockfiles may be written (one for each profile),\15\naccording to the value of `straight-profiles'.\15\n\15\n(fn &optional FORCE)" t) (autoload 'straight-thaw-versions "straight" "\15\nRead version lockfiles and restore package versions to those listed." t) (autoload 'straight-bug-report "straight" "\15\nTest straight.el in a clean environment.\15\nARGS may be any of the following keywords and their respective values:\15\n  - :pre-bootstrap (Form)...\15\n      Forms evaluated before bootstrapping straight.el\15\n      e.g. (setq straight-repository-branch \"develop\")\15\n      Note this example is already in the default bootstrapping code.\15\n\15\n  - :post-bootstrap (Form)...\15\n      Forms evaluated in the testing environment after boostrapping.\15\n      e.g. (straight-use-package \\='(example :type git :host github))\15\n\15\n  - :interactive Boolean\15\n      If nil, the subprocess will immediately exit after the test.\15\n      Output will be printed to `straight-bug-report--process-buffer'\15\n      Otherwise, the subprocess will be interactive.\15\n\15\n  - :preserve Boolean\15\n      If non-nil, the test directory is left in the directory stored in the\15\n      variable `temporary-file-directory'. Otherwise, it is\15\n      immediately removed after the test is run.\15\n\15\n  - :executable String\15\n      Indicate the Emacs executable to launch.\15\n      Defaults to the path of the current Emacs executable.\15\n\15\n  - :raw Boolean\15\n      If non-nil, the raw process output is sent to\15\n      `straight-bug-report--process-buffer'. Otherwise, it is\15\n      formatted as markdown for submitting as an issue.\15\n\15\n  - :user-dir String\15\n      If non-nil, the test is run with `user-emacs-directory' set to STRING.\15\n      Otherwise, a temporary directory is created and used.\15\n      Unless absolute, paths are expanded relative to the variable\15\n      `temporary-file-directory'.\15\n\15\nARGS are accessible within the :pre/:post-bootsrap phases via the\15\nlocally bound plist, straight-bug-report-args.\15\n\15\n(fn &rest ARGS)" nil t) (function-put 'straight-bug-report 'lisp-indent-function 0) (autoload 'straight-dependencies "straight" "\15\nReturn a list of PACKAGE's dependencies.\15\n\15\n(fn &optional PACKAGE)" t) (autoload 'straight-dependents "straight" "\15\nReturn a list of PACKAGE's dependents.\15\n\15\n(fn &optional PACKAGE)" t) (defvar straight-x-pinned-packages nil "\15\nList of pinned packages.") nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/gcmh/gcmh-autoloads.el") (load-true-file-name load-file-name)) (defvar gcmh-mode nil "\15\nNon-nil if GCMH mode is enabled.\15\nSee the `gcmh-mode' command\15\nfor a description of this minor mode.\15\nSetting this variable directly does not take effect;\15\neither customize it (see the info node `Easy Customization')\15\nor call the function `gcmh-mode'.") (autoload 'gcmh-mode "gcmh" "\15\nMinor mode to tweak Garbage Collection strategy.\15\n\15\nThis is a global minor mode.  If called interactively, toggle the `GCMH\15\nmode' mode.  If the prefix argument is positive, enable the mode, and if\15\nit is zero or negative, disable the mode.\15\n\15\nIf called from Lisp, toggle the mode if ARG is `toggle'.  Enable the\15\nmode if ARG is nil, omitted, or is a positive number.  Disable the mode\15\nif ARG is a negative number.\15\n\15\nTo check whether the minor mode is enabled in the current buffer,\15\nevaluate `(default-value \\='gcmh-mode)'.\15\n\15\nThe mode's hook is called both when the mode is enabled and when it is\15\ndisabled.\15\n\15\n(fn &optional ARG)" t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/auto-minor-mode/auto-minor-mode-autoloads.el") (load-true-file-name load-file-name)) (defvar auto-minor-mode-alist nil "\15\nAlist of filename patterns vs corresponding minor mode functions.\15\n\15\nThis is an equivalent of \x2018\ auto-mode-alist\x2019, for minor modes.\15\n\15\nUnlike \x2018\ auto-mode-alist\x2019, matching is always case-folded.") (defvar auto-minor-mode-magic-alist nil "\15\nAlist of buffer beginnings vs corresponding minor mode functions.\15\n\15\nThis is an equivalent of \x2018magic-mode-alist\x2019, for minor modes.\15\n\15\nMagic minor modes are applied after \x2018set-auto-mode\x2019 enables any\15\nmajor mode, so it\x2019s possible to check for expected major modes in\15\nmatch functions.\15\n\15\nUnlike \x2018magic-mode-alist\x2019, matching is always case-folded.") (autoload 'auto-minor-mode-set "auto-minor-mode" "\15\nEnable all minor modes appropriate for the current buffer.\15\n\15\nIf the optional argument KEEP-MODE-IF-SAME is non-nil, then we\15\ndon\x2019t re-activate minor modes already enabled in the buffer.\15\n\15\n(fn &optional KEEP-MODE-IF-SAME)") (advice-add #'set-auto-mode :after #'auto-minor-mode-set) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/bind-key/bind-key-autoloads.el") (load-true-file-name load-file-name)) (defvar personal-keybindings nil "\15\nList of bindings performed by `bind-key'.\15\n\15\nElements have the form ((KEY . [MAP]) CMD ORIGINAL-CMD)") (autoload 'bind-key "bind-key" "\15\nBind KEY-NAME to COMMAND in KEYMAP (`global-map' if not passed).\15\n\15\nKEY-NAME may be a vector, in which case it is passed straight to\15\n`define-key'.  Or it may be a string to be interpreted as\15\nspelled-out keystrokes, e.g., \"C-c C-z\".  See the documentation\15\nof `edmacro-mode' for details.\15\n\15\nCOMMAND must be an interactive function or lambda form.\15\n\15\nKEYMAP, if present, should be a keymap variable or symbol.\15\nFor example:\15\n\15\n  (bind-key \"M-h\" #\\='some-interactive-function my-mode-map)\15\n\15\n  (bind-key \"M-h\" #\\='some-interactive-function \\='my-mode-map)\15\n\15\nIf PREDICATE is non-nil, it is a form evaluated to determine when\15\na key should be bound. It must return non-nil in such cases.\15\nEmacs can evaluate this form at any time that it does redisplay\15\nor operates on menu data structures, so you should write it so it\15\ncan safely be called at any time.\15\n\15\n(fn KEY-NAME COMMAND &optional KEYMAP PREDICATE)" nil t) (autoload 'unbind-key "bind-key" "\15\nUnbind the given KEY-NAME, within the KEYMAP (if specified).\15\nSee `bind-key' for more details.\15\n\15\n(fn KEY-NAME &optional KEYMAP)" nil t) (autoload 'bind-key* "bind-key" "\15\nSimilar to `bind-key', but overrides any mode-specific bindings.\15\n\15\n(fn KEY-NAME COMMAND &optional PREDICATE)" nil t) (autoload 'bind-keys "bind-key" "\15\nBind multiple keys at once.\15\n\15\nAccepts keyword arguments:\15\n:map MAP               - a keymap into which the keybindings should be\15\n                         added\15\n:prefix KEY            - prefix key for these bindings\15\n:prefix-map MAP        - name of the prefix map that should be created\15\n                         for these bindings\15\n:prefix-docstring STR  - docstring for the prefix-map variable\15\n:menu-name NAME        - optional menu string for prefix map\15\n:repeat-docstring STR  - docstring for the repeat-map variable\15\n:repeat-map MAP        - name of the repeat map that should be created\15\n                         for these bindings. If specified, the\15\n                         `repeat-map' property of each command bound\15\n                         (within the scope of the `:repeat-map' keyword)\15\n                         is set to this map.\15\n:exit BINDINGS         - Within the scope of `:repeat-map' will bind the\15\n                         key in the repeat map, but will not set the\15\n                         `repeat-map' property of the bound command.\15\n:continue BINDINGS     - Within the scope of `:repeat-map' forces the\15\n                         same behavior as if no special keyword had\15\n                         been used (that is, the command is bound, and\15\n                         it's `repeat-map' property set)\15\n:filter FORM           - optional form to determine when bindings apply\15\n\15\nThe rest of the arguments are conses of keybinding string and a\15\nfunction symbol (unquoted).\15\n\15\n(fn &rest ARGS)" nil t) (autoload 'bind-keys* "bind-key" "\15\nBind multiple keys at once, in `override-global-map'.\15\nAccepts the same keyword arguments as `bind-keys' (which see).\15\n\15\nThis binds keys in such a way that bindings are not overridden by\15\nother modes.  See `override-global-mode'.\15\n\15\n(fn &rest ARGS)" nil t) (autoload 'describe-personal-keybindings "bind-key" "\15\nDisplay all the personal keybindings defined by `bind-key'." t) nil) (let* ((load-file-name "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/use-package/use-package-autoloads.el") (load-true-file-name load-file-name)) (autoload 'use-package-autoload-keymap "use-package-bind-key" "\15\nLoad PACKAGE and bind key sequence invoking this function to KEYMAP-SYMBOL.\15\nThen simulate pressing the same key sequence a again, so that the\15\nnext key pressed is routed to the newly loaded keymap.\15\n\15\nThis function supports use-package's :bind-keymap keyword.  It\15\nworks by binding the given key sequence to an invocation of this\15\nfunction for a particular keymap.  The keymap is expected to be\15\ndefined by the package.  In this way, loading the package is\15\ndeferred until the prefix key sequence is pressed.\15\n\15\n(fn KEYMAP-SYMBOL PACKAGE OVERRIDE)") (autoload 'use-package-normalize-binder "use-package-bind-key" "\15\n\15\n\15\n(fn NAME KEYWORD ARGS)") (defalias 'use-package-normalize/:bind 'use-package-normalize-binder) (defalias 'use-package-normalize/:bind* 'use-package-normalize-binder) (defalias 'use-package-autoloads/:bind 'use-package-autoloads-mode) (defalias 'use-package-autoloads/:bind* 'use-package-autoloads-mode) (autoload 'use-package-handler/:bind "use-package-bind-key" "\15\n\15\n\15\n(fn NAME KEYWORD ARGS REST STATE &optional BIND-MACRO)") (defalias 'use-package-normalize/:bind-keymap 'use-package-normalize-binder) (defalias 'use-package-normalize/:bind-keymap* 'use-package-normalize-binder) (autoload 'use-package-handler/:bind-keymap "use-package-bind-key" "\15\n\15\n\15\n(fn NAME KEYWORD ARGS REST STATE &optional OVERRIDE)") (autoload 'use-package-handler/:bind-keymap* "use-package-bind-key" "\15\n\15\n\15\n(fn NAME KEYWORD ARG REST STATE)") (autoload 'use-package "use-package-core" "\15\nDeclare an Emacs package by specifying a group of configuration options.\15\n\15\nFor the full documentation, see Info node `(use-package) top'.\15\nUsage:\15\n\15\n  (use-package package-name\15\n     [:keyword [option]]...)\15\n\15\n:init            Code to run before PACKAGE-NAME has been loaded.\15\n:config          Code to run after PACKAGE-NAME has been loaded.  Note that\15\n                 if loading is deferred for any reason, this code does not\15\n                 execute until the lazy load has occurred.\15\n:preface         Code to be run before everything except `:disabled'; this\15\n                 can be used to define functions for use in `:if', or that\15\n                 should be seen by the byte-compiler.\15\n\15\n:mode            Form to be added to `auto-mode-alist'.\15\n:magic           Form to be added to `magic-mode-alist'.\15\n:magic-fallback  Form to be added to `magic-fallback-mode-alist'.\15\n:interpreter     Form to be added to `interpreter-mode-alist'.\15\n\15\n:commands        Define autoloads for commands defined by the package.\15\n                 This is useful if the package is being lazily loaded,\15\n                 and you wish to conditionally call functions in your\15\n                 `:init' block that are defined in the package.\15\n:autoload        Similar to `:commands', but used for non-interactive functions.\15\n:hook            Specify hook(s) to attach this package to.\15\n\15\n:bind            Bind keys, and define autoloads for the bound commands.\15\n:bind*           Bind keys, and define autoloads for the bound commands,\15\n                 *overriding all minor mode bindings*.\15\n:bind-keymap     Bind a key prefix to an auto-loaded keymap defined in the\15\n                 package.  This is like `:bind', but for keymaps.\15\n:bind-keymap*    Like `:bind-keymap', but overrides all minor mode bindings\15\n\15\n:defer           Defer loading of a package -- this is implied when using\15\n                 `:commands', `:bind', `:bind*', `:mode', `:magic', `:hook',\15\n                 `:magic-fallback', or `:interpreter'.  This can be an integer,\15\n                 to force loading after N seconds of idle time, if the package\15\n                 has not already been loaded.\15\n:demand          Prevent the automatic deferred loading introduced by constructs\15\n                 such as `:bind' (see `:defer' for the complete list).\15\n\15\n:after           Delay the effect of the use-package declaration\15\n                 until after the named libraries have loaded.\15\n                 Before they have been loaded, no other keyword\15\n                 has any effect at all, and once they have been\15\n                 loaded it is as if `:after' was not specified.\15\n\15\n:if EXPR         Initialize and load only if EXPR evaluates to a non-nil value.\15\n:disabled        The package is ignored completely if this keyword is present.\15\n:defines         Declare certain variables to silence the byte-compiler.\15\n:functions       Declare certain functions to silence the byte-compiler.\15\n:load-path       Add to the `load-path' before attempting to load the package.\15\n:diminish        Support for diminish.el (if installed).\15\n:delight         Support for delight.el (if installed).\15\n:custom          Call `Custom-set' or `set-default' with each variable\15\n                 definition without modifying the Emacs `custom-file'.\15\n                 (compare with `custom-set-variables').\15\n:custom-face     Call `face-spec-set' with each face definition.\15\n:ensure          Loads the package using package.el if necessary.\15\n:pin             Pin the package to an archive.\15\n:vc              Install the package directly from a version control system\15\n                 (using `package-vc.el').\15\n\15\n(fn NAME &rest ARGS)" nil t) (function-put 'use-package 'lisp-indent-function 'defun) (autoload 'use-package-normalize/:delight "use-package-delight" "\15\nNormalize arguments to delight.\15\n\15\n(fn NAME KEYWORD ARGS)") (autoload 'use-package-handler/:delight "use-package-delight" "\15\n\15\n\15\n(fn NAME KEYWORD ARGS REST STATE)") (autoload 'use-package-normalize/:diminish "use-package-diminish" "\15\n\15\n\15\n(fn NAME KEYWORD ARGS)") (autoload 'use-package-handler/:diminish "use-package-diminish" "\15\n\15\n\15\n(fn NAME KEYWORD ARG REST STATE)") (autoload 'use-package-normalize/:ensure "use-package-ensure" "\15\n\15\n\15\n(fn NAME KEYWORD ARGS)") (autoload 'use-package-handler/:ensure "use-package-ensure" "\15\n\15\n\15\n(fn NAME KEYWORD ENSURE REST STATE)") (autoload 'use-package-normalize/:ensure-system-package "use-package-ensure-system-package" "\15\nTurn ARGS into a list of conses of the form (PACKAGE-NAME . INSTALL-COMMAND).\15\n\15\n(fn NAME-SYMBOL KEYWORD ARGS)") (autoload 'use-package-handler/:ensure-system-package "use-package-ensure-system-package" "\15\nExecute the handler for `:ensure-system-package' keyword in `use-package'.\15\n\15\n(fn NAME KEYWORD ARG REST STATE)") (autoload 'use-package-jump-to-package-form "use-package-jump" "\15\nAttempt to find and jump to the `use-package' form that loaded PACKAGE.\15\nThis will only find the form if that form actually required\15\nPACKAGE.  If PACKAGE was previously required then this function\15\nwill jump to the file that originally required PACKAGE instead.\15\n\15\n(fn PACKAGE)" t) (autoload 'use-package-lint "use-package-lint" "\15\nCheck for errors in `use-package' declarations.\15\nFor example, if the module's `:if' condition is met, but even\15\nwith the specified `:load-path' the module cannot be found." t) nil)) (require 'info) (info-initialize) (setq Info-directory-list (append '("c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/use-package/" "c:/Users/jiacs/dotfiles/doom-emacs/.local/straight/build-30.1/org/") Info-directory-list)))(set 'doom-modules '#s(hash-table test equal data ((:doom) #s(doom-module 0 :doom nil (-110 . -110) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/lisp/") (:user) #s(doom-module 1 :user nil (-105 . 105) nil nil "c:/Users/jiacs/dotfiles/.doom.d/") (:config . use-package) #s(doom-module 2 :config use-package (-111 . -111) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/config/use-package") (:completion . corfu) #s(doom-module 3 :completion corfu (0 . 0) (+orderless) nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/corfu") (:completion . vertico) #s(doom-module 4 :completion vertico (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/vertico") (:ui . doom) #s(doom-module 5 :ui doom (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/doom") (:ui . doom-dashboard) #s(doom-module 6 :ui doom-dashboard (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/doom-dashboard") (:ui . hl-todo) #s(doom-module 7 :ui hl-todo (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/hl-todo") (:ui . modeline) #s(doom-module 8 :ui modeline (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/modeline") (:ui . ophints) #s(doom-module 9 :ui ophints (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/ophints") (:ui . popup) #s(doom-module 10 :ui popup (0 . 0) (+defaults) nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/popup") (:ui . vc-gutter) #s(doom-module 11 :ui vc-gutter (0 . 0) (+pretty) nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/vc-gutter") (:ui . vi-tilde-fringe) #s(doom-module 12 :ui vi-tilde-fringe (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/vi-tilde-fringe") (:ui . workspaces) #s(doom-module 13 :ui workspaces (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/workspaces") (:editor . evil) #s(doom-module 14 :editor evil (0 . 0) (+everywhere) nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/evil") (:editor . file-templates) #s(doom-module 15 :editor file-templates (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/file-templates") (:editor . fold) #s(doom-module 16 :editor fold (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/fold") (:editor . snippets) #s(doom-module 17 :editor snippets (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/snippets") (:emacs . dired) #s(doom-module 18 :emacs dired (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/dired") (:emacs . electric) #s(doom-module 19 :emacs electric (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/electric") (:emacs . undo) #s(doom-module 20 :emacs undo (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/undo") (:emacs . vc) #s(doom-module 21 :emacs vc (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/vc") (:checkers . syntax) #s(doom-module 22 :checkers syntax (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/checkers/syntax") (:tools . eval) #s(doom-module 23 :tools eval (0 . 0) (+overlay) nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/eval") (:tools . lookup) #s(doom-module 24 :tools lookup (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lookup") (:tools . magit) #s(doom-module 25 :tools magit (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/magit") (:lang . emacs-lisp) #s(doom-module 26 :lang emacs-lisp (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/emacs-lisp") (:lang . markdown) #s(doom-module 27 :lang markdown (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/markdown") (:lang . org) #s(doom-module 28 :lang org (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org") (:lang . sh) #s(doom-module 29 :lang sh (0 . 0) nil nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/sh") (:config . default) #s(doom-module 30 :config default (0 . 0) (+bindings +smartparens) nil "c:/Users/jiacs/dotfiles/doom-emacs/modules/config/default"))))(set 'doom-disabled-packages 'nil)(setplist ':doom '(nil #s(doom-module-context 0 (:doom) "c:/Users/jiacs/dotfiles/doom-emacs/lisp/" nil nil)))(setplist ':completion '(corfu #s(doom-module-context 3 (:completion . corfu) "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/corfu" (+orderless) nil) vertico #s(doom-module-context 4 (:completion . vertico) "c:/Users/jiacs/dotfiles/doom-emacs/modules/completion/vertico" nil nil)))(setplist ':ui '(doom #s(doom-module-context 5 (:ui . doom) "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/doom" nil nil) doom-dashboard #s(doom-module-context 6 (:ui . doom-dashboard) "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/doom-dashboard" nil nil) hl-todo #s(doom-module-context 7 (:ui . hl-todo) "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/hl-todo" nil nil) modeline #s(doom-module-context 8 (:ui . modeline) "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/modeline" nil nil) ophints #s(doom-module-context 9 (:ui . ophints) "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/ophints" nil nil) popup #s(doom-module-context 10 (:ui . popup) "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/popup" (+defaults) nil) vc-gutter #s(doom-module-context 11 (:ui . vc-gutter) "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/vc-gutter" (+pretty) nil) vi-tilde-fringe #s(doom-module-context 12 (:ui . vi-tilde-fringe) "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/vi-tilde-fringe" nil nil) workspaces #s(doom-module-context 13 (:ui . workspaces) "c:/Users/jiacs/dotfiles/doom-emacs/modules/ui/workspaces" nil nil)))(setplist ':editor '(evil #s(doom-module-context 14 (:editor . evil) "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/evil" (+everywhere) nil) file-templates #s(doom-module-context 15 (:editor . file-templates) "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/file-templates" nil nil) fold #s(doom-module-context 16 (:editor . fold) "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/fold" nil nil) snippets #s(doom-module-context 17 (:editor . snippets) "c:/Users/jiacs/dotfiles/doom-emacs/modules/editor/snippets" nil nil)))(setplist ':emacs '(dired #s(doom-module-context 18 (:emacs . dired) "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/dired" nil nil) electric #s(doom-module-context 19 (:emacs . electric) "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/electric" nil nil) undo #s(doom-module-context 20 (:emacs . undo) "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/undo" nil nil) vc #s(doom-module-context 21 (:emacs . vc) "c:/Users/jiacs/dotfiles/doom-emacs/modules/emacs/vc" nil nil)))(setplist ':checkers '(syntax #s(doom-module-context 22 (:checkers . syntax) "c:/Users/jiacs/dotfiles/doom-emacs/modules/checkers/syntax" nil nil)))(setplist ':tools '(eval #s(doom-module-context 23 (:tools . eval) "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/eval" (+overlay) nil) lookup #s(doom-module-context 24 (:tools . lookup) "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/lookup" nil nil) magit #s(doom-module-context 25 (:tools . magit) "c:/Users/jiacs/dotfiles/doom-emacs/modules/tools/magit" nil nil)))(setplist ':lang '(emacs-lisp #s(doom-module-context 26 (:lang . emacs-lisp) "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/emacs-lisp" nil nil) markdown #s(doom-module-context 27 (:lang . markdown) "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/markdown" nil nil) org #s(doom-module-context 28 (:lang . org) "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/org" nil nil) sh #s(doom-module-context 29 (:lang . sh) "c:/Users/jiacs/dotfiles/doom-emacs/modules/lang/sh" nil nil)))(setplist ':config '(use-package #s(doom-module-context 2 (:config . use-package) "c:/Users/jiacs/dotfiles/doom-emacs/modules/config/use-package" nil nil) default #s(doom-module-context 30 (:config . default) "c:/Users/jiacs/dotfiles/doom-emacs/modules/config/default" (+bindings +smartparens) nil)))(setplist ':user '(nil #s(doom-module-context 1 (:user) "c:/Users/jiacs/dotfiles/.doom.d/" nil nil)))(defun doom--startup-modules nil (with-doom-context 'module (let ((old-custom-file custom-file)) (with-doom-context 'init (with-doom-module '(:config . use-package) (doom-load "~/doom-emacs/modules/config/use-package/init" t)) (with-doom-module '(:doom) (doom-load (file-name-concat doom-core-dir "init") t)) (doom-run-hooks 'doom-before-modules-init-hook) (doom-run-hooks 'doom-after-modules-init-hook)) (with-doom-context 'config (doom-run-hooks 'doom-before-modules-config-hook) (with-doom-module '(:completion . corfu) (doom-load "~/doom-emacs/modules/completion/corfu/config" t)) (with-doom-module '(:completion . vertico) (doom-load "~/doom-emacs/modules/completion/vertico/config" t)) (with-doom-module '(:ui . doom) (doom-load "~/doom-emacs/modules/ui/doom/config" t)) (with-doom-module '(:ui . doom-dashboard) (doom-load "~/doom-emacs/modules/ui/doom-dashboard/config" t)) (with-doom-module '(:ui . hl-todo) (doom-load "~/doom-emacs/modules/ui/hl-todo/config" t)) (with-doom-module '(:ui . modeline) (doom-load "~/doom-emacs/modules/ui/modeline/config" t)) (with-doom-module '(:ui . ophints) (doom-load "~/doom-emacs/modules/ui/ophints/config" t)) (with-doom-module '(:ui . popup) (doom-load "~/doom-emacs/modules/ui/popup/config" t)) (with-doom-module '(:ui . vc-gutter) (doom-load "~/doom-emacs/modules/ui/vc-gutter/config" t)) (with-doom-module '(:ui . workspaces) (doom-load "~/doom-emacs/modules/ui/workspaces/config" t)) (with-doom-module '(:editor . evil) (doom-load "~/doom-emacs/modules/editor/evil/config" t)) (with-doom-module '(:editor . file-templates) (doom-load "~/doom-emacs/modules/editor/file-templates/config" t)) (with-doom-module '(:editor . fold) (doom-load "~/doom-emacs/modules/editor/fold/config" t)) (with-doom-module '(:editor . snippets) (doom-load "~/doom-emacs/modules/editor/snippets/config" t)) (with-doom-module '(:emacs . dired) (doom-load "~/doom-emacs/modules/emacs/dired/config" t)) (with-doom-module '(:emacs . electric) (doom-load "~/doom-emacs/modules/emacs/electric/config" t)) (with-doom-module '(:emacs . undo) (doom-load "~/doom-emacs/modules/emacs/undo/config" t)) (with-doom-module '(:emacs . vc) (doom-load "~/doom-emacs/modules/emacs/vc/config" t)) (with-doom-module '(:checkers . syntax) (doom-load "~/doom-emacs/modules/checkers/syntax/config" t)) (with-doom-module '(:tools . eval) (doom-load "~/doom-emacs/modules/tools/eval/config" t)) (with-doom-module '(:tools . lookup) (doom-load "~/doom-emacs/modules/tools/lookup/config" t)) (with-doom-module '(:tools . magit) (doom-load "~/doom-emacs/modules/tools/magit/config" t)) (with-doom-module '(:lang . emacs-lisp) (doom-load "~/doom-emacs/modules/lang/emacs-lisp/config" t)) (with-doom-module '(:lang . markdown) (doom-load "~/doom-emacs/modules/lang/markdown/config" t)) (with-doom-module '(:lang . org) (doom-load "~/doom-emacs/modules/lang/org/config" t)) (with-doom-module '(:lang . sh) (doom-load "~/doom-emacs/modules/lang/sh/config" t)) (with-doom-module '(:config . default) (doom-load "~/doom-emacs/modules/config/default/config" t)) (doom-run-hooks 'doom-after-modules-config-hook) (with-doom-module '(:user) (doom-load (file-name-concat doom-user-dir "config") t))) (when (eq custom-file old-custom-file) (doom-load custom-file 'noerror)))))(defun doom-startup nil (when (or (doom-context-p 'startup) (doom-context-p 'reload)) (doom--startup-vars) (doom--startup-loaddefs-doom) (doom--startup-loaddefs-packages) (doom--startup-modules)))